# Copyright (c) Facebook, Inc. and its affiliates.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import doctest
import os
import sys
from enum import Enum
from typing import Dict, Iterable, List, TextIO


class Target(Enum):
    NAME = 0
    THRIFT = 1


THRIFT_HEADER = f"""# This file was generated by `thrift/test/testset/generator.py`
# {'@'}generated

namespace cpp2 apache.thrift.test.testset
"""

PRIMITIVE_TYPES = (
    "bool",
    "byte",
    "i16",
    "i32",
    "i64",
    "float",
    "double",
    "binary",
    "string",
)

PRIMATIVE_TRANSFORM: Dict[Target, str] = {
    Target.NAME: "{}",
    Target.THRIFT: "{}",
}

STRUCT_TRANSFORM: Dict[Target, str] = {
    Target.NAME: "struct_{}",
    Target.THRIFT: "struct {}",
}

UNION_TRANSFORM: Dict[Target, str] = {
    Target.NAME: "union_{}",
    Target.THRIFT: "union {}",
}

EXCEPTION_TRANSFORM: Dict[Target, str] = {
    Target.NAME: "exception_{}",
    Target.THRIFT: "exception {}",
}

LIST_TRANSFORM: Dict[Target, str] = {
    Target.NAME: "list_{}",
    Target.THRIFT: "list<{}>",
}

SET_TRANSFORM: Dict[Target, str] = {
    Target.NAME: "set_{}",
    Target.THRIFT: "set<{}>",
}

MAP_TRANSFORM: Dict[Target, str] = {
    Target.NAME: "map_{}_{}",
    Target.THRIFT: "map<{}, {}>",
}

OPTIONAL_TRANSFORM: Dict[Target, str] = {
    Target.NAME: "optional_{}",
    Target.THRIFT: "optional {}",
}

REQUIRED_TRANSFORM: Dict[Target, str] = {
    Target.NAME: "required_{}",
    Target.THRIFT: "required {}",
}

CPP_REF_TRANSFORM: Dict[Target, str] = {
    Target.NAME: "{}_cpp_ref",
    Target.THRIFT: "{} (cpp.ref = 'true')",
}


def gen_primatives(
    target: Target, prims: Iterable[str] = PRIMITIVE_TYPES
) -> Dict[str, str]:
    result = {}
    for prim in prims:
        value = PRIMATIVE_TRANSFORM[target].format(prim)
        result[PRIMATIVE_TRANSFORM[Target.NAME].format(prim)] = value
    return result


def _gen_unary_tramsform(
    transform: Dict[Target, str], target: Target, values: Dict[str, str]
) -> Dict[str, str]:
    result = {}
    for name, value_t in values.items():
        result[transform[Target.NAME].format(name)] = transform[target].format(value_t)
    return result


def gen_lists(target: Target, values: Dict[str, str]) -> Dict[str, str]:
    return _gen_unary_tramsform(LIST_TRANSFORM, target, values)


def gen_sets(target: Target, values: Dict[str, str]) -> Dict[str, str]:
    return _gen_unary_tramsform(SET_TRANSFORM, target, values)


def gen_maps(
    target: Target, keys: Dict[str, str], values: Dict[str, str]
) -> Dict[str, str]:
    result = {}
    for key_name, key_t in keys.items():
        for value_name, value_t in values.items():
            name = MAP_TRANSFORM[Target.NAME].format(key_name, value_name)
            value = MAP_TRANSFORM[target].format(key_t, value_t)
            result[name] = value
    return result


def gen_optional(target: Target, values: Dict[str, str]) -> Dict[str, str]:
    return _gen_unary_tramsform(OPTIONAL_TRANSFORM, target, values)


def gen_required(target: Target, values: Dict[str, str]) -> Dict[str, str]:
    return _gen_unary_tramsform(REQUIRED_TRANSFORM, target, values)


def gen_cpp_ref(target: Target, values: Dict[str, str]) -> Dict[str, str]:
    return _gen_unary_tramsform(CPP_REF_TRANSFORM, target, values)


def gen_union_fields(target: Target) -> Dict[str, str]:
    """Generates field name -> type that are appropriate for use in unions."""
    ret = gen_primatives(target, PRIMITIVE_TYPES)
    ret.update(gen_sets(target, ret))
    ret.update(gen_maps(target, gen_primatives(target, ["string"]), ret))
    ret.update(gen_cpp_ref(target, ret))
    return ret


def gen_struct_fields(target: Target) -> Dict[str, str]:
    """Generates field name -> type that are appropriate for use in structs."""
    ret = gen_union_fields(target)
    ret.update(**gen_optional(target, ret), **gen_required(target, ret))
    return ret


def gen_thrift_def(
    transform: Dict[Target, str], name: str, field_types: List[str]
) -> str:
    """Generate thrift struct from types
    >>> print(gen_thrift_def(STRUCT_TRANSFORM, "Foo", ["i64", "optional string", "set<i32> (cpp.ref = 'true')"]))
    struct Foo {
      1: i64 field_1;
      2: optional string field_2;
      3: set<i32> (cpp.ref = 'true') field_3;
    } (thrift.uri="facebook.com/thrift/test/testset/Foo")
    """
    decl = transform[Target.THRIFT].format(name)
    lines = [f"{decl} {{"]
    for idx, field_type in enumerate(field_types):
        lines.append("  {0}: {1} field_{0};".format(idx + 1, field_type))
    lines.append(f'}} (thrift.uri="facebook.com/thrift/test/testset/{name}")')
    return "\n".join(lines)


def print_thrift_defs(
    transform: Dict[Target, str],
    fields: Dict[str, str],
    count: int = 1,
    *,
    file: TextIO = sys.stdout,
) -> List[str]:
    """Prints one thrift class def per field in fields and returns the names of all the classes."""
    empty_name = transform[Target.NAME].format("empty")
    print(gen_thrift_def(transform, empty_name, []), file=file)
    classes = [empty_name]
    for name, value_t in fields.items():
        class_name = transform[Target.NAME].format(name)
        classes.append(class_name)
        print(gen_thrift_def(transform, class_name, [value_t] * count), file=file)
    return classes


def gen_thrift(path: str) -> None:
    with open(path, "w") as file:
        print(THRIFT_HEADER, file=file)
        classes = []

        # Generate all structs
        struct_fields = gen_struct_fields(Target.THRIFT)
        classes.extend(print_thrift_defs(STRUCT_TRANSFORM, struct_fields, file=file))

        # Generate all exceptions, with the struct fields.
        print_thrift_defs(EXCEPTION_TRANSFORM, struct_fields, file=file)

        # Generate all unions.
        union_fields = gen_union_fields(Target.THRIFT)
        classes.extend(
            print_thrift_defs(UNION_TRANSFORM, union_fields, count=2, file=file)
        )

        # Generate a union of all defined structs and unions.
        all_name = UNION_TRANSFORM[Target.NAME].format("all")
        print(gen_thrift_def(UNION_TRANSFORM, all_name, classes), file=file)


def generate(dir: str) -> None:
    gen_thrift(os.path.join(dir, "testset.thrift"))


def main() -> None:
    doctest.testmod()
    parser = argparse.ArgumentParser()
    parser.add_argument("--install_dir", required=True)
    args = parser.parse_args()
    generate(args.install_dir)


if __name__ == "__main__":
    main()
