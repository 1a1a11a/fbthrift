# Copyright (c) Facebook, Inc. and its affiliates.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import doctest
import os
from enum import Enum
from typing import Dict, Iterable, List, TextIO


class Target(Enum):
    NAME = 0
    THRIFT = 1


THRIFT_HEADER = f"""# This file was generated by `thrift/test/testset/generator.py`
# {'@'}generated

namespace cpp2 apache.thrift.test.testset
"""

FIELD_COUNT = 2  # Number of fields per structs

PRIMITIVE_TYPES = (
    "bool",
    "byte",
    "i16",
    "i32",
    "i64",
    "float",
    "double",
    "binary",
    "string",
)

PRIMATIVE_TRANSFORM: Dict[Target, str] = {
    Target.NAME: "{}",
    Target.THRIFT: "{}",
}

LIST_TRANSFORM: Dict[Target, str] = {
    Target.NAME: "list_{}",
    Target.THRIFT: "list<{}>",
}

SET_TRANSFORM: Dict[Target, str] = {
    Target.NAME: "set_{}",
    Target.THRIFT: "set<{}>",
}

MAP_TRANSFORM: Dict[Target, str] = {
    Target.NAME: "map_{}_{}",
    Target.THRIFT: "map<{}, {}>",
}

OPTIONAL_TRANSFORM: Dict[Target, str] = {
    Target.NAME: "optional_{}",
    Target.THRIFT: "optional {}",
}

REQUIRED_TRANSFORM: Dict[Target, str] = {
    Target.NAME: "required_{}",
    Target.THRIFT: "required {}",
}

CPP_REF_TRANSFORM: Dict[Target, str] = {
    Target.NAME: "{}_cpp_ref",
    Target.THRIFT: "{} (cpp.ref = 'true')",
}


def gen_primatives(
    target: Target, prims: Iterable[str] = PRIMITIVE_TYPES
) -> Dict[str, str]:
    result = {}
    for prim in prims:
        value = PRIMATIVE_TRANSFORM[target].format(prim)
        result[PRIMATIVE_TRANSFORM[Target.NAME].format(prim)] = value
    return result


def _gen_unary_tramsform(
    transform: Dict[Target, str], target: Target, values: Dict[str, str]
) -> Dict[str, str]:
    result = {}
    for name, value_t in values.items():
        result[transform[Target.NAME].format(name)] = transform[target].format(value_t)
    return result


def gen_lists(target: Target, values: Dict[str, str]) -> Dict[str, str]:
    return _gen_unary_tramsform(LIST_TRANSFORM, target, values)


def gen_sets(target: Target, values: Dict[str, str]) -> Dict[str, str]:
    return _gen_unary_tramsform(SET_TRANSFORM, target, values)


def gen_maps(
    target: Target, keys: Dict[str, str], values: Dict[str, str]
) -> Dict[str, str]:
    result = {}
    for key_name, key_t in keys.items():
        for value_name, value_t in values.items():
            name = MAP_TRANSFORM[Target.NAME].format(key_name, value_name)
            value = MAP_TRANSFORM[target].format(key_t, value_t)
            result[name] = value
    return result


def gen_optional(target: Target, values: Dict[str, str]) -> Dict[str, str]:
    return _gen_unary_tramsform(OPTIONAL_TRANSFORM, target, values)


def gen_required(target: Target, values: Dict[str, str]) -> Dict[str, str]:
    return _gen_unary_tramsform(REQUIRED_TRANSFORM, target, values)


def gen_cpp_ref(target: Target, values: Dict[str, str]) -> Dict[str, str]:
    return _gen_unary_tramsform(CPP_REF_TRANSFORM, target, values)


def generate_union_names_to_types(target: Target) -> Dict[str, str]:
    """ Generate display name to thrift type mapping in union. Display name will be used in file name, rule name, etc """
    ret = gen_primatives(target, PRIMITIVE_TYPES)
    ret.update(gen_sets(target, ret))
    ret.update(gen_maps(target, gen_primatives(target, ["string"]), ret))
    ret.update(gen_cpp_ref(target, ret))
    return ret


def generate_struct_names_to_types(target: Target) -> Dict[str, str]:
    """ Similar to thrift types in union. Difference is that unions cannot contain qualified fields. """
    ret = generate_union_names_to_types(target)
    ret.update(**gen_optional(target, ret), **gen_required(target, ret))
    return ret


def generate_class(class_type: str, name: str, types: List[str]) -> str:
    """Generate thrift struct from types
    >>> print(generate_class("struct", "Foo", ["i64", "optional string", "set<i32> (cpp.ref = 'true')"]))
    struct Foo {
      1: i64 field_1;
      2: optional string field_2;
      3: set<i32> (cpp.ref = 'true') field_3;
    } (thrift.uri="facebook.com/thrift/test/testset/Foo")
    """
    lines = [f"{class_type} {name} {{"]
    for i, t in enumerate(types):
        lines.append("  {0}: {1} field_{0};".format(i + 1, t))
    lines.append(f'}} (thrift.uri="facebook.com/thrift/test/testset/{name}")')
    return "\n".join(lines)


def print_thrift_class(
    class_type: str,
    names_to_types: Dict[str, str],
    *,
    file: TextIO,
) -> None:
    name = "empty_" + class_type
    print(generate_class(class_type, name, []), file=file)
    classes = [name]
    for display_name, type in names_to_types.items():
        class_name = class_type + "_" + display_name
        classes.append(class_name)
        print(generate_class(class_type, class_name, [type] * FIELD_COUNT), file=file)

    # Thrift class that contains all other generated classes with same-type
    print(generate_class(class_type, class_type + "_all", classes), file=file)


def gen_thrift(path: str) -> None:
    with open(path, "w") as file:
        print(THRIFT_HEADER, file=file)
        print_thrift_class(
            "struct", generate_struct_names_to_types(Target.THRIFT), file=file
        )
        print_thrift_class(
            "union", generate_union_names_to_types(Target.THRIFT), file=file
        )


def generate(dir: str) -> None:
    gen_thrift(os.path.join(dir, "testset.thrift"))


def main() -> None:
    doctest.testmod()
    parser = argparse.ArgumentParser()
    parser.add_argument("--install_dir", required=True)
    args = parser.parse_args()
    generate(args.install_dir)


if __name__ == "__main__":
    main()
