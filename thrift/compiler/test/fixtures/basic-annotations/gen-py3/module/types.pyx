#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
cimport cython as __cython
from cpython.bytes cimport PyBytes_AsStringAndSize
from cpython.object cimport PyTypeObject, Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT, Py_GE
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import (
    NOTSET as __NOTSET,
    NumberType as __NumberType,
    StructSpec as __StructSpec,
    ListSpec as __ListSpec,
    SetSpec as __SetSpec,
    MapSpec as __MapSpec,
    FieldSpec as __FieldSpec,
    StructType as __StructType,
    Qualifier as __Qualifier,
)
from thrift.py3.types cimport (
    translate_cpp_enum_to_python,
    SetMetaClass as __SetMetaClass,
    constant_shared_ptr,
    default_inst,
)
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer import Protocol as __Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize
import folly.iobuf as __iobuf
from folly.optional cimport cOptional

import sys
import types as _py_types
import itertools
from collections.abc import Sequence, Set, Mapping, Iterable
import warnings
import weakref as __weakref
import builtins as _builtins

cdef object __MyEnumEnumInstances = None  # Set[MyEnum]
cdef object __MyEnumEnumMembers = {}      # Dict[str, MyEnum]
cdef object __MyEnumEnumUniqueValues = dict()    # Dict[int, MyEnum]

@__cython.internal
@__cython.auto_pickle(False)
cdef class __MyEnumMeta(type):
    def __call__(cls, value):
        cdef int cvalue
        if isinstance(value, cls):
            return value
        if isinstance(value, int):
            cvalue = value
            if cvalue == 0:
                return MyEnum.MyValue1
            elif cvalue == 1:
                return MyEnum.MyValue2
            elif cvalue == 2:
                return MyEnum.DOMAIN

        raise ValueError(f'{value} is not a valid MyEnum')

    def __getitem__(cls, name):
        return __MyEnumEnumMembers[name]

    def __dir__(cls):
        return ['__class__', '__doc__', '__members__', '__module__',
        'MyValue1',
        'MyValue2',
        'DOMAIN',
        ]

    def __iter__(cls):
        return iter(__MyEnumEnumUniqueValues.values())

    def __reversed__(cls):
        return reversed(iter(cls))

    def __contains__(cls, item):
        if not isinstance(item, cls):
            return False
        return item in __MyEnumEnumInstances

    def __len__(cls):
        return len(__MyEnumEnumInstances)


cdef __MyEnum_unique_instance(int value, str name):
    inst = __MyEnumEnumUniqueValues.get(value)
    if inst is None:
        inst = __MyEnumEnumUniqueValues[value] = MyEnum.__new__(MyEnum, value, name)
    __MyEnumEnumMembers[name] = inst
    return inst


@__cython.final
@__cython.auto_pickle(False)
cdef class MyEnum(thrift.py3.types.CompiledEnum):
    MyValue1 = __MyEnum_unique_instance(0, "MyValue1")
    MyValue2 = __MyEnum_unique_instance(1, "MyValue2")
    DOMAIN = __MyEnum_unique_instance(2, "DOMAIN")
    __members__ = thrift.py3.types.MappingProxyType(__MyEnumEnumMembers)

    def __cinit__(self, value, name):
        if __MyEnumEnumInstances is not None:
            raise TypeError('__new__ is disabled in the interest of type-safety')
        self.value = value
        self.name = name
        self.__hash = hash(name)
        self.__str = f"MyEnum.{name}"
        self.__repr = f"<{self.__str}: {value}>"

    def __repr__(self):
        return self.__repr

    def __str__(self):
        return self.__str

    def __int__(self):
        return self.value

    def __eq__(self, other):
        if not isinstance(other, MyEnum):
            warnings.warn(f"comparison not supported between instances of { MyEnum } and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self is other

    def __hash__(self):
        return self.__hash

    def __reduce__(self):
        return MyEnum, (self.value,)


__SetMetaClass(<PyTypeObject*> MyEnum, <PyTypeObject*> __MyEnumMeta)
__MyEnumEnumInstances = set(__MyEnumEnumUniqueValues.values())


cdef inline cMyEnum MyEnum_to_cpp(MyEnum value):
    cdef int cvalue = value.value
    if cvalue == 0:
        return MyEnum__MyValue1
    elif cvalue == 1:
        return MyEnum__MyValue2
    elif cvalue == 2:
        return MyEnum__DOMAIN

@__cython.auto_pickle(False)
cdef class MyStruct(thrift.py3.types.Struct):

    def __init__(
        MyStruct self, *,
        major=None,
        str package=None,
        str annotation_with_quote=None,
        str class_=None
    ):
        if major is not None:
            if not isinstance(major, int):
                raise TypeError(f'major is not a { int !r}.')
            major = <int64_t> major

        self._cpp_obj = move(MyStruct._make_instance(
          NULL,
          NULL,
          major,
          package,
          annotation_with_quote,
          class_,
        ))

    def __call__(
        MyStruct self,
        major=__NOTSET,
        package=__NOTSET,
        annotation_with_quote=__NOTSET,
        class_=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[4] __isNOTSET  # so make_instance is typed

        changes = False
        if major is ___NOTSET:
            __isNOTSET[0] = True
            major = None
        else:
            __isNOTSET[0] = False
            changes = True

        if package is ___NOTSET:
            __isNOTSET[1] = True
            package = None
        else:
            __isNOTSET[1] = False
            changes = True

        if annotation_with_quote is ___NOTSET:
            __isNOTSET[2] = True
            annotation_with_quote = None
        else:
            __isNOTSET[2] = False
            changes = True

        if class_ is ___NOTSET:
            __isNOTSET[3] = True
            class_ = None
        else:
            __isNOTSET[3] = False
            changes = True


        if not changes:
            return self

        if major is not None:
            if not isinstance(major, int):
                raise TypeError(f'major is not a { int !r}.')
            major = <int64_t> major

        if package is not None:
            if not isinstance(package, str):
                raise TypeError(f'package is not a { str !r}.')

        if annotation_with_quote is not None:
            if not isinstance(annotation_with_quote, str):
                raise TypeError(f'annotation_with_quote is not a { str !r}.')

        if class_ is not None:
            if not isinstance(class_, str):
                raise TypeError(f'class_ is not a { str !r}.')

        inst = <MyStruct>MyStruct.__new__(MyStruct)
        inst._cpp_obj = move(MyStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          major,
          package,
          annotation_with_quote,
          class_,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cMyStruct] _make_instance(
        cMyStruct* base_instance,
        bint* __isNOTSET,
        object major ,
        str package ,
        str annotation_with_quote ,
        str class_ 
    ) except *:
        cdef unique_ptr[cMyStruct] c_inst
        if base_instance:
            c_inst = make_unique[cMyStruct](deref(base_instance))
        else:
            c_inst = make_unique[cMyStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and major is None:
                deref(c_inst).major = default_inst[cMyStruct]().major
                deref(c_inst).__isset.major = False
                pass

            if not __isNOTSET[1] and package is None:
                deref(c_inst).package = default_inst[cMyStruct]().package
                deref(c_inst).__isset.package = False
                pass

            if not __isNOTSET[2] and annotation_with_quote is None:
                deref(c_inst).annotation_with_quote = default_inst[cMyStruct]().annotation_with_quote
                deref(c_inst).__isset.annotation_with_quote = False
                pass

            if not __isNOTSET[3] and class_ is None:
                deref(c_inst).class_ = default_inst[cMyStruct]().class_
                deref(c_inst).__isset.class_ = False
                pass

        if major is not None:
            deref(c_inst).major = major
            deref(c_inst).__isset.major = True
        if package is not None:
            deref(c_inst).package = thrift.py3.types.move(thrift.py3.types.bytes_to_string(package.encode('utf-8')))
            deref(c_inst).__isset.package = True
        if annotation_with_quote is not None:
            deref(c_inst).annotation_with_quote = thrift.py3.types.move(thrift.py3.types.bytes_to_string(annotation_with_quote.encode('utf-8')))
            deref(c_inst).__isset.annotation_with_quote = True
        if class_ is not None:
            deref(c_inst).class_ = thrift.py3.types.move(thrift.py3.types.bytes_to_string(class_.encode('utf-8')))
            deref(c_inst).__isset.class_ = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'major', self.major
        yield 'package', self.package
        yield 'annotation_with_quote', self.annotation_with_quote
        yield 'class_', self.class_

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cMyStruct] cpp_obj):
        inst = <MyStruct>MyStruct.__new__(MyStruct)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def major(self):

        return deref(self._cpp_obj).major

    @property
    def package(self):

        return (<bytes>deref(self._cpp_obj).package).decode('UTF-8')

    @property
    def annotation_with_quote(self):

        return (<bytes>deref(self._cpp_obj).annotation_with_quote).decode('UTF-8')

    @property
    def class_(self):

        return (<bytes>deref(self._cpp_obj).class_).decode('UTF-8')


    def __hash__(MyStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.major,
            self.package,
            self.annotation_with_quote,
            self.class_,
            ))
        return self.__hash

    def __repr__(MyStruct self):
        return f'MyStruct(major={repr(self.major)}, package={repr(self.package)}, annotation_with_quote={repr(self.annotation_with_quote)}, class_={repr(self.class_)})'
    def __copy__(MyStruct self):
        cdef shared_ptr[cMyStruct] cpp_obj = make_shared[cMyStruct](
            deref(self._cpp_obj)
        )
        return MyStruct.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, MyStruct) and
                isinstance(other, MyStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cMyStruct* cself = (<MyStruct>self)._cpp_obj.get()
        cdef cMyStruct* cother = (<MyStruct>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
      defaults = MyStruct.create(constant_shared_ptr[cMyStruct](default_inst[cMyStruct]()))
      return __StructSpec(
        name="MyStruct",
        kind=__StructType.STRUCT,
        fields=[
          __FieldSpec(
  name="major",
  type=int,
  kind=__NumberType.I64,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
    """cpp.name""": """majorVer""",  }),
),
                __FieldSpec(
  name="package",
  type=str,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
    """java.swift.name""": """_package""",  }),
),
                __FieldSpec(
  name="annotation_with_quote",
  type=str,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
    """go.tag""": """tag:\"somevalue\"""",  }),
),
                __FieldSpec(
  name="class_",
  type=str,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
    """java.swift.name""": """class_""",  }),
),
          ],
        annotations=_py_types.MappingProxyType({
          """android.generate_builder""": """1""",    }),
      )
    cdef __iobuf.IOBuf _serialize(MyStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cMyStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cMyStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cMyStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cMyStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cMyStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(MyStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cMyStruct]()
        cdef cMyStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cMyStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cMyStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cMyStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cMyStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (MyStruct, serialize(self)))


@__cython.auto_pickle(False)
cdef class SecretStruct(thrift.py3.types.Struct):

    def __init__(
        SecretStruct self, *,
        id=None,
        str password=None
    ):
        if id is not None:
            if not isinstance(id, int):
                raise TypeError(f'id is not a { int !r}.')
            id = <int64_t> id

        self._cpp_obj = move(SecretStruct._make_instance(
          NULL,
          NULL,
          id,
          password,
        ))

    def __call__(
        SecretStruct self,
        id=__NOTSET,
        password=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[2] __isNOTSET  # so make_instance is typed

        changes = False
        if id is ___NOTSET:
            __isNOTSET[0] = True
            id = None
        else:
            __isNOTSET[0] = False
            changes = True

        if password is ___NOTSET:
            __isNOTSET[1] = True
            password = None
        else:
            __isNOTSET[1] = False
            changes = True


        if not changes:
            return self

        if id is not None:
            if not isinstance(id, int):
                raise TypeError(f'id is not a { int !r}.')
            id = <int64_t> id

        if password is not None:
            if not isinstance(password, str):
                raise TypeError(f'password is not a { str !r}.')

        inst = <SecretStruct>SecretStruct.__new__(SecretStruct)
        inst._cpp_obj = move(SecretStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          id,
          password,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cSecretStruct] _make_instance(
        cSecretStruct* base_instance,
        bint* __isNOTSET,
        object id ,
        str password 
    ) except *:
        cdef unique_ptr[cSecretStruct] c_inst
        if base_instance:
            c_inst = make_unique[cSecretStruct](deref(base_instance))
        else:
            c_inst = make_unique[cSecretStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and id is None:
                deref(c_inst).id = default_inst[cSecretStruct]().id
                deref(c_inst).__isset.id = False
                pass

            if not __isNOTSET[1] and password is None:
                deref(c_inst).password = default_inst[cSecretStruct]().password
                deref(c_inst).__isset.password = False
                pass

        if id is not None:
            deref(c_inst).id = id
            deref(c_inst).__isset.id = True
        if password is not None:
            deref(c_inst).password = thrift.py3.types.move(thrift.py3.types.bytes_to_string(password.encode('utf-8')))
            deref(c_inst).__isset.password = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'id', self.id
        yield 'password', self.password

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cSecretStruct] cpp_obj):
        inst = <SecretStruct>SecretStruct.__new__(SecretStruct)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def id(self):

        return deref(self._cpp_obj).id

    @property
    def password(self):

        return (<bytes>deref(self._cpp_obj).password).decode('UTF-8')


    def __hash__(SecretStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.id,
            self.password,
            ))
        return self.__hash

    def __repr__(SecretStruct self):
        return f'SecretStruct(id={repr(self.id)}, password={repr(self.password)})'
    def __copy__(SecretStruct self):
        cdef shared_ptr[cSecretStruct] cpp_obj = make_shared[cSecretStruct](
            deref(self._cpp_obj)
        )
        return SecretStruct.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, SecretStruct) and
                isinstance(other, SecretStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cSecretStruct* cself = (<SecretStruct>self)._cpp_obj.get()
        cdef cSecretStruct* cother = (<SecretStruct>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return deref(cself) != deref(cother)
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    @staticmethod
    def __get_reflection__():
      defaults = SecretStruct.create(constant_shared_ptr[cSecretStruct](default_inst[cSecretStruct]()))
      return __StructSpec(
        name="SecretStruct",
        kind=__StructType.STRUCT,
        fields=[
          __FieldSpec(
  name="id",
  type=int,
  kind=__NumberType.I64,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
  }),
),
                __FieldSpec(
  name="password",
  type=str,
  kind=None,
  qualifier=__Qualifier.NONE,
  default=None,
  annotations=_py_types.MappingProxyType({
    """java.sensitive""": """1""",  }),
),
          ],
        annotations=_py_types.MappingProxyType({
        }),
      )
    cdef __iobuf.IOBuf _serialize(SecretStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cSecretStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cSecretStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cSecretStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cSecretStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cSecretStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(SecretStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cSecretStruct]()
        cdef cSecretStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cSecretStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cSecretStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cSecretStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cSecretStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (SecretStruct, serialize(self)))


