{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
--  @generated
-----------------------------------------------------------------

module Module0_Types where
import Prelude ( Bool(..), Enum, Float, IO, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 concat, error, fromIntegral, fromEnum, length, map,
                 maybe, not, null, otherwise, return, show, toEnum,
                 enumFromTo, Bounded, minBound, maxBound, seq,
                 (.), (&&), (||), (==), (++), ($), (-), (>>=), (>>))

import Control.Applicative (ZipList(..), (<*>))
import Control.DeepSeq
import Control.Exception
import Control.Monad ( liftM, ap, when )
import Data.ByteString.Lazy (ByteString)
import Data.Functor ( (<$>) )
import Data.Hashable
import Data.Int
import Data.Maybe (catMaybes)
import Data.Text.Lazy.Encoding ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import Data.Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import Test.QuickCheck.Arbitrary ( Arbitrary(..) )
import Test.QuickCheck ( elements )

import Thrift hiding (ProtocolExnType(..))
import qualified Thrift (ProtocolExnType(..))
import Thrift.Types
import Thrift.Arbitraries


data Enum = ONE|TWO|THREE  deriving (Show,Eq, Typeable, Ord, Bounded)
instance Enum Enum where
  fromEnum t = case t of
    ONE -> 1
    TWO -> 2
    THREE -> 3
  toEnum t = case t of
    1 -> ONE
    2 -> TWO
    3 -> THREE
    _ -> throw ThriftException
instance Hashable Enum where
  hashWithSalt salt = hashWithSalt salt . fromEnum
instance NFData Enum where
  rnf x = x `seq` ()
instance Arbitrary Enum where
  arbitrary = elements (enumFromTo minBound maxBound)
data Struct = Struct
  { struct_first :: Int32
  , struct_second :: LT.Text
  } deriving (Show,Eq,Typeable)
instance Hashable Struct where
  hashWithSalt salt record = salt   `hashWithSalt` struct_first record   `hashWithSalt` struct_second record  
instance NFData Struct where
  rnf _record0 =
    rnf (struct_first _record0) `seq`
    rnf (struct_second _record0) `seq`
    ()
instance Arbitrary Struct where 
  arbitrary = liftM Struct (arbitrary)
          `ap`(arbitrary)
  shrink obj | obj == default_Struct = []
             | otherwise = catMaybes
    [ if obj == default_Struct{struct_first = struct_first obj} then Nothing else Just $ default_Struct{struct_first = struct_first obj}
    , if obj == default_Struct{struct_second = struct_second obj} then Nothing else Just $ default_Struct{struct_second = struct_second obj}
    ]
from_Struct :: Struct -> ThriftVal
from_Struct record = TStruct $ Map.fromList $ catMaybes
  [ (\_v3 -> Just (1, ("first",TI32 _v3))) $ struct_first record
  , (\_v3 -> Just (2, ("second",TString $ encodeUtf8 _v3))) $ struct_second record
  ]
write_Struct :: (Protocol p, Transport t) => p t -> Struct -> IO ()
write_Struct oprot record = writeVal oprot $ from_Struct record
encode_Struct :: (Protocol p, Transport t) => p t -> Struct -> ByteString
encode_Struct oprot record = serializeVal oprot $ from_Struct record
to_Struct :: ThriftVal -> Struct
to_Struct (TStruct fields) = Struct{
  struct_first = maybe (struct_first default_Struct) (\(_,_val5) -> (case _val5 of {TI32 _val6 -> _val6; _ -> error "wrong type"})) (Map.lookup (1) fields),
  struct_second = maybe (struct_second default_Struct) (\(_,_val5) -> (case _val5 of {TString _val7 -> decodeUtf8 _val7; _ -> error "wrong type"})) (Map.lookup (2) fields)
  }
to_Struct _ = error "not a struct"
read_Struct :: (Transport t, Protocol p) => p t -> IO Struct
read_Struct iprot = to_Struct <$> readVal iprot (T_STRUCT typemap_Struct)
decode_Struct :: (Protocol p, Transport t) => p t -> ByteString -> Struct
decode_Struct iprot bs = to_Struct $ deserializeVal iprot (T_STRUCT typemap_Struct) bs
typemap_Struct :: TypeMap
typemap_Struct = Map.fromList [("first",(1,T_I32)),("second",(2,T_STRING))]
default_Struct :: Struct
default_Struct = Struct{
  struct_first = 0,
  struct_second = ""}
