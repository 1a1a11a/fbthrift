#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
cimport cython as __cython
from cpython.bytes cimport PyBytes_AsStringAndSize
from cpython.object cimport PyTypeObject, Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT, Py_GE
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET as __NOTSET
from thrift.py3.types cimport (
    translate_cpp_enum_to_python,
    SetMetaClass as __SetMetaClass,
    constant_shared_ptr,
)
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer import Protocol as __Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize
import folly.iobuf as __iobuf
from folly.optional cimport cOptional

import sys
import itertools
from collections import Sequence, Set, Mapping, Iterable
import warnings
import builtins as _builtins

cdef object __MyEnumAEnumInstances = None  # Set[MyEnumA]
cdef object __MyEnumAEnumMembers = {}      # Dict[str, MyEnumA]
cdef object __MyEnumAEnumUniqueValues = dict()    # Dict[int, MyEnumA]

@__cython.internal
@__cython.auto_pickle(False)
cdef class __MyEnumAMeta(type):
    def __call__(cls, value):
        cdef int cvalue
        if isinstance(value, cls) and value in __MyEnumAEnumInstances:
            return value
        if isinstance(value, int):
            cvalue = value
            if cvalue == 1:
                return MyEnumA.fieldA
            elif cvalue == 2:
                return MyEnumA.fieldB
            elif cvalue == 4:
                return MyEnumA.fieldC

        raise ValueError(f'{value} is not a valid MyEnumA')

    def __getitem__(cls, name):
        return __MyEnumAEnumMembers[name]

    def __dir__(cls):
        return ['__class__', '__doc__', '__members__', '__module__',
        'fieldA',
        'fieldB',
        'fieldC',
        ]

    def __iter__(cls):
        return iter(__MyEnumAEnumUniqueValues.values())

    def __reversed__(cls):
        return reversed(iter(cls))

    def __contains__(cls, item):
        if not isinstance(item, cls):
            return False
        return item in __MyEnumAEnumInstances

    def __len__(cls):
        return len(__MyEnumAEnumInstances)


cdef __MyEnumA_unique_instance(int value, str name):
    inst = __MyEnumAEnumUniqueValues.get(value)
    if inst is None:
        inst = __MyEnumAEnumUniqueValues[value] = MyEnumA.__new__(MyEnumA, value, name)
    __MyEnumAEnumMembers[name] = inst
    return inst


@__cython.final
cdef class MyEnumA(thrift.py3.types.CompiledEnum):
    fieldA = __MyEnumA_unique_instance(1, "fieldA")
    fieldB = __MyEnumA_unique_instance(2, "fieldB")
    fieldC = __MyEnumA_unique_instance(4, "fieldC")
    __members__ = thrift.py3.types.MappingProxyType(__MyEnumAEnumMembers)

    def __cinit__(self, value, name):
        if __MyEnumAEnumInstances is not None:
            raise TypeError('For Safty we have disabled __new__')
        self.value = value
        self.name = name
        self.__hash = hash(name)
        self.__str = f"MyEnumA.{name}"
        self.__repr = f"<{self.__str}: {value}>"

    def __repr__(self):
        return self.__repr

    def __str__(self):
        return self.__str

    def __int__(self):
        return self.value

    def __eq__(self, other):
        if not isinstance(other, MyEnumA):
            warnings.warn(f"comparison not supported between instances of { MyEnumA } and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self is other

    def __hash__(self):
        return self.__hash

    def __reduce__(self):
        return MyEnumA, (self.value,)


__SetMetaClass(<PyTypeObject*> MyEnumA, <PyTypeObject*> __MyEnumAMeta)
__MyEnumAEnumInstances = set(__MyEnumAEnumUniqueValues.values())


cdef inline cMyEnumA MyEnumA_to_cpp(MyEnumA value):
    cdef int cvalue = value.value
    if cvalue == 1:
        return MyEnumA__fieldA
    elif cvalue == 2:
        return MyEnumA__fieldB
    elif cvalue == 4:
        return MyEnumA__fieldC

cdef cSmallStruct _SmallStruct_defaults = cSmallStruct()

cdef class SmallStruct(thrift.py3.types.Struct):

    def __init__(
        SmallStruct self, *,
        pbool small_A=None,
        small_B=None
    ):
        if small_B is not None:
            if not isinstance(small_B, int):
                raise TypeError(f'small_B is not a { int !r}.')
            small_B = <int32_t> small_B

        self._cpp_obj = move(SmallStruct._make_instance(
          NULL,
          NULL,
          small_A,
          small_B,
        ))

    def __call__(
        SmallStruct self,
        small_A=__NOTSET,
        small_B=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[2] __isNOTSET  # so make_instance is typed

        changes = False
        if small_A is ___NOTSET:
            __isNOTSET[0] = True
            small_A = None
        else:
            __isNOTSET[0] = False
            changes = True

        if small_B is ___NOTSET:
            __isNOTSET[1] = True
            small_B = None
        else:
            __isNOTSET[1] = False
            changes = True


        if not changes:
            return self

        if small_A is not None:
            if not isinstance(small_A, bool):
                raise TypeError(f'small_A is not a { bool !r}.')

        if small_B is not None:
            if not isinstance(small_B, int):
                raise TypeError(f'small_B is not a { int !r}.')
            small_B = <int32_t> small_B

        inst = <SmallStruct>SmallStruct.__new__(SmallStruct)
        inst._cpp_obj = move(SmallStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          small_A,
          small_B,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cSmallStruct] _make_instance(
        cSmallStruct* base_instance,
        bint* __isNOTSET,
        pbool small_A ,
        object small_B 
    ) except *:
        cdef unique_ptr[cSmallStruct] c_inst
        if base_instance:
            c_inst = make_unique[cSmallStruct](deref(base_instance))
        else:
            c_inst = make_unique[cSmallStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and small_A is None:
                deref(c_inst).small_A = _SmallStruct_defaults.small_A
                deref(c_inst).__isset.small_A = False
                pass

            if not __isNOTSET[1] and small_B is None:
                deref(c_inst).small_B = _SmallStruct_defaults.small_B
                deref(c_inst).__isset.small_B = False
                pass

        if small_A is not None:
            deref(c_inst).small_A = small_A
            deref(c_inst).__isset.small_A = True
        if small_B is not None:
            deref(c_inst).small_B = small_B
            deref(c_inst).__isset.small_B = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'small_A', self.small_A
        yield 'small_B', self.small_B

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cSmallStruct] cpp_obj):
        inst = <SmallStruct>SmallStruct.__new__(SmallStruct)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def small_A(self):

        return <pbool> deref(self._cpp_obj).small_A

    @property
    def small_B(self):

        return deref(self._cpp_obj).small_B


    def __hash__(SmallStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.small_A,
            self.small_B,
            ))
        return self.__hash

    def __repr__(SmallStruct self):
        return f'SmallStruct(small_A={repr(self.small_A)}, small_B={repr(self.small_B)})'
    def __copy__(SmallStruct self):
        cdef shared_ptr[cSmallStruct] cpp_obj = make_shared[cSmallStruct](
            deref(self._cpp_obj)
        )
        return SmallStruct.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, SmallStruct) and
                isinstance(other, SmallStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cSmallStruct cself = deref((<SmallStruct>self)._cpp_obj)
        cdef cSmallStruct cother = deref((<SmallStruct>other)._cpp_obj)
        if cop == Py_EQ:
            return cself == cother
        elif cop == Py_NE:
            return not (cself == cother)
        elif cop == Py_LT:
            return cself < cother
        elif cop == Py_LE:
            return cself <= cother
        elif cop == Py_GT:
            return cself > cother
        elif cop == Py_GE:
            return cself >= cother
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(SmallStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cSmallStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cSmallStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cSmallStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cSmallStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cSmallStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(SmallStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cSmallStruct]()
        cdef cSmallStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cSmallStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cSmallStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cSmallStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cSmallStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (SmallStruct, serialize(self)))


cdef ccontainerStruct _containerStruct_defaults = ccontainerStruct()

cdef class containerStruct(thrift.py3.types.Struct):

    def __init__(
        containerStruct self, *,
        pbool fieldA=None,
        fieldB=None,
        fieldC=None,
        str fieldD=None,
        str fieldE=None,
        fieldF=None,
        fieldG=None,
        fieldH=None,
        pbool fieldI=None,
        fieldJ=None,
        fieldK=None,
        fieldL=None,
        fieldM=None,
        fieldN=None,
        fieldO=None,
        fieldP=None,
        MyEnumA fieldQ=None,
        fieldR=None,
        SmallStruct fieldS=None,
        SmallStruct fieldT=None,
        SmallStruct fieldU=None,
        SmallStruct fieldX=None
    ):
        self._cpp_obj = move(containerStruct._make_instance(
          NULL,
          NULL,
          fieldA,
          fieldB,
          fieldC,
          fieldD,
          fieldE,
          fieldF,
          fieldG,
          fieldH,
          fieldI,
          fieldJ,
          fieldK,
          fieldL,
          fieldM,
          fieldN,
          fieldO,
          fieldP,
          fieldQ,
          fieldR,
          fieldS,
          fieldT,
          fieldU,
          fieldX,
        ))

    def __call__(
        containerStruct self,
        fieldA=__NOTSET,
        fieldB=__NOTSET,
        fieldC=__NOTSET,
        fieldD=__NOTSET,
        fieldE=__NOTSET,
        fieldF=__NOTSET,
        fieldG=__NOTSET,
        fieldH=__NOTSET,
        fieldI=__NOTSET,
        fieldJ=__NOTSET,
        fieldK=__NOTSET,
        fieldL=__NOTSET,
        fieldM=__NOTSET,
        fieldN=__NOTSET,
        fieldO=__NOTSET,
        fieldP=__NOTSET,
        fieldQ=__NOTSET,
        fieldR=__NOTSET,
        fieldS=__NOTSET,
        fieldT=__NOTSET,
        fieldU=__NOTSET,
        fieldX=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[22] __isNOTSET  # so make_instance is typed

        changes = False
        if fieldA is ___NOTSET:
            __isNOTSET[0] = True
            fieldA = None
        else:
            __isNOTSET[0] = False
            changes = True

        if fieldB is ___NOTSET:
            __isNOTSET[1] = True
            fieldB = None
        else:
            __isNOTSET[1] = False
            changes = True

        if fieldC is ___NOTSET:
            __isNOTSET[2] = True
            fieldC = None
        else:
            __isNOTSET[2] = False
            changes = True

        if fieldD is ___NOTSET:
            __isNOTSET[3] = True
            fieldD = None
        else:
            __isNOTSET[3] = False
            changes = True

        if fieldE is ___NOTSET:
            __isNOTSET[4] = True
            fieldE = None
        else:
            __isNOTSET[4] = False
            changes = True

        if fieldF is ___NOTSET:
            __isNOTSET[5] = True
            fieldF = None
        else:
            __isNOTSET[5] = False
            changes = True

        if fieldG is ___NOTSET:
            __isNOTSET[6] = True
            fieldG = None
        else:
            __isNOTSET[6] = False
            changes = True

        if fieldH is ___NOTSET:
            __isNOTSET[7] = True
            fieldH = None
        else:
            __isNOTSET[7] = False
            changes = True

        if fieldI is ___NOTSET:
            __isNOTSET[8] = True
            fieldI = None
        else:
            __isNOTSET[8] = False
            changes = True

        if fieldJ is ___NOTSET:
            __isNOTSET[9] = True
            fieldJ = None
        else:
            __isNOTSET[9] = False
            changes = True

        if fieldK is ___NOTSET:
            __isNOTSET[10] = True
            fieldK = None
        else:
            __isNOTSET[10] = False
            changes = True

        if fieldL is ___NOTSET:
            __isNOTSET[11] = True
            fieldL = None
        else:
            __isNOTSET[11] = False
            changes = True

        if fieldM is ___NOTSET:
            __isNOTSET[12] = True
            fieldM = None
        else:
            __isNOTSET[12] = False
            changes = True

        if fieldN is ___NOTSET:
            __isNOTSET[13] = True
            fieldN = None
        else:
            __isNOTSET[13] = False
            changes = True

        if fieldO is ___NOTSET:
            __isNOTSET[14] = True
            fieldO = None
        else:
            __isNOTSET[14] = False
            changes = True

        if fieldP is ___NOTSET:
            __isNOTSET[15] = True
            fieldP = None
        else:
            __isNOTSET[15] = False
            changes = True

        if fieldQ is ___NOTSET:
            __isNOTSET[16] = True
            fieldQ = None
        else:
            __isNOTSET[16] = False
            changes = True

        if fieldR is ___NOTSET:
            __isNOTSET[17] = True
            fieldR = None
        else:
            __isNOTSET[17] = False
            changes = True

        if fieldS is ___NOTSET:
            __isNOTSET[18] = True
            fieldS = None
        else:
            __isNOTSET[18] = False
            changes = True

        if fieldT is ___NOTSET:
            __isNOTSET[19] = True
            fieldT = None
        else:
            __isNOTSET[19] = False
            changes = True

        if fieldU is ___NOTSET:
            __isNOTSET[20] = True
            fieldU = None
        else:
            __isNOTSET[20] = False
            changes = True

        if fieldX is ___NOTSET:
            __isNOTSET[21] = True
            fieldX = None
        else:
            __isNOTSET[21] = False
            changes = True


        if not changes:
            return self

        if fieldA is not None:
            if not isinstance(fieldA, bool):
                raise TypeError(f'fieldA is not a { bool !r}.')

        if fieldD is not None:
            if not isinstance(fieldD, str):
                raise TypeError(f'fieldD is not a { str !r}.')

        if fieldE is not None:
            if not isinstance(fieldE, str):
                raise TypeError(f'fieldE is not a { str !r}.')

        if fieldI is not None:
            if not isinstance(fieldI, bool):
                raise TypeError(f'fieldI is not a { bool !r}.')

        if fieldQ is not None:
            if not isinstance(fieldQ, MyEnumA):
                raise TypeError(f'field fieldQ value: { fieldQ !r} is not of the enum type { MyEnumA }.')

        if fieldS is not None:
            if not isinstance(fieldS, SmallStruct):
                raise TypeError(f'fieldS is not a { SmallStruct !r}.')

        if fieldT is not None:
            if not isinstance(fieldT, SmallStruct):
                raise TypeError(f'fieldT is not a { SmallStruct !r}.')

        if fieldU is not None:
            if not isinstance(fieldU, SmallStruct):
                raise TypeError(f'fieldU is not a { SmallStruct !r}.')

        if fieldX is not None:
            if not isinstance(fieldX, SmallStruct):
                raise TypeError(f'fieldX is not a { SmallStruct !r}.')

        inst = <containerStruct>containerStruct.__new__(containerStruct)
        inst._cpp_obj = move(containerStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          fieldA,
          fieldB,
          fieldC,
          fieldD,
          fieldE,
          fieldF,
          fieldG,
          fieldH,
          fieldI,
          fieldJ,
          fieldK,
          fieldL,
          fieldM,
          fieldN,
          fieldO,
          fieldP,
          fieldQ,
          fieldR,
          fieldS,
          fieldT,
          fieldU,
          fieldX,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[ccontainerStruct] _make_instance(
        ccontainerStruct* base_instance,
        bint* __isNOTSET,
        pbool fieldA ,
        object fieldB ,
        object fieldC ,
        str fieldD ,
        str fieldE ,
        object fieldF ,
        object fieldG ,
        object fieldH ,
        pbool fieldI ,
        object fieldJ ,
        object fieldK ,
        object fieldL ,
        object fieldM ,
        object fieldN ,
        object fieldO ,
        object fieldP ,
        MyEnumA fieldQ ,
        object fieldR ,
        SmallStruct fieldS ,
        SmallStruct fieldT ,
        SmallStruct fieldU ,
        SmallStruct fieldX 
    ) except *:
        cdef unique_ptr[ccontainerStruct] c_inst
        if base_instance:
            c_inst = make_unique[ccontainerStruct](deref(base_instance))
        else:
            c_inst = make_unique[ccontainerStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and fieldA is None:
                deref(c_inst).fieldA = _containerStruct_defaults.fieldA
                deref(c_inst).__isset.fieldA = False
                pass

            if not __isNOTSET[1] and fieldB is None:
                deref(c_inst).fieldB = _containerStruct_defaults.fieldB
                deref(c_inst).__isset.fieldB = False
                pass

            if not __isNOTSET[2] and fieldC is None:
                deref(c_inst).fieldC = _containerStruct_defaults.fieldC
                deref(c_inst).__isset.fieldC = False
                pass

            if not __isNOTSET[3] and fieldD is None:
                deref(c_inst).fieldD = _containerStruct_defaults.fieldD
                deref(c_inst).__isset.fieldD = False
                pass

            if not __isNOTSET[4] and fieldE is None:
                deref(c_inst).fieldE = _containerStruct_defaults.fieldE
                deref(c_inst).__isset.fieldE = False
                pass

            if not __isNOTSET[5] and fieldF is None:
                deref(c_inst).fieldF = _containerStruct_defaults.fieldF
                deref(c_inst).__isset.fieldF = False
                pass

            if not __isNOTSET[6] and fieldG is None:
                deref(c_inst).fieldG = _containerStruct_defaults.fieldG
                deref(c_inst).__isset.fieldG = False
                pass

            if not __isNOTSET[7] and fieldH is None:
                deref(c_inst).fieldH = _containerStruct_defaults.fieldH
                deref(c_inst).__isset.fieldH = False
                pass

            if not __isNOTSET[8] and fieldI is None:
                deref(c_inst).fieldI = _containerStruct_defaults.fieldI
                deref(c_inst).__isset.fieldI = False
                pass

            if not __isNOTSET[9] and fieldJ is None:
                deref(c_inst).fieldJ = _containerStruct_defaults.fieldJ
                deref(c_inst).__isset.fieldJ = False
                pass

            if not __isNOTSET[10] and fieldK is None:
                deref(c_inst).fieldK = _containerStruct_defaults.fieldK
                deref(c_inst).__isset.fieldK = False
                pass

            if not __isNOTSET[11] and fieldL is None:
                deref(c_inst).fieldL = _containerStruct_defaults.fieldL
                deref(c_inst).__isset.fieldL = False
                pass

            if not __isNOTSET[12] and fieldM is None:
                deref(c_inst).fieldM = _containerStruct_defaults.fieldM
                deref(c_inst).__isset.fieldM = False
                pass

            if not __isNOTSET[13] and fieldN is None:
                deref(c_inst).fieldN = _containerStruct_defaults.fieldN
                deref(c_inst).__isset.fieldN = False
                pass

            if not __isNOTSET[14] and fieldO is None:
                deref(c_inst).fieldO = _containerStruct_defaults.fieldO
                deref(c_inst).__isset.fieldO = False
                pass

            if not __isNOTSET[15] and fieldP is None:
                deref(c_inst).fieldP = _containerStruct_defaults.fieldP
                deref(c_inst).__isset.fieldP = False
                pass

            if not __isNOTSET[16] and fieldQ is None:
                deref(c_inst).fieldQ = _containerStruct_defaults.fieldQ
                deref(c_inst).__isset.fieldQ = False
                pass

            if not __isNOTSET[17] and fieldR is None:
                deref(c_inst).fieldR.reset()
                pass

            if not __isNOTSET[18] and fieldS is None:
                deref(c_inst).fieldS.reset()
                pass

            if not __isNOTSET[19] and fieldT is None:
                deref(c_inst).fieldT.reset()
                pass

            if not __isNOTSET[20] and fieldU is None:
                deref(c_inst).fieldU.reset()
                pass

            if not __isNOTSET[21] and fieldX is None:
                deref(c_inst).fieldX.reset()
                pass

        if fieldA is not None:
            deref(c_inst).fieldA = fieldA
            deref(c_inst).__isset.fieldA = True
        if fieldB is not None:
            deref(c_inst).fieldB = deref(Map__string_bool(fieldB)._cpp_obj)
            deref(c_inst).__isset.fieldB = True
        if fieldC is not None:
            deref(c_inst).fieldC = deref(Set__i32(fieldC)._cpp_obj)
            deref(c_inst).__isset.fieldC = True
        if fieldD is not None:
            deref(c_inst).fieldD = thrift.py3.types.move(thrift.py3.types.bytes_to_string(fieldD.encode('utf-8')))
            deref(c_inst).__isset.fieldD = True
        if fieldE is not None:
            deref(c_inst).fieldE = thrift.py3.types.move(thrift.py3.types.bytes_to_string(fieldE.encode('utf-8')))
            deref(c_inst).__isset.fieldE = True
        if fieldF is not None:
            deref(c_inst).fieldF = deref(List__List__List__i32(fieldF)._cpp_obj)
            deref(c_inst).__isset.fieldF = True
        if fieldG is not None:
            deref(c_inst).fieldG = deref(Map__string_Map__string_Map__string_i32(fieldG)._cpp_obj)
            deref(c_inst).__isset.fieldG = True
        if fieldH is not None:
            deref(c_inst).fieldH = deref(List__Set__i32(fieldH)._cpp_obj)
            deref(c_inst).__isset.fieldH = True
        if fieldI is not None:
            deref(c_inst).fieldI = fieldI
            deref(c_inst).__isset.fieldI = True
        if fieldJ is not None:
            deref(c_inst).fieldJ = deref(Map__string_List__i32(fieldJ)._cpp_obj)
            deref(c_inst).__isset.fieldJ = True
        if fieldK is not None:
            deref(c_inst).fieldK = deref(List__List__List__List__i32(fieldK)._cpp_obj)
            deref(c_inst).__isset.fieldK = True
        if fieldL is not None:
            deref(c_inst).fieldL = deref(Set__Set__Set__bool(fieldL)._cpp_obj)
            deref(c_inst).__isset.fieldL = True
        if fieldM is not None:
            deref(c_inst).fieldM = deref(Map__Set__List__i32_Map__List__Set__string_string(fieldM)._cpp_obj)
            deref(c_inst).__isset.fieldM = True
        if fieldN is not None:
            deref(c_inst).fieldN = deref(List__Foo__i64(fieldN)._cpp_obj)
            deref(c_inst).__isset.fieldN = True
        if fieldO is not None:
            deref(c_inst).fieldO = deref(List__Bar__double(fieldO)._cpp_obj)
            deref(c_inst).__isset.fieldO = True
        if fieldP is not None:
            deref(c_inst).fieldP = deref(List__Baz__i32(fieldP)._cpp_obj)
            deref(c_inst).__isset.fieldP = True
        if fieldQ is not None:
            deref(c_inst).fieldQ = MyEnumA_to_cpp(fieldQ)
            deref(c_inst).__isset.fieldQ = True
        if fieldR is not None:
            deref(c_inst).fieldR = make_unique[cmap[string,cbool]](deref((<Map__string_bool?>fieldR)._cpp_obj))
        if fieldS is not None:
            deref(c_inst).fieldS = make_unique[cSmallStruct](deref((<SmallStruct?>fieldS)._cpp_obj))
        if fieldT is not None:
            deref(c_inst).fieldT = (<SmallStruct?>fieldT)._cpp_obj
        if fieldU is not None:
            deref(c_inst).fieldU = const_pointer_cast((<SmallStruct?>fieldU)._cpp_obj)
        if fieldX is not None:
            deref(c_inst).fieldX = make_unique[cSmallStruct](deref((<SmallStruct?>fieldX)._cpp_obj))
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'fieldA', self.fieldA
        yield 'fieldB', self.fieldB
        yield 'fieldC', self.fieldC
        yield 'fieldD', self.fieldD
        yield 'fieldE', self.fieldE
        yield 'fieldF', self.fieldF
        yield 'fieldG', self.fieldG
        yield 'fieldH', self.fieldH
        yield 'fieldI', self.fieldI
        yield 'fieldJ', self.fieldJ
        yield 'fieldK', self.fieldK
        yield 'fieldL', self.fieldL
        yield 'fieldM', self.fieldM
        yield 'fieldN', self.fieldN
        yield 'fieldO', self.fieldO
        yield 'fieldP', self.fieldP
        yield 'fieldQ', self.fieldQ
        yield 'fieldR', self.fieldR
        yield 'fieldS', self.fieldS
        yield 'fieldT', self.fieldT
        yield 'fieldU', self.fieldU
        yield 'fieldX', self.fieldX

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[ccontainerStruct] cpp_obj):
        inst = <containerStruct>containerStruct.__new__(containerStruct)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def fieldA(self):

        return <pbool> deref(self._cpp_obj).fieldA

    @property
    def fieldB(self):

        if self.__fieldB is None:
            self.__fieldB = Map__string_bool.create(reference_shared_ptr_fieldB(self._cpp_obj, deref(self._cpp_obj).fieldB))
        return self.__fieldB

    @property
    def fieldC(self):

        if self.__fieldC is None:
            self.__fieldC = Set__i32.create(reference_shared_ptr_fieldC(self._cpp_obj, deref(self._cpp_obj).fieldC))
        return self.__fieldC

    @property
    def fieldD(self):

        return (<bytes>deref(self._cpp_obj).fieldD).decode('UTF-8')

    @property
    def fieldE(self):

        return (<bytes>deref(self._cpp_obj).fieldE).decode('UTF-8')

    @property
    def fieldF(self):

        if self.__fieldF is None:
            self.__fieldF = List__List__List__i32.create(reference_shared_ptr_fieldF(self._cpp_obj, deref(self._cpp_obj).fieldF))
        return self.__fieldF

    @property
    def fieldG(self):

        if self.__fieldG is None:
            self.__fieldG = Map__string_Map__string_Map__string_i32.create(reference_shared_ptr_fieldG(self._cpp_obj, deref(self._cpp_obj).fieldG))
        return self.__fieldG

    @property
    def fieldH(self):

        if self.__fieldH is None:
            self.__fieldH = List__Set__i32.create(reference_shared_ptr_fieldH(self._cpp_obj, deref(self._cpp_obj).fieldH))
        return self.__fieldH

    @property
    def fieldI(self):

        return <pbool> deref(self._cpp_obj).fieldI

    @property
    def fieldJ(self):

        if self.__fieldJ is None:
            self.__fieldJ = Map__string_List__i32.create(reference_shared_ptr_fieldJ(self._cpp_obj, deref(self._cpp_obj).fieldJ))
        return self.__fieldJ

    @property
    def fieldK(self):

        if self.__fieldK is None:
            self.__fieldK = List__List__List__List__i32.create(reference_shared_ptr_fieldK(self._cpp_obj, deref(self._cpp_obj).fieldK))
        return self.__fieldK

    @property
    def fieldL(self):

        if self.__fieldL is None:
            self.__fieldL = Set__Set__Set__bool.create(reference_shared_ptr_fieldL(self._cpp_obj, deref(self._cpp_obj).fieldL))
        return self.__fieldL

    @property
    def fieldM(self):

        if self.__fieldM is None:
            self.__fieldM = Map__Set__List__i32_Map__List__Set__string_string.create(reference_shared_ptr_fieldM(self._cpp_obj, deref(self._cpp_obj).fieldM))
        return self.__fieldM

    @property
    def fieldN(self):

        if self.__fieldN is None:
            self.__fieldN = List__Foo__i64.create(reference_shared_ptr_fieldN(self._cpp_obj, deref(self._cpp_obj).fieldN))
        return self.__fieldN

    @property
    def fieldO(self):

        if self.__fieldO is None:
            self.__fieldO = List__Bar__double.create(reference_shared_ptr_fieldO(self._cpp_obj, deref(self._cpp_obj).fieldO))
        return self.__fieldO

    @property
    def fieldP(self):

        if self.__fieldP is None:
            self.__fieldP = List__Baz__i32.create(reference_shared_ptr_fieldP(self._cpp_obj, deref(self._cpp_obj).fieldP))
        return self.__fieldP

    @property
    def fieldQ(self):

        return translate_cpp_enum_to_python(MyEnumA, <int>(deref(self._cpp_obj).fieldQ))

    @property
    def fieldR(self):

        if self.__fieldR is None:
            if not deref(self._cpp_obj).fieldR:
                return None
            self.__fieldR = Map__string_bool.create(reference_shared_ptr_fieldR(self._cpp_obj, deref(deref(self._cpp_obj).fieldR)))
        return self.__fieldR

    @property
    def fieldS(self):

        if self.__fieldS is None:
            if not deref(self._cpp_obj).fieldS:
                return None
            self.__fieldS = SmallStruct.create(reference_shared_ptr_fieldS(self._cpp_obj, deref(deref(self._cpp_obj).fieldS)))
        return self.__fieldS

    @property
    def fieldT(self):

        if self.__fieldT is None:
            if not deref(self._cpp_obj).fieldT:
                return None
            self.__fieldT = SmallStruct.create(reference_shared_ptr_fieldT(self._cpp_obj, deref(deref(self._cpp_obj).fieldT)))
        return self.__fieldT

    @property
    def fieldU(self):

        if self.__fieldU is None:
            if not deref(self._cpp_obj).fieldU:
                return None
            self.__fieldU = SmallStruct.create(reference_shared_ptr_fieldU(self._cpp_obj, deref(deref(self._cpp_obj).fieldU)))
        return self.__fieldU

    @property
    def fieldX(self):

        if self.__fieldX is None:
            if not deref(self._cpp_obj).fieldX:
                return None
            self.__fieldX = SmallStruct.create(reference_shared_ptr_fieldX(self._cpp_obj, deref(deref(self._cpp_obj).fieldX)))
        return self.__fieldX


    def __hash__(containerStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.fieldA,
            self.fieldB,
            self.fieldC,
            self.fieldD,
            self.fieldE,
            self.fieldF,
            self.fieldG,
            self.fieldH,
            self.fieldI,
            self.fieldJ,
            self.fieldK,
            self.fieldL,
            self.fieldM,
            self.fieldN,
            self.fieldO,
            self.fieldP,
            self.fieldQ,
            self.fieldR,
            self.fieldS,
            self.fieldT,
            self.fieldU,
            self.fieldX,
            ))
        return self.__hash

    def __repr__(containerStruct self):
        return f'containerStruct(fieldA={repr(self.fieldA)}, fieldB={repr(self.fieldB)}, fieldC={repr(self.fieldC)}, fieldD={repr(self.fieldD)}, fieldE={repr(self.fieldE)}, fieldF={repr(self.fieldF)}, fieldG={repr(self.fieldG)}, fieldH={repr(self.fieldH)}, fieldI={repr(self.fieldI)}, fieldJ={repr(self.fieldJ)}, fieldK={repr(self.fieldK)}, fieldL={repr(self.fieldL)}, fieldM={repr(self.fieldM)}, fieldN={repr(self.fieldN)}, fieldO={repr(self.fieldO)}, fieldP={repr(self.fieldP)}, fieldQ={repr(self.fieldQ)}, fieldR={repr(self.fieldR)}, fieldS={repr(self.fieldS)}, fieldT={repr(self.fieldT)}, fieldU={repr(self.fieldU)}, fieldX={repr(self.fieldX)})'
    def __copy__(containerStruct self):
        cdef shared_ptr[ccontainerStruct] cpp_obj = make_shared[ccontainerStruct](
            deref(self._cpp_obj)
        )
        return containerStruct.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, containerStruct) and
                isinstance(other, containerStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef ccontainerStruct cself = deref((<containerStruct>self)._cpp_obj)
        cdef ccontainerStruct cother = deref((<containerStruct>other)._cpp_obj)
        if cop == Py_EQ:
            return cself == cother
        elif cop == Py_NE:
            return not (cself == cother)
        elif cop == Py_LT:
            return cself < cother
        elif cop == Py_LE:
            return cself <= cother
        elif cop == Py_GT:
            return cself > cother
        elif cop == Py_GE:
            return cself >= cother
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(containerStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef ccontainerStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[ccontainerStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[ccontainerStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[ccontainerStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[ccontainerStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(containerStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[ccontainerStruct]()
        cdef ccontainerStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[ccontainerStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[ccontainerStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[ccontainerStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[ccontainerStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (containerStruct, serialize(self)))


cdef class Map__string_bool:
    def __init__(self, items=None):
        if isinstance(items, Map__string_bool):
            self._cpp_obj = (<Map__string_bool> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_bool._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cbool]] c_items):
        inst = <Map__string_bool>Map__string_bool.__new__(Map__string_bool)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__string_bool self):
        cdef shared_ptr[cmap[string,cbool]] cpp_obj = make_shared[cmap[string,cbool]](
            deref(self._cpp_obj)
        )
        return Map__string_bool.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[string,cbool]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cbool]] c_inst = make_shared[cmap[string,cbool]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, bool):
                    raise TypeError(f"{item!r} is not of type bool")

                deref(c_inst)[key.encode('UTF-8')] = item
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,cbool].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef cbool citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef cmap[string,cbool].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef cbool citem
        cdef cmap[string,cbool].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield citem
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef cbool citem
        cdef cmap[string,cbool].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey.decode('UTF-8'), citem)
            inc(loc)

    def __reduce__(self):
        return (Map__string_bool, (dict(self), ))


Mapping.register(Map__string_bool)

cdef class Set__i32:
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._cpp_obj = (<Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[int32_t]] c_items):
        inst = <Set__i32>Set__i32.__new__(Set__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Set__i32 self):
        cdef shared_ptr[cset[int32_t]] cpp_obj = make_shared[cset[int32_t]](
            deref(self._cpp_obj)
        )
        return Set__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cset[int32_t]] _make_instance(object items) except *:
        cdef shared_ptr[cset[int32_t]] c_inst = make_shared[cset[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).insert(item)
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef cset[int32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[int32_t]] cself, cother
        cdef cset[int32_t].iterator loc
        if (isinstance(self, Set__i32) and
                isinstance(other, Set__i32)):
            cself = (<Set__i32> self)._cpp_obj
            cother = (<Set__i32> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()

        cdef shared_ptr[cset[int32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[int32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[int32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()

        cdef shared_ptr[cset[int32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[int32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[int32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()

        cdef shared_ptr[cset[int32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[int32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[int32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()

        cdef shared_ptr[cset[int32_t]] cself = (<Set__i32> self)._cpp_obj
        cdef shared_ptr[cset[int32_t]] cother = (<Set__i32> other)._cpp_obj

        cdef cset[int32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__i32.create(move_shared(shretval))

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other

    def __reduce__(self):
        return (Set__i32, (set(self), ))


Set.register(Set__i32)

cdef class List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[int32_t]] c_items):
        inst = <List__i32>List__i32.__new__(List__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__i32 self):
        cdef shared_ptr[vector[int32_t]] cpp_obj = make_shared[vector[int32_t]](
            deref(self._cpp_obj)
        )
        return List__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[int32_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[int32_t]] c_inst = make_shared[vector[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__i32.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[vector[int32_t].iterator, int32_t](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef vector[int32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef vector[int32_t].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef vector[int32_t].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef vector[int32_t].iterator loc = std_libcpp.find[vector[int32_t].iterator, int32_t](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <int64_t> std_libcpp.count[vector[int32_t].iterator, int32_t](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    def __reduce__(self):
        return (List__i32, (list(self), ))


Sequence.register(List__i32)

cdef class List__List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__List__i32):
            self._cpp_obj = (<List__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[vector[int32_t]]] c_items):
        inst = <List__List__i32>List__List__i32.__new__(List__List__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__List__i32 self):
        cdef shared_ptr[vector[vector[int32_t]]] cpp_obj = make_shared[vector[vector[int32_t]]](
            deref(self._cpp_obj)
        )
        return List__List__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[vector[int32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[vector[int32_t]]] c_inst = make_shared[vector[vector[int32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[int]")
                if not isinstance(item, List__i32):
                    item = List__i32(item)
                deref(c_inst).push_back(deref((<List__i32>item)._cpp_obj))
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[vector[int32_t]]] c_inst
        cdef shared_ptr[vector[int32_t]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[vector[int32_t]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__List__i32.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__List__i32(self._cpp_obj, deref(self._cpp_obj)[index])
            return List__i32.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            return False
        if not isinstance(item, List__i32):
            return False
        return std_libcpp.find[vector[vector[int32_t]].iterator, vector[int32_t]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__i32>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[vector[int32_t]] citem
        cdef vector[vector[int32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__List__i32(self._cpp_obj, deref(loc))
            yield List__i32.create(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[vector[int32_t]] citem
        cdef vector[vector[int32_t]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__List__i32(self._cpp_obj, deref(loc))
            yield List__i32.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, List__i32):
            raise err
        cdef vector[vector[int32_t]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef vector[vector[int32_t]].iterator loc = std_libcpp.find[vector[vector[int32_t]].iterator, vector[int32_t]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            deref((<List__i32>item)._cpp_obj)        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            return 0
        if not isinstance(item, List__i32):
            return 0
        return <int64_t> std_libcpp.count[vector[vector[int32_t]].iterator, vector[int32_t]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__i32>item)._cpp_obj))

    def __reduce__(self):
        return (List__List__i32, (list(self), ))


Sequence.register(List__List__i32)

cdef class List__List__List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__List__List__i32):
            self._cpp_obj = (<List__List__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__List__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[vector[vector[int32_t]]]] c_items):
        inst = <List__List__List__i32>List__List__List__i32.__new__(List__List__List__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__List__List__i32 self):
        cdef shared_ptr[vector[vector[vector[int32_t]]]] cpp_obj = make_shared[vector[vector[vector[int32_t]]]](
            deref(self._cpp_obj)
        )
        return List__List__List__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[vector[vector[int32_t]]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[vector[vector[int32_t]]]] c_inst = make_shared[vector[vector[vector[int32_t]]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[_typing.Sequence[int]]")
                if not isinstance(item, List__List__i32):
                    item = List__List__i32(item)
                deref(c_inst).push_back(deref((<List__List__i32>item)._cpp_obj))
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[vector[vector[int32_t]]]] c_inst
        cdef shared_ptr[vector[vector[int32_t]]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[vector[vector[int32_t]]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__List__List__i32.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__List__List__i32(self._cpp_obj, deref(self._cpp_obj)[index])
            return List__List__i32.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, List__List__i32):
                item = List__List__i32(item)
        except Exception:
            return False
        if not isinstance(item, List__List__i32):
            return False
        return std_libcpp.find[vector[vector[vector[int32_t]]].iterator, vector[vector[int32_t]]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__List__i32>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[vector[vector[int32_t]]] citem
        cdef vector[vector[vector[int32_t]]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__List__List__i32(self._cpp_obj, deref(loc))
            yield List__List__i32.create(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[vector[vector[int32_t]]] citem
        cdef vector[vector[vector[int32_t]]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__List__List__i32(self._cpp_obj, deref(loc))
            yield List__List__i32.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, List__List__i32):
                item = List__List__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, List__List__i32):
            raise err
        cdef vector[vector[vector[int32_t]]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef vector[vector[vector[int32_t]]].iterator loc = std_libcpp.find[vector[vector[vector[int32_t]]].iterator, vector[vector[int32_t]]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            deref((<List__List__i32>item)._cpp_obj)        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, List__List__i32):
                item = List__List__i32(item)
        except Exception:
            return 0
        if not isinstance(item, List__List__i32):
            return 0
        return <int64_t> std_libcpp.count[vector[vector[vector[int32_t]]].iterator, vector[vector[int32_t]]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__List__i32>item)._cpp_obj))

    def __reduce__(self):
        return (List__List__List__i32, (list(self), ))


Sequence.register(List__List__List__i32)

cdef class Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_i32):
            self._cpp_obj = (<Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,int32_t]] c_items):
        inst = <Map__string_i32>Map__string_i32.__new__(Map__string_i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__string_i32 self):
        cdef shared_ptr[cmap[string,int32_t]] cpp_obj = make_shared[cmap[string,int32_t]](
            deref(self._cpp_obj)
        )
        return Map__string_i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[string,int32_t]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,int32_t]] c_inst = make_shared[cmap[string,int32_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item

                deref(c_inst)[key.encode('UTF-8')] = item
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,int32_t].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef int32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef cmap[string,int32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef cmap[string,int32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield citem
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef int32_t citem
        cdef cmap[string,int32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey.decode('UTF-8'), citem)
            inc(loc)

    def __reduce__(self):
        return (Map__string_i32, (dict(self), ))


Mapping.register(Map__string_i32)

cdef class Map__string_Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_Map__string_i32):
            self._cpp_obj = (<Map__string_Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_Map__string_i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cmap[string,int32_t]]] c_items):
        inst = <Map__string_Map__string_i32>Map__string_Map__string_i32.__new__(Map__string_Map__string_i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__string_Map__string_i32 self):
        cdef shared_ptr[cmap[string,cmap[string,int32_t]]] cpp_obj = make_shared[cmap[string,cmap[string,int32_t]]](
            deref(self._cpp_obj)
        )
        return Map__string_Map__string_i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[string,cmap[string,int32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cmap[string,int32_t]]] c_inst = make_shared[cmap[string,cmap[string,int32_t]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[str, int]")
                if not isinstance(item, Map__string_i32):
                    item = Map__string_i32(item)

                deref(c_inst)[key.encode('UTF-8')] = deref((<Map__string_i32>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,cmap[string,int32_t]].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[cmap[string,int32_t]] citem = reference_shared_ptr_Map__string_Map__string_i32(self._cpp_obj, deref(iter).second)
        return Map__string_i32.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef cmap[string,cmap[string,int32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[cmap[string,int32_t]] citem
        cdef cmap[string,cmap[string,int32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__string_Map__string_i32(self._cpp_obj, deref(loc).second)
            yield Map__string_i32.create(citem)
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef shared_ptr[cmap[string,int32_t]] citem
        cdef cmap[string,cmap[string,int32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__string_Map__string_i32(self._cpp_obj, deref(loc).second)
            yield (ckey.decode('UTF-8'), Map__string_i32.create(citem))
            inc(loc)

    def __reduce__(self):
        return (Map__string_Map__string_i32, (dict(self), ))


Mapping.register(Map__string_Map__string_i32)

cdef class Map__string_Map__string_Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_Map__string_Map__string_i32):
            self._cpp_obj = (<Map__string_Map__string_Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_Map__string_Map__string_i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cmap[string,cmap[string,int32_t]]]] c_items):
        inst = <Map__string_Map__string_Map__string_i32>Map__string_Map__string_Map__string_i32.__new__(Map__string_Map__string_Map__string_i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__string_Map__string_Map__string_i32 self):
        cdef shared_ptr[cmap[string,cmap[string,cmap[string,int32_t]]]] cpp_obj = make_shared[cmap[string,cmap[string,cmap[string,int32_t]]]](
            deref(self._cpp_obj)
        )
        return Map__string_Map__string_Map__string_i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[string,cmap[string,cmap[string,int32_t]]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cmap[string,cmap[string,int32_t]]]] c_inst = make_shared[cmap[string,cmap[string,cmap[string,int32_t]]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[str, _typing.Mapping[str, int]]")
                if not isinstance(item, Map__string_Map__string_i32):
                    item = Map__string_Map__string_i32(item)

                deref(c_inst)[key.encode('UTF-8')] = deref((<Map__string_Map__string_i32>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,cmap[string,cmap[string,int32_t]]].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[cmap[string,cmap[string,int32_t]]] citem = reference_shared_ptr_Map__string_Map__string_Map__string_i32(self._cpp_obj, deref(iter).second)
        return Map__string_Map__string_i32.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef cmap[string,cmap[string,cmap[string,int32_t]]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[cmap[string,cmap[string,int32_t]]] citem
        cdef cmap[string,cmap[string,cmap[string,int32_t]]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__string_Map__string_Map__string_i32(self._cpp_obj, deref(loc).second)
            yield Map__string_Map__string_i32.create(citem)
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef shared_ptr[cmap[string,cmap[string,int32_t]]] citem
        cdef cmap[string,cmap[string,cmap[string,int32_t]]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__string_Map__string_Map__string_i32(self._cpp_obj, deref(loc).second)
            yield (ckey.decode('UTF-8'), Map__string_Map__string_i32.create(citem))
            inc(loc)

    def __reduce__(self):
        return (Map__string_Map__string_Map__string_i32, (dict(self), ))


Mapping.register(Map__string_Map__string_Map__string_i32)

cdef class List__Set__i32:
    def __init__(self, items=None):
        if isinstance(items, List__Set__i32):
            self._cpp_obj = (<List__Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cset[int32_t]]] c_items):
        inst = <List__Set__i32>List__Set__i32.__new__(List__Set__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__Set__i32 self):
        cdef shared_ptr[vector[cset[int32_t]]] cpp_obj = make_shared[vector[cset[int32_t]]](
            deref(self._cpp_obj)
        )
        return List__Set__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[cset[int32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cset[int32_t]]] c_inst = make_shared[vector[cset[int32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.AbstractSet[int]")
                if not isinstance(item, Set__i32):
                    item = Set__i32(item)
                deref(c_inst).push_back(deref((<Set__i32>item)._cpp_obj))
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cset[int32_t]]] c_inst
        cdef shared_ptr[cset[int32_t]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cset[int32_t]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Set__i32.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__Set__i32(self._cpp_obj, deref(self._cpp_obj)[index])
            return Set__i32.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            return False
        if not isinstance(item, Set__i32):
            return False
        return std_libcpp.find[vector[cset[int32_t]].iterator, cset[int32_t]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__i32>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[cset[int32_t]] citem
        cdef vector[cset[int32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__Set__i32(self._cpp_obj, deref(loc))
            yield Set__i32.create(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[cset[int32_t]] citem
        cdef vector[cset[int32_t]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__Set__i32(self._cpp_obj, deref(loc))
            yield Set__i32.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, Set__i32):
            raise err
        cdef vector[cset[int32_t]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef vector[cset[int32_t]].iterator loc = std_libcpp.find[vector[cset[int32_t]].iterator, cset[int32_t]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            deref((<Set__i32>item)._cpp_obj)        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Set__i32):
                item = Set__i32(item)
        except Exception:
            return 0
        if not isinstance(item, Set__i32):
            return 0
        return <int64_t> std_libcpp.count[vector[cset[int32_t]].iterator, cset[int32_t]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__i32>item)._cpp_obj))

    def __reduce__(self):
        return (List__Set__i32, (list(self), ))


Sequence.register(List__Set__i32)

cdef class Map__string_List__i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_List__i32):
            self._cpp_obj = (<Map__string_List__i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,vector[int32_t]]] c_items):
        inst = <Map__string_List__i32>Map__string_List__i32.__new__(Map__string_List__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__string_List__i32 self):
        cdef shared_ptr[cmap[string,vector[int32_t]]] cpp_obj = make_shared[cmap[string,vector[int32_t]]](
            deref(self._cpp_obj)
        )
        return Map__string_List__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[string,vector[int32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,vector[int32_t]]] c_inst = make_shared[cmap[string,vector[int32_t]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence[int]")
                if not isinstance(item, List__i32):
                    item = List__i32(item)

                deref(c_inst)[key.encode('UTF-8')] = deref((<List__i32>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,vector[int32_t]].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[vector[int32_t]] citem = reference_shared_ptr_Map__string_List__i32(self._cpp_obj, deref(iter).second)
        return List__i32.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef cmap[string,vector[int32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[vector[int32_t]] citem
        cdef cmap[string,vector[int32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__string_List__i32(self._cpp_obj, deref(loc).second)
            yield List__i32.create(citem)
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef shared_ptr[vector[int32_t]] citem
        cdef cmap[string,vector[int32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__string_List__i32(self._cpp_obj, deref(loc).second)
            yield (ckey.decode('UTF-8'), List__i32.create(citem))
            inc(loc)

    def __reduce__(self):
        return (Map__string_List__i32, (dict(self), ))


Mapping.register(Map__string_List__i32)

cdef class List__List__List__List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__List__List__List__i32):
            self._cpp_obj = (<List__List__List__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__List__List__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[vector[vector[vector[int32_t]]]]] c_items):
        inst = <List__List__List__List__i32>List__List__List__List__i32.__new__(List__List__List__List__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__List__List__List__i32 self):
        cdef shared_ptr[vector[vector[vector[vector[int32_t]]]]] cpp_obj = make_shared[vector[vector[vector[vector[int32_t]]]]](
            deref(self._cpp_obj)
        )
        return List__List__List__List__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[vector[vector[vector[int32_t]]]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[vector[vector[vector[int32_t]]]]] c_inst = make_shared[vector[vector[vector[vector[int32_t]]]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]")
                if not isinstance(item, List__List__List__i32):
                    item = List__List__List__i32(item)
                deref(c_inst).push_back(deref((<List__List__List__i32>item)._cpp_obj))
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[vector[vector[vector[int32_t]]]]] c_inst
        cdef shared_ptr[vector[vector[vector[int32_t]]]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[vector[vector[vector[int32_t]]]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__List__List__List__i32.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__List__List__List__i32(self._cpp_obj, deref(self._cpp_obj)[index])
            return List__List__List__i32.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, List__List__List__i32):
                item = List__List__List__i32(item)
        except Exception:
            return False
        if not isinstance(item, List__List__List__i32):
            return False
        return std_libcpp.find[vector[vector[vector[vector[int32_t]]]].iterator, vector[vector[vector[int32_t]]]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__List__List__i32>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[vector[vector[vector[int32_t]]]] citem
        cdef vector[vector[vector[vector[int32_t]]]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__List__List__List__i32(self._cpp_obj, deref(loc))
            yield List__List__List__i32.create(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[vector[vector[vector[int32_t]]]] citem
        cdef vector[vector[vector[vector[int32_t]]]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__List__List__List__i32(self._cpp_obj, deref(loc))
            yield List__List__List__i32.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, List__List__List__i32):
                item = List__List__List__i32(item)
        except Exception:
            raise err from None
        if not isinstance(item, List__List__List__i32):
            raise err
        cdef vector[vector[vector[vector[int32_t]]]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef vector[vector[vector[vector[int32_t]]]].iterator loc = std_libcpp.find[vector[vector[vector[vector[int32_t]]]].iterator, vector[vector[vector[int32_t]]]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            deref((<List__List__List__i32>item)._cpp_obj)        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, List__List__List__i32):
                item = List__List__List__i32(item)
        except Exception:
            return 0
        if not isinstance(item, List__List__List__i32):
            return 0
        return <int64_t> std_libcpp.count[vector[vector[vector[vector[int32_t]]]].iterator, vector[vector[vector[int32_t]]]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<List__List__List__i32>item)._cpp_obj))

    def __reduce__(self):
        return (List__List__List__List__i32, (list(self), ))


Sequence.register(List__List__List__List__i32)

cdef class Set__bool:
    def __init__(self, items=None):
        if isinstance(items, Set__bool):
            self._cpp_obj = (<Set__bool> items)._cpp_obj
        else:
            self._cpp_obj = Set__bool._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[cbool]] c_items):
        inst = <Set__bool>Set__bool.__new__(Set__bool)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Set__bool self):
        cdef shared_ptr[cset[cbool]] cpp_obj = make_shared[cset[cbool]](
            deref(self._cpp_obj)
        )
        return Set__bool.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cset[cbool]] _make_instance(object items) except *:
        cdef shared_ptr[cset[cbool]] c_inst = make_shared[cset[cbool]]()
        if items is not None:
            for item in items:
                if not isinstance(item, bool):
                    raise TypeError(f"{item!r} is not of type bool")
                deref(c_inst).insert(item)
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, bool):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cbool citem
        cdef cset[cbool].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[cbool]] cself, cother
        cdef cset[cbool].iterator loc
        if (isinstance(self, Set__bool) and
                isinstance(other, Set__bool)):
            cself = (<Set__bool> self)._cpp_obj
            cother = (<Set__bool> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__bool):
            self = Set__bool(self)
        if not isinstance(other, Set__bool):
            other = Set__bool(other)

        cdef shared_ptr[cset[cbool]] shretval = \
            make_shared[cset[cbool]]()

        cdef shared_ptr[cset[cbool]] cself = (<Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cbool]] cother = (<Set__bool> other)._cpp_obj

        cdef cset[cbool].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__bool.create(move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__bool):
            self = Set__bool(self)
        if not isinstance(other, Set__bool):
            other = Set__bool(other)

        cdef shared_ptr[cset[cbool]] shretval = \
            make_shared[cset[cbool]]()

        cdef shared_ptr[cset[cbool]] cself = (<Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cbool]] cother = (<Set__bool> other)._cpp_obj

        cdef cset[cbool].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__bool.create(move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__bool):
            self = Set__bool(self)
        if not isinstance(other, Set__bool):
            other = Set__bool(other)

        cdef shared_ptr[cset[cbool]] shretval = \
            make_shared[cset[cbool]]()

        cdef shared_ptr[cset[cbool]] cself = (<Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cbool]] cother = (<Set__bool> other)._cpp_obj

        cdef cset[cbool].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__bool.create(move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__bool):
            self = Set__bool(self)
        if not isinstance(other, Set__bool):
            other = Set__bool(other)

        cdef shared_ptr[cset[cbool]] shretval = \
            make_shared[cset[cbool]]()

        cdef shared_ptr[cset[cbool]] cself = (<Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cbool]] cother = (<Set__bool> other)._cpp_obj

        cdef cset[cbool].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__bool.create(move_shared(shretval))

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other

    def __reduce__(self):
        return (Set__bool, (set(self), ))


Set.register(Set__bool)

cdef class Set__Set__bool:
    def __init__(self, items=None):
        if isinstance(items, Set__Set__bool):
            self._cpp_obj = (<Set__Set__bool> items)._cpp_obj
        else:
            self._cpp_obj = Set__Set__bool._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[cset[cbool]]] c_items):
        inst = <Set__Set__bool>Set__Set__bool.__new__(Set__Set__bool)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Set__Set__bool self):
        cdef shared_ptr[cset[cset[cbool]]] cpp_obj = make_shared[cset[cset[cbool]]](
            deref(self._cpp_obj)
        )
        return Set__Set__bool.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cset[cset[cbool]]] _make_instance(object items) except *:
        cdef shared_ptr[cset[cset[cbool]]] c_inst = make_shared[cset[cset[cbool]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of type _typing.AbstractSet[bool]")
                if not isinstance(item, Set__bool):
                    item = Set__bool(item)
                deref(c_inst).insert(deref((<Set__bool>item)._cpp_obj))
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__bool):
                item = Set__bool(item)
        except Exception:
            return False
        if not isinstance(item, Set__bool):
            return False
        return pbool(deref(self._cpp_obj).count(deref((<Set__bool>item)._cpp_obj)))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[cset[cbool]] citem
        cdef cset[cset[cbool]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Set__Set__bool(self._cpp_obj, deref(loc))
            yield Set__bool.create(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[cset[cbool]]] cself, cother
        cdef cset[cset[cbool]].iterator loc
        if (isinstance(self, Set__Set__bool) and
                isinstance(other, Set__Set__bool)):
            cself = (<Set__Set__bool> self)._cpp_obj
            cother = (<Set__Set__bool> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__Set__bool):
            self = Set__Set__bool(self)
        if not isinstance(other, Set__Set__bool):
            other = Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cbool]]] shretval = \
            make_shared[cset[cset[cbool]]]()

        cdef shared_ptr[cset[cset[cbool]]] cself = (<Set__Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cset[cbool]]] cother = (<Set__Set__bool> other)._cpp_obj

        cdef cset[cset[cbool]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Set__bool.create(move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__Set__bool):
            self = Set__Set__bool(self)
        if not isinstance(other, Set__Set__bool):
            other = Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cbool]]] shretval = \
            make_shared[cset[cset[cbool]]]()

        cdef shared_ptr[cset[cset[cbool]]] cself = (<Set__Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cset[cbool]]] cother = (<Set__Set__bool> other)._cpp_obj

        cdef cset[cset[cbool]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Set__bool.create(move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__Set__bool):
            self = Set__Set__bool(self)
        if not isinstance(other, Set__Set__bool):
            other = Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cbool]]] shretval = \
            make_shared[cset[cset[cbool]]]()

        cdef shared_ptr[cset[cset[cbool]]] cself = (<Set__Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cset[cbool]]] cother = (<Set__Set__bool> other)._cpp_obj

        cdef cset[cset[cbool]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Set__bool.create(move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__Set__bool):
            self = Set__Set__bool(self)
        if not isinstance(other, Set__Set__bool):
            other = Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cbool]]] shretval = \
            make_shared[cset[cset[cbool]]]()

        cdef shared_ptr[cset[cset[cbool]]] cself = (<Set__Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cset[cbool]]] cother = (<Set__Set__bool> other)._cpp_obj

        cdef cset[cset[cbool]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Set__bool.create(move_shared(shretval))

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other

    def __reduce__(self):
        return (Set__Set__bool, (set(self), ))


Set.register(Set__Set__bool)

cdef class Set__Set__Set__bool:
    def __init__(self, items=None):
        if isinstance(items, Set__Set__Set__bool):
            self._cpp_obj = (<Set__Set__Set__bool> items)._cpp_obj
        else:
            self._cpp_obj = Set__Set__Set__bool._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[cset[cset[cbool]]]] c_items):
        inst = <Set__Set__Set__bool>Set__Set__Set__bool.__new__(Set__Set__Set__bool)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Set__Set__Set__bool self):
        cdef shared_ptr[cset[cset[cset[cbool]]]] cpp_obj = make_shared[cset[cset[cset[cbool]]]](
            deref(self._cpp_obj)
        )
        return Set__Set__Set__bool.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cset[cset[cset[cbool]]]] _make_instance(object items) except *:
        cdef shared_ptr[cset[cset[cset[cbool]]]] c_inst = make_shared[cset[cset[cset[cbool]]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of type _typing.AbstractSet[_typing.AbstractSet[bool]]")
                if not isinstance(item, Set__Set__bool):
                    item = Set__Set__bool(item)
                deref(c_inst).insert(deref((<Set__Set__bool>item)._cpp_obj))
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__Set__bool):
                item = Set__Set__bool(item)
        except Exception:
            return False
        if not isinstance(item, Set__Set__bool):
            return False
        return pbool(deref(self._cpp_obj).count(deref((<Set__Set__bool>item)._cpp_obj)))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[cset[cset[cbool]]] citem
        cdef cset[cset[cset[cbool]]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Set__Set__Set__bool(self._cpp_obj, deref(loc))
            yield Set__Set__bool.create(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[cset[cset[cbool]]]] cself, cother
        cdef cset[cset[cset[cbool]]].iterator loc
        if (isinstance(self, Set__Set__Set__bool) and
                isinstance(other, Set__Set__Set__bool)):
            cself = (<Set__Set__Set__bool> self)._cpp_obj
            cother = (<Set__Set__Set__bool> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__Set__Set__bool):
            self = Set__Set__Set__bool(self)
        if not isinstance(other, Set__Set__Set__bool):
            other = Set__Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cset[cbool]]]] shretval = \
            make_shared[cset[cset[cset[cbool]]]]()

        cdef shared_ptr[cset[cset[cset[cbool]]]] cself = (<Set__Set__Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cset[cset[cbool]]]] cother = (<Set__Set__Set__bool> other)._cpp_obj

        cdef cset[cset[cset[cbool]]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Set__Set__bool.create(move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__Set__Set__bool):
            self = Set__Set__Set__bool(self)
        if not isinstance(other, Set__Set__Set__bool):
            other = Set__Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cset[cbool]]]] shretval = \
            make_shared[cset[cset[cset[cbool]]]]()

        cdef shared_ptr[cset[cset[cset[cbool]]]] cself = (<Set__Set__Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cset[cset[cbool]]]] cother = (<Set__Set__Set__bool> other)._cpp_obj

        cdef cset[cset[cset[cbool]]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Set__Set__bool.create(move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__Set__Set__bool):
            self = Set__Set__Set__bool(self)
        if not isinstance(other, Set__Set__Set__bool):
            other = Set__Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cset[cbool]]]] shretval = \
            make_shared[cset[cset[cset[cbool]]]]()

        cdef shared_ptr[cset[cset[cset[cbool]]]] cself = (<Set__Set__Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cset[cset[cbool]]]] cother = (<Set__Set__Set__bool> other)._cpp_obj

        cdef cset[cset[cset[cbool]]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Set__Set__bool.create(move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__Set__Set__bool):
            self = Set__Set__Set__bool(self)
        if not isinstance(other, Set__Set__Set__bool):
            other = Set__Set__Set__bool(other)

        cdef shared_ptr[cset[cset[cset[cbool]]]] shretval = \
            make_shared[cset[cset[cset[cbool]]]]()

        cdef shared_ptr[cset[cset[cset[cbool]]]] cself = (<Set__Set__Set__bool> self)._cpp_obj
        cdef shared_ptr[cset[cset[cset[cbool]]]] cother = (<Set__Set__Set__bool> other)._cpp_obj

        cdef cset[cset[cset[cbool]]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Set__Set__bool.create(move_shared(shretval))

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other

    def __reduce__(self):
        return (Set__Set__Set__bool, (set(self), ))


Set.register(Set__Set__Set__bool)

cdef class Set__List__i32:
    def __init__(self, items=None):
        if isinstance(items, Set__List__i32):
            self._cpp_obj = (<Set__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = Set__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[vector[int32_t]]] c_items):
        inst = <Set__List__i32>Set__List__i32.__new__(Set__List__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Set__List__i32 self):
        cdef shared_ptr[cset[vector[int32_t]]] cpp_obj = make_shared[cset[vector[int32_t]]](
            deref(self._cpp_obj)
        )
        return Set__List__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cset[vector[int32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[cset[vector[int32_t]]] c_inst = make_shared[cset[vector[int32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence[int]")
                if not isinstance(item, List__i32):
                    item = List__i32(item)
                deref(c_inst).insert(deref((<List__i32>item)._cpp_obj))
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            return False
        if not isinstance(item, List__i32):
            return False
        return pbool(deref(self._cpp_obj).count(deref((<List__i32>item)._cpp_obj)))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[vector[int32_t]] citem
        cdef cset[vector[int32_t]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Set__List__i32(self._cpp_obj, deref(loc))
            yield List__i32.create(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[vector[int32_t]]] cself, cother
        cdef cset[vector[int32_t]].iterator loc
        if (isinstance(self, Set__List__i32) and
                isinstance(other, Set__List__i32)):
            cself = (<Set__List__i32> self)._cpp_obj
            cother = (<Set__List__i32> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__List__i32):
            self = Set__List__i32(self)
        if not isinstance(other, Set__List__i32):
            other = Set__List__i32(other)

        cdef shared_ptr[cset[vector[int32_t]]] shretval = \
            make_shared[cset[vector[int32_t]]]()

        cdef shared_ptr[cset[vector[int32_t]]] cself = (<Set__List__i32> self)._cpp_obj
        cdef shared_ptr[cset[vector[int32_t]]] cother = (<Set__List__i32> other)._cpp_obj

        cdef cset[vector[int32_t]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__List__i32.create(move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__List__i32):
            self = Set__List__i32(self)
        if not isinstance(other, Set__List__i32):
            other = Set__List__i32(other)

        cdef shared_ptr[cset[vector[int32_t]]] shretval = \
            make_shared[cset[vector[int32_t]]]()

        cdef shared_ptr[cset[vector[int32_t]]] cself = (<Set__List__i32> self)._cpp_obj
        cdef shared_ptr[cset[vector[int32_t]]] cother = (<Set__List__i32> other)._cpp_obj

        cdef cset[vector[int32_t]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__List__i32.create(move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__List__i32):
            self = Set__List__i32(self)
        if not isinstance(other, Set__List__i32):
            other = Set__List__i32(other)

        cdef shared_ptr[cset[vector[int32_t]]] shretval = \
            make_shared[cset[vector[int32_t]]]()

        cdef shared_ptr[cset[vector[int32_t]]] cself = (<Set__List__i32> self)._cpp_obj
        cdef shared_ptr[cset[vector[int32_t]]] cother = (<Set__List__i32> other)._cpp_obj

        cdef cset[vector[int32_t]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__List__i32.create(move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__List__i32):
            self = Set__List__i32(self)
        if not isinstance(other, Set__List__i32):
            other = Set__List__i32(other)

        cdef shared_ptr[cset[vector[int32_t]]] shretval = \
            make_shared[cset[vector[int32_t]]]()

        cdef shared_ptr[cset[vector[int32_t]]] cself = (<Set__List__i32> self)._cpp_obj
        cdef shared_ptr[cset[vector[int32_t]]] cother = (<Set__List__i32> other)._cpp_obj

        cdef cset[vector[int32_t]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__List__i32.create(move_shared(shretval))

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other

    def __reduce__(self):
        return (Set__List__i32, (set(self), ))


Set.register(Set__List__i32)

cdef class Set__string:
    def __init__(self, items=None):
        if isinstance(items, Set__string):
            self._cpp_obj = (<Set__string> items)._cpp_obj
        else:
            self._cpp_obj = Set__string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        inst = <Set__string>Set__string.__new__(Set__string)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Set__string self):
        cdef shared_ptr[cset[string]] cpp_obj = make_shared[cset[string]](
            deref(self._cpp_obj)
        )
        return Set__string.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cset[string]] _make_instance(object items) except *:
        cdef shared_ptr[cset[string]] c_inst = make_shared[cset[string]]()
        if items is not None:
            for item in items:
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")
                deref(c_inst).insert(item.encode('UTF-8'))
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, str):
            return False
        return pbool(deref(self._cpp_obj).count(item.encode('UTF-8')))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef cset[string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[string]] cself, cother
        cdef cset[string].iterator loc
        if (isinstance(self, Set__string) and
                isinstance(other, Set__string)):
            cself = (<Set__string> self)._cpp_obj
            cother = (<Set__string> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__string> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__string> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__string.create(move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__string> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__string> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__string.create(move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__string> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__string> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__string.create(move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()

        cdef shared_ptr[cset[string]] cself = (<Set__string> self)._cpp_obj
        cdef shared_ptr[cset[string]] cother = (<Set__string> other)._cpp_obj

        cdef cset[string].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__string.create(move_shared(shretval))

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other

    def __reduce__(self):
        return (Set__string, (set(self), ))


Set.register(Set__string)

cdef class List__Set__string:
    def __init__(self, items=None):
        if isinstance(items, List__Set__string):
            self._cpp_obj = (<List__Set__string> items)._cpp_obj
        else:
            self._cpp_obj = List__Set__string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cset[string]]] c_items):
        inst = <List__Set__string>List__Set__string.__new__(List__Set__string)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__Set__string self):
        cdef shared_ptr[vector[cset[string]]] cpp_obj = make_shared[vector[cset[string]]](
            deref(self._cpp_obj)
        )
        return List__Set__string.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[cset[string]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cset[string]]] c_inst = make_shared[vector[cset[string]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.AbstractSet[str]")
                if not isinstance(item, Set__string):
                    item = Set__string(item)
                deref(c_inst).push_back(deref((<Set__string>item)._cpp_obj))
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cset[string]]] c_inst
        cdef shared_ptr[cset[string]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cset[string]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Set__string.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__Set__string(self._cpp_obj, deref(self._cpp_obj)[index])
            return Set__string.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__string):
                item = Set__string(item)
        except Exception:
            return False
        if not isinstance(item, Set__string):
            return False
        return std_libcpp.find[vector[cset[string]].iterator, cset[string]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__string>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[cset[string]] citem
        cdef vector[cset[string]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__Set__string(self._cpp_obj, deref(loc))
            yield Set__string.create(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[cset[string]] citem
        cdef vector[cset[string]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__Set__string(self._cpp_obj, deref(loc))
            yield Set__string.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Set__string):
                item = Set__string(item)
        except Exception:
            raise err from None
        if not isinstance(item, Set__string):
            raise err
        cdef vector[cset[string]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef vector[cset[string]].iterator loc = std_libcpp.find[vector[cset[string]].iterator, cset[string]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            deref((<Set__string>item)._cpp_obj)        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Set__string):
                item = Set__string(item)
        except Exception:
            return 0
        if not isinstance(item, Set__string):
            return 0
        return <int64_t> std_libcpp.count[vector[cset[string]].iterator, cset[string]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Set__string>item)._cpp_obj))

    def __reduce__(self):
        return (List__Set__string, (list(self), ))


Sequence.register(List__Set__string)

cdef class Map__List__Set__string_string:
    def __init__(self, items=None):
        if isinstance(items, Map__List__Set__string_string):
            self._cpp_obj = (<Map__List__Set__string_string> items)._cpp_obj
        else:
            self._cpp_obj = Map__List__Set__string_string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[vector[cset[string]],string]] c_items):
        inst = <Map__List__Set__string_string>Map__List__Set__string_string.__new__(Map__List__Set__string_string)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__List__Set__string_string self):
        cdef shared_ptr[cmap[vector[cset[string]],string]] cpp_obj = make_shared[cmap[vector[cset[string]],string]](
            deref(self._cpp_obj)
        )
        return Map__List__Set__string_string.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[vector[cset[string]],string]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[vector[cset[string]],string]] c_inst = make_shared[cmap[vector[cset[string]],string]]()
        if items is not None:
            for key, item in items.items():
                if key is None:
                    raise TypeError("None is not of type _typing.Sequence[_typing.AbstractSet[str]]")
                if not isinstance(key, List__Set__string):
                    key = List__Set__string(key)
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst)[deref((<List__Set__string>key)._cpp_obj)] = item.encode('UTF-8')
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        try:
            if not isinstance(key, List__Set__string):
                key = List__Set__string(key)
        except Exception:
            raise err from None
        if not isinstance(key, List__Set__string):
            raise err from None
        cdef cmap[vector[cset[string]],string].iterator iter = deref(
            self._cpp_obj).find(deref((<List__Set__string>key)._cpp_obj))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[vector[cset[string]]] citem
        cdef cmap[vector[cset[string]],string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__List__Set__string_string_key(self._cpp_obj, deref(loc).first)
            yield List__Set__string.create(citem)
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        try:
            if not isinstance(key, List__Set__string):
                key = List__Set__string(key)
        except Exception:
            return False
        if not isinstance(key, List__Set__string):
            return False
        cdef vector[cset[string]] ckey = deref((<List__Set__string>key)._cpp_obj)
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, List__Set__string):
                key = List__Set__string(key)
        except Exception:
            return default
        if not isinstance(key, List__Set__string):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef cmap[vector[cset[string]],string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[vector[cset[string]]] ckey
        cdef string citem
        cdef cmap[vector[cset[string]],string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = reference_shared_ptr_Map__List__Set__string_string_key(self._cpp_obj, deref(loc).first)
            citem = deref(loc).second
            yield (List__Set__string.create(ckey), bytes(citem).decode('UTF-8'))
            inc(loc)

    def __reduce__(self):
        return (Map__List__Set__string_string, (dict(self), ))


Mapping.register(Map__List__Set__string_string)

cdef class Map__Set__List__i32_Map__List__Set__string_string:
    def __init__(self, items=None):
        if isinstance(items, Map__Set__List__i32_Map__List__Set__string_string):
            self._cpp_obj = (<Map__Set__List__i32_Map__List__Set__string_string> items)._cpp_obj
        else:
            self._cpp_obj = Map__Set__List__i32_Map__List__Set__string_string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]] c_items):
        inst = <Map__Set__List__i32_Map__List__Set__string_string>Map__Set__List__i32_Map__List__Set__string_string.__new__(Map__Set__List__i32_Map__List__Set__string_string)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__Set__List__i32_Map__List__Set__string_string self):
        cdef shared_ptr[cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]] cpp_obj = make_shared[cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]](
            deref(self._cpp_obj)
        )
        return Map__Set__List__i32_Map__List__Set__string_string.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]] c_inst = make_shared[cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]]]()
        if items is not None:
            for key, item in items.items():
                if key is None:
                    raise TypeError("None is not of type _typing.AbstractSet[_typing.Sequence[int]]")
                if not isinstance(key, Set__List__i32):
                    key = Set__List__i32(key)
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]")
                if not isinstance(item, Map__List__Set__string_string):
                    item = Map__List__Set__string_string(item)

                deref(c_inst)[deref((<Set__List__i32>key)._cpp_obj)] = deref((<Map__List__Set__string_string>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        try:
            if not isinstance(key, Set__List__i32):
                key = Set__List__i32(key)
        except Exception:
            raise err from None
        if not isinstance(key, Set__List__i32):
            raise err from None
        cdef cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]].iterator iter = deref(
            self._cpp_obj).find(deref((<Set__List__i32>key)._cpp_obj))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[cmap[vector[cset[string]],string]] citem = reference_shared_ptr_Map__Set__List__i32_Map__List__Set__string_string(self._cpp_obj, deref(iter).second)
        return Map__List__Set__string_string.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[cset[vector[int32_t]]] citem
        cdef cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__Set__List__i32_Map__List__Set__string_string_key(self._cpp_obj, deref(loc).first)
            yield Set__List__i32.create(citem)
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        try:
            if not isinstance(key, Set__List__i32):
                key = Set__List__i32(key)
        except Exception:
            return False
        if not isinstance(key, Set__List__i32):
            return False
        cdef cset[vector[int32_t]] ckey = deref((<Set__List__i32>key)._cpp_obj)
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        try:
            if not isinstance(key, Set__List__i32):
                key = Set__List__i32(key)
        except Exception:
            return default
        if not isinstance(key, Set__List__i32):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[cmap[vector[cset[string]],string]] citem
        cdef cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__Set__List__i32_Map__List__Set__string_string(self._cpp_obj, deref(loc).second)
            yield Map__List__Set__string_string.create(citem)
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[cset[vector[int32_t]]] ckey
        cdef shared_ptr[cmap[vector[cset[string]],string]] citem
        cdef cmap[cset[vector[int32_t]],cmap[vector[cset[string]],string]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = reference_shared_ptr_Map__Set__List__i32_Map__List__Set__string_string_key(self._cpp_obj, deref(loc).first)
            citem = reference_shared_ptr_Map__Set__List__i32_Map__List__Set__string_string(self._cpp_obj, deref(loc).second)
            yield (Set__List__i32.create(ckey), Map__List__Set__string_string.create(citem))
            inc(loc)

    def __reduce__(self):
        return (Map__Set__List__i32_Map__List__Set__string_string, (dict(self), ))


Mapping.register(Map__Set__List__i32_Map__List__Set__string_string)

cdef class List__Foo__i64:
    def __init__(self, items=None):
        if isinstance(items, List__Foo__i64):
            self._cpp_obj = (<List__Foo__i64> items)._cpp_obj
        else:
            self._cpp_obj = List__Foo__i64._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[Foo]] c_items):
        inst = <List__Foo__i64>List__Foo__i64.__new__(List__Foo__i64)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__Foo__i64 self):
        cdef shared_ptr[vector[Foo]] cpp_obj = make_shared[vector[Foo]](
            deref(self._cpp_obj)
        )
        return List__Foo__i64.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[Foo]] _make_instance(object items) except *:
        cdef shared_ptr[vector[Foo]] c_inst = make_shared[vector[Foo]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int64_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[Foo]] c_inst
        cdef Foo citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[Foo]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Foo__i64.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[vector[Foo].iterator, Foo](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef Foo citem
        cdef vector[Foo].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef Foo citem
        cdef vector[Foo].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef vector[Foo].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef vector[Foo].iterator loc = std_libcpp.find[vector[Foo].iterator, Foo](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <int64_t> std_libcpp.count[vector[Foo].iterator, Foo](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    def __reduce__(self):
        return (List__Foo__i64, (list(self), ))


Sequence.register(List__Foo__i64)

cdef class List__Bar__double:
    def __init__(self, items=None):
        if isinstance(items, List__Bar__double):
            self._cpp_obj = (<List__Bar__double> items)._cpp_obj
        else:
            self._cpp_obj = List__Bar__double._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[Bar]] c_items):
        inst = <List__Bar__double>List__Bar__double.__new__(List__Bar__double)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__Bar__double self):
        cdef shared_ptr[vector[Bar]] cpp_obj = make_shared[vector[Bar]](
            deref(self._cpp_obj)
        )
        return List__Bar__double.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[Bar]] _make_instance(object items) except *:
        cdef shared_ptr[vector[Bar]] c_inst = make_shared[vector[Bar]]()
        if items is not None:
            for item in items:
                if not isinstance(item, (float, int)):
                    raise TypeError(f"{item!r} is not of type float")
                deref(c_inst).push_back(item)
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[Bar]] c_inst
        cdef Bar citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[Bar]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Bar__double.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, float):
            return False
        return std_libcpp.find[vector[Bar].iterator, Bar](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef Bar citem
        cdef vector[Bar].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef Bar citem
        cdef vector[Bar].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, float):
            raise err
        cdef vector[Bar].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef vector[Bar].iterator loc = std_libcpp.find[vector[Bar].iterator, Bar](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, float):
            return 0
        return <int64_t> std_libcpp.count[vector[Bar].iterator, Bar](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    def __reduce__(self):
        return (List__Bar__double, (list(self), ))


Sequence.register(List__Bar__double)

cdef class List__Baz__i32:
    def __init__(self, items=None):
        if isinstance(items, List__Baz__i32):
            self._cpp_obj = (<List__Baz__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__Baz__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[Baz]] c_items):
        inst = <List__Baz__i32>List__Baz__i32.__new__(List__Baz__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__Baz__i32 self):
        cdef shared_ptr[vector[Baz]] cpp_obj = make_shared[vector[Baz]](
            deref(self._cpp_obj)
        )
        return List__Baz__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[Baz]] _make_instance(object items) except *:
        cdef shared_ptr[vector[Baz]] c_inst = make_shared[vector[Baz]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[Baz]] c_inst
        cdef Baz citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[Baz]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Baz__i32.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[vector[Baz].iterator, Baz](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef Baz citem
        cdef vector[Baz].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef Baz citem
        cdef vector[Baz].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef vector[Baz].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef vector[Baz].iterator loc = std_libcpp.find[vector[Baz].iterator, Baz](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <int64_t> std_libcpp.count[vector[Baz].iterator, Baz](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    def __reduce__(self):
        return (List__Baz__i32, (list(self), ))


Sequence.register(List__Baz__i32)

IndirectionA = int
IndirectionC = int
IndirectionB = float
