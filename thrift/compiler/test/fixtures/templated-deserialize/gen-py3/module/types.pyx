#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
cimport cython as __cython
from cpython.bytes cimport PyBytes_AsStringAndSize
from cpython.object cimport PyTypeObject, Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT, Py_GE
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from libcpp.utility cimport move as cmove
from cpython cimport bool as pbool
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types cimport (
    cSetOp as __cSetOp,
    richcmp as __richcmp,
    set_op as __set_op,
    setcmp as __setcmp,
    list_index as __list_index,
    list_count as __list_count,
    list_slice as __list_slice,
    list_getitem as __list_getitem,
    set_iter as __set_iter,
    map_iter as __map_iter,
    map_contains as __map_contains,
    map_getitem as __map_getitem,
    reference_shared_ptr as __reference_shared_ptr,
    translate_cpp_enum_to_python,
    SetMetaClass as __SetMetaClass,
    const_pointer_cast,
    constant_shared_ptr,
    default_inst,
    NOTSET as __NOTSET,
    EnumData as __EnumData,
    EnumFlagsData as __EnumFlagsData,
    UnionTypeEnumData as __UnionTypeEnumData,
    createEnumDataForUnionType as __createEnumDataForUnionType,
)
cimport thrift.py3.std_libcpp as std_libcpp
cimport thrift.py3.serializer as serializer
import folly.iobuf as __iobuf
from folly.optional cimport cOptional
from folly.memory cimport to_shared_ptr as __to_shared_ptr

import sys
from collections.abc import Sequence, Set, Mapping, Iterable
import weakref as __weakref
import builtins as _builtins

cimport module.types_reflection as _types_reflection


cdef __EnumData __MyEnumA_enum_data  = __EnumData.create(thrift.py3.types.createEnumData[cMyEnumA](), MyEnumA)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __MyEnumAMeta(thrift.py3.types.EnumMeta):

    def __get_by_name(cls, str name):
        return __MyEnumA_enum_data.get_by_name(name)

    def __get_by_value(cls, int value):
        return __MyEnumA_enum_data.get_by_value(value)

    def __get_all_names(cls):
        return __MyEnumA_enum_data.get_all_names()

    def __len__(cls):
        return __MyEnumA_enum_data.size()


@__cython.final
@__cython.auto_pickle(False)
cdef class MyEnumA(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __MyEnumA_enum_data.get_by_name(name)



__SetMetaClass(<PyTypeObject*> MyEnumA, <PyTypeObject*> __MyEnumAMeta)



@__cython.auto_pickle(False)
cdef class SmallStruct(thrift.py3.types.Struct):

    def __init__(
        SmallStruct self, *,
        pbool small_A=None,
        small_B=None
    ):
        if small_B is not None:
            if not isinstance(small_B, int):
                raise TypeError(f'small_B is not a { int !r}.')
            small_B = <cint32_t> small_B

        self._cpp_obj = __to_shared_ptr(cmove(SmallStruct._make_instance(
          NULL,
          NULL,
          small_A,
          small_B,
        )))

    def __call__(
        SmallStruct self,
        small_A=__NOTSET,
        small_B=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[2] __isNOTSET  # so make_instance is typed

        __fbthrift_changed = False
        if small_A is ___NOTSET:
            __isNOTSET[0] = True
            small_A = None
        else:
            __isNOTSET[0] = False
            __fbthrift_changed = True

        if small_B is ___NOTSET:
            __isNOTSET[1] = True
            small_B = None
        else:
            __isNOTSET[1] = False
            __fbthrift_changed = True


        if not __fbthrift_changed:
            return self

        if small_A is not None:
            if not isinstance(small_A, bool):
                raise TypeError(f'small_A is not a { bool !r}.')

        if small_B is not None:
            if not isinstance(small_B, int):
                raise TypeError(f'small_B is not a { int !r}.')
            small_B = <cint32_t> small_B

        __fbthrift_inst = <SmallStruct>SmallStruct.__new__(SmallStruct)
        __fbthrift_inst._cpp_obj = __to_shared_ptr(cmove(SmallStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          small_A,
          small_B,
        )))
        return __fbthrift_inst

    @staticmethod
    cdef unique_ptr[cSmallStruct] _make_instance(
        cSmallStruct* base_instance,
        bint* __isNOTSET,
        pbool small_A ,
        object small_B 
    ) except *:
        cdef unique_ptr[cSmallStruct] c_inst
        if base_instance:
            c_inst = make_unique[cSmallStruct](deref(base_instance))
        else:
            c_inst = make_unique[cSmallStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and small_A is None:
                deref(c_inst).small_A_ref().assign(default_inst[cSmallStruct]().small_A_ref().value())
                deref(c_inst).__isset.small_A = False
                pass

            if not __isNOTSET[1] and small_B is None:
                deref(c_inst).small_B_ref().assign(default_inst[cSmallStruct]().small_B_ref().value())
                deref(c_inst).__isset.small_B = False
                pass

        if small_A is not None:
            deref(c_inst).small_A_ref().assign(small_A)
            deref(c_inst).__isset.small_A = True
        if small_B is not None:
            deref(c_inst).small_B_ref().assign(small_B)
            deref(c_inst).__isset.small_B = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return cmove(c_inst)

    cdef object __fbthrift_isset(self):
        return thrift.py3.types._IsSet("SmallStruct", {
          "small_A": deref(self._cpp_obj).small_A_ref().has_value(),
          "small_B": deref(self._cpp_obj).small_B_ref().has_value(),
        })

    def __iter__(self):
        yield 'small_A', self.small_A
        yield 'small_B', self.small_B

    @staticmethod
    cdef create(shared_ptr[cSmallStruct] cpp_obj):
        __fbthrift_inst = <SmallStruct>SmallStruct.__new__(SmallStruct)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def small_A(self):

        return <pbool> deref(self._cpp_obj).small_A_ref().value()

    @property
    def small_B(self):

        return deref(self._cpp_obj).small_B_ref().value()


    def __hash__(SmallStruct self):
        return  super().__hash__()

    def __copy__(SmallStruct self):
        cdef shared_ptr[cSmallStruct] cpp_obj = make_shared[cSmallStruct](
            deref(self._cpp_obj)
        )
        return SmallStruct.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self.__cmp_sametype(other, op)
        return __richcmp[cSmallStruct](
            self._cpp_obj,
            (<SmallStruct>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__SmallStruct()

    cdef __iobuf.IOBuf _serialize(SmallStruct self, __Protocol proto):
        cdef unique_ptr[__iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cSmallStruct](self._cpp_obj.get(), proto))
        return __iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(SmallStruct self, const __iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cSmallStruct]()
        with nogil:
            needed = serializer.cdeserialize[cSmallStruct](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class containerStruct(thrift.py3.types.Struct):

    def __init__(
        containerStruct self, *,
        pbool fieldA=None,
        fieldB=None,
        fieldC=None,
        str fieldD=None,
        str fieldE=None,
        fieldF=None,
        fieldG=None,
        fieldH=None,
        pbool fieldI=None,
        fieldJ=None,
        fieldK=None,
        fieldL=None,
        fieldM=None,
        fieldN=None,
        fieldO=None,
        fieldP=None,
        MyEnumA fieldQ=None,
        fieldR=None,
        SmallStruct fieldS=None,
        SmallStruct fieldT=None,
        SmallStruct fieldU=None,
        SmallStruct fieldX=None
    ):
        self._cpp_obj = __to_shared_ptr(cmove(containerStruct._make_instance(
          NULL,
          NULL,
          fieldA,
          fieldB,
          fieldC,
          fieldD,
          fieldE,
          fieldF,
          fieldG,
          fieldH,
          fieldI,
          fieldJ,
          fieldK,
          fieldL,
          fieldM,
          fieldN,
          fieldO,
          fieldP,
          fieldQ,
          fieldR,
          fieldS,
          fieldT,
          fieldU,
          fieldX,
        )))

    def __call__(
        containerStruct self,
        fieldA=__NOTSET,
        fieldB=__NOTSET,
        fieldC=__NOTSET,
        fieldD=__NOTSET,
        fieldE=__NOTSET,
        fieldF=__NOTSET,
        fieldG=__NOTSET,
        fieldH=__NOTSET,
        fieldI=__NOTSET,
        fieldJ=__NOTSET,
        fieldK=__NOTSET,
        fieldL=__NOTSET,
        fieldM=__NOTSET,
        fieldN=__NOTSET,
        fieldO=__NOTSET,
        fieldP=__NOTSET,
        fieldQ=__NOTSET,
        fieldR=__NOTSET,
        fieldS=__NOTSET,
        fieldT=__NOTSET,
        fieldU=__NOTSET,
        fieldX=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[22] __isNOTSET  # so make_instance is typed

        __fbthrift_changed = False
        if fieldA is ___NOTSET:
            __isNOTSET[0] = True
            fieldA = None
        else:
            __isNOTSET[0] = False
            __fbthrift_changed = True

        if fieldB is ___NOTSET:
            __isNOTSET[1] = True
            fieldB = None
        else:
            __isNOTSET[1] = False
            __fbthrift_changed = True

        if fieldC is ___NOTSET:
            __isNOTSET[2] = True
            fieldC = None
        else:
            __isNOTSET[2] = False
            __fbthrift_changed = True

        if fieldD is ___NOTSET:
            __isNOTSET[3] = True
            fieldD = None
        else:
            __isNOTSET[3] = False
            __fbthrift_changed = True

        if fieldE is ___NOTSET:
            __isNOTSET[4] = True
            fieldE = None
        else:
            __isNOTSET[4] = False
            __fbthrift_changed = True

        if fieldF is ___NOTSET:
            __isNOTSET[5] = True
            fieldF = None
        else:
            __isNOTSET[5] = False
            __fbthrift_changed = True

        if fieldG is ___NOTSET:
            __isNOTSET[6] = True
            fieldG = None
        else:
            __isNOTSET[6] = False
            __fbthrift_changed = True

        if fieldH is ___NOTSET:
            __isNOTSET[7] = True
            fieldH = None
        else:
            __isNOTSET[7] = False
            __fbthrift_changed = True

        if fieldI is ___NOTSET:
            __isNOTSET[8] = True
            fieldI = None
        else:
            __isNOTSET[8] = False
            __fbthrift_changed = True

        if fieldJ is ___NOTSET:
            __isNOTSET[9] = True
            fieldJ = None
        else:
            __isNOTSET[9] = False
            __fbthrift_changed = True

        if fieldK is ___NOTSET:
            __isNOTSET[10] = True
            fieldK = None
        else:
            __isNOTSET[10] = False
            __fbthrift_changed = True

        if fieldL is ___NOTSET:
            __isNOTSET[11] = True
            fieldL = None
        else:
            __isNOTSET[11] = False
            __fbthrift_changed = True

        if fieldM is ___NOTSET:
            __isNOTSET[12] = True
            fieldM = None
        else:
            __isNOTSET[12] = False
            __fbthrift_changed = True

        if fieldN is ___NOTSET:
            __isNOTSET[13] = True
            fieldN = None
        else:
            __isNOTSET[13] = False
            __fbthrift_changed = True

        if fieldO is ___NOTSET:
            __isNOTSET[14] = True
            fieldO = None
        else:
            __isNOTSET[14] = False
            __fbthrift_changed = True

        if fieldP is ___NOTSET:
            __isNOTSET[15] = True
            fieldP = None
        else:
            __isNOTSET[15] = False
            __fbthrift_changed = True

        if fieldQ is ___NOTSET:
            __isNOTSET[16] = True
            fieldQ = None
        else:
            __isNOTSET[16] = False
            __fbthrift_changed = True

        if fieldR is ___NOTSET:
            __isNOTSET[17] = True
            fieldR = None
        else:
            __isNOTSET[17] = False
            __fbthrift_changed = True

        if fieldS is ___NOTSET:
            __isNOTSET[18] = True
            fieldS = None
        else:
            __isNOTSET[18] = False
            __fbthrift_changed = True

        if fieldT is ___NOTSET:
            __isNOTSET[19] = True
            fieldT = None
        else:
            __isNOTSET[19] = False
            __fbthrift_changed = True

        if fieldU is ___NOTSET:
            __isNOTSET[20] = True
            fieldU = None
        else:
            __isNOTSET[20] = False
            __fbthrift_changed = True

        if fieldX is ___NOTSET:
            __isNOTSET[21] = True
            fieldX = None
        else:
            __isNOTSET[21] = False
            __fbthrift_changed = True


        if not __fbthrift_changed:
            return self

        if fieldA is not None:
            if not isinstance(fieldA, bool):
                raise TypeError(f'fieldA is not a { bool !r}.')

        if fieldD is not None:
            if not isinstance(fieldD, str):
                raise TypeError(f'fieldD is not a { str !r}.')

        if fieldE is not None:
            if not isinstance(fieldE, str):
                raise TypeError(f'fieldE is not a { str !r}.')

        if fieldI is not None:
            if not isinstance(fieldI, bool):
                raise TypeError(f'fieldI is not a { bool !r}.')

        if fieldQ is not None:
            if not isinstance(fieldQ, MyEnumA):
                raise TypeError(f'field fieldQ value: { fieldQ !r} is not of the enum type { MyEnumA }.')

        if fieldS is not None:
            if not isinstance(fieldS, SmallStruct):
                raise TypeError(f'fieldS is not a { SmallStruct !r}.')

        if fieldT is not None:
            if not isinstance(fieldT, SmallStruct):
                raise TypeError(f'fieldT is not a { SmallStruct !r}.')

        if fieldU is not None:
            if not isinstance(fieldU, SmallStruct):
                raise TypeError(f'fieldU is not a { SmallStruct !r}.')

        if fieldX is not None:
            if not isinstance(fieldX, SmallStruct):
                raise TypeError(f'fieldX is not a { SmallStruct !r}.')

        __fbthrift_inst = <containerStruct>containerStruct.__new__(containerStruct)
        __fbthrift_inst._cpp_obj = __to_shared_ptr(cmove(containerStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          fieldA,
          fieldB,
          fieldC,
          fieldD,
          fieldE,
          fieldF,
          fieldG,
          fieldH,
          fieldI,
          fieldJ,
          fieldK,
          fieldL,
          fieldM,
          fieldN,
          fieldO,
          fieldP,
          fieldQ,
          fieldR,
          fieldS,
          fieldT,
          fieldU,
          fieldX,
        )))
        return __fbthrift_inst

    @staticmethod
    cdef unique_ptr[ccontainerStruct] _make_instance(
        ccontainerStruct* base_instance,
        bint* __isNOTSET,
        pbool fieldA ,
        object fieldB ,
        object fieldC ,
        str fieldD ,
        str fieldE ,
        object fieldF ,
        object fieldG ,
        object fieldH ,
        pbool fieldI ,
        object fieldJ ,
        object fieldK ,
        object fieldL ,
        object fieldM ,
        object fieldN ,
        object fieldO ,
        object fieldP ,
        MyEnumA fieldQ ,
        object fieldR ,
        SmallStruct fieldS ,
        SmallStruct fieldT ,
        SmallStruct fieldU ,
        SmallStruct fieldX 
    ) except *:
        cdef unique_ptr[ccontainerStruct] c_inst
        if base_instance:
            c_inst = make_unique[ccontainerStruct](deref(base_instance))
        else:
            c_inst = make_unique[ccontainerStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and fieldA is None:
                deref(c_inst).fieldA_ref().assign(default_inst[ccontainerStruct]().fieldA_ref().value())
                deref(c_inst).__isset.fieldA = False
                pass

            if not __isNOTSET[1] and fieldB is None:
                deref(c_inst).fieldB_ref().assign(default_inst[ccontainerStruct]().fieldB_ref().value())
                deref(c_inst).__isset.fieldB = False
                pass

            if not __isNOTSET[2] and fieldC is None:
                deref(c_inst).fieldC_ref().assign(default_inst[ccontainerStruct]().fieldC_ref().value())
                deref(c_inst).__isset.fieldC = False
                pass

            if not __isNOTSET[3] and fieldD is None:
                deref(c_inst).fieldD_ref().assign(default_inst[ccontainerStruct]().fieldD_ref().value())
                deref(c_inst).__isset.fieldD = False
                pass

            if not __isNOTSET[4] and fieldE is None:
                deref(c_inst).fieldE_ref().assign(default_inst[ccontainerStruct]().fieldE_ref().value())
                deref(c_inst).__isset.fieldE = False
                pass

            if not __isNOTSET[5] and fieldF is None:
                deref(c_inst).fieldF_ref().assign(default_inst[ccontainerStruct]().fieldF_ref().value())
                deref(c_inst).__isset.fieldF = False
                pass

            if not __isNOTSET[6] and fieldG is None:
                deref(c_inst).fieldG_ref().assign(default_inst[ccontainerStruct]().fieldG_ref().value())
                deref(c_inst).__isset.fieldG = False
                pass

            if not __isNOTSET[7] and fieldH is None:
                deref(c_inst).fieldH_ref().assign(default_inst[ccontainerStruct]().fieldH_ref().value())
                deref(c_inst).__isset.fieldH = False
                pass

            if not __isNOTSET[8] and fieldI is None:
                deref(c_inst).fieldI_ref().assign(default_inst[ccontainerStruct]().fieldI_ref().value())
                deref(c_inst).__isset.fieldI = False
                pass

            if not __isNOTSET[9] and fieldJ is None:
                deref(c_inst).fieldJ_ref().assign(default_inst[ccontainerStruct]().fieldJ_ref().value())
                deref(c_inst).__isset.fieldJ = False
                pass

            if not __isNOTSET[10] and fieldK is None:
                deref(c_inst).fieldK_ref().assign(default_inst[ccontainerStruct]().fieldK_ref().value())
                deref(c_inst).__isset.fieldK = False
                pass

            if not __isNOTSET[11] and fieldL is None:
                deref(c_inst).fieldL_ref().assign(default_inst[ccontainerStruct]().fieldL_ref().value())
                deref(c_inst).__isset.fieldL = False
                pass

            if not __isNOTSET[12] and fieldM is None:
                deref(c_inst).fieldM_ref().assign(default_inst[ccontainerStruct]().fieldM_ref().value())
                deref(c_inst).__isset.fieldM = False
                pass

            if not __isNOTSET[13] and fieldN is None:
                deref(c_inst).fieldN_ref().assign(default_inst[ccontainerStruct]().fieldN_ref().value())
                deref(c_inst).__isset.fieldN = False
                pass

            if not __isNOTSET[14] and fieldO is None:
                deref(c_inst).fieldO_ref().assign(default_inst[ccontainerStruct]().fieldO_ref().value())
                deref(c_inst).__isset.fieldO = False
                pass

            if not __isNOTSET[15] and fieldP is None:
                deref(c_inst).fieldP_ref().assign(default_inst[ccontainerStruct]().fieldP_ref().value())
                deref(c_inst).__isset.fieldP = False
                pass

            if not __isNOTSET[16] and fieldQ is None:
                deref(c_inst).fieldQ_ref().assign(default_inst[ccontainerStruct]().fieldQ_ref().value())
                deref(c_inst).__isset.fieldQ = False
                pass

            if not __isNOTSET[17] and fieldR is None:
                deref(c_inst).fieldR.reset()
                pass

            if not __isNOTSET[18] and fieldS is None:
                deref(c_inst).fieldS.reset()
                pass

            if not __isNOTSET[19] and fieldT is None:
                deref(c_inst).fieldT.reset()
                pass

            if not __isNOTSET[20] and fieldU is None:
                deref(c_inst).fieldU.reset()
                pass

            if not __isNOTSET[21] and fieldX is None:
                deref(c_inst).fieldX.reset()
                pass

        if fieldA is not None:
            deref(c_inst).fieldA_ref().assign(fieldA)
            deref(c_inst).__isset.fieldA = True
        if fieldB is not None:
            deref(c_inst).fieldB_ref().assign(deref(Map__string_bool(fieldB)._cpp_obj))
            deref(c_inst).__isset.fieldB = True
        if fieldC is not None:
            deref(c_inst).fieldC_ref().assign(deref(Set__i32(fieldC)._cpp_obj))
            deref(c_inst).__isset.fieldC = True
        if fieldD is not None:
            deref(c_inst).fieldD_ref().assign(cmove(thrift.py3.types.bytes_to_string(fieldD.encode('utf-8'))))
            deref(c_inst).__isset.fieldD = True
        if fieldE is not None:
            deref(c_inst).fieldE_ref().assign(cmove(thrift.py3.types.bytes_to_string(fieldE.encode('utf-8'))))
            deref(c_inst).__isset.fieldE = True
        if fieldF is not None:
            deref(c_inst).fieldF_ref().assign(deref(List__List__List__i32(fieldF)._cpp_obj))
            deref(c_inst).__isset.fieldF = True
        if fieldG is not None:
            deref(c_inst).fieldG_ref().assign(deref(Map__string_Map__string_Map__string_i32(fieldG)._cpp_obj))
            deref(c_inst).__isset.fieldG = True
        if fieldH is not None:
            deref(c_inst).fieldH_ref().assign(deref(List__Set__i32(fieldH)._cpp_obj))
            deref(c_inst).__isset.fieldH = True
        if fieldI is not None:
            deref(c_inst).fieldI_ref().assign(fieldI)
            deref(c_inst).__isset.fieldI = True
        if fieldJ is not None:
            deref(c_inst).fieldJ_ref().assign(deref(Map__string_List__i32(fieldJ)._cpp_obj))
            deref(c_inst).__isset.fieldJ = True
        if fieldK is not None:
            deref(c_inst).fieldK_ref().assign(deref(List__List__List__List__i32(fieldK)._cpp_obj))
            deref(c_inst).__isset.fieldK = True
        if fieldL is not None:
            deref(c_inst).fieldL_ref().assign(deref(Set__Set__Set__bool(fieldL)._cpp_obj))
            deref(c_inst).__isset.fieldL = True
        if fieldM is not None:
            deref(c_inst).fieldM_ref().assign(deref(Map__Set__List__i32_Map__List__Set__string_string(fieldM)._cpp_obj))
            deref(c_inst).__isset.fieldM = True
        if fieldN is not None:
            deref(c_inst).fieldN_ref().assign(deref(List__Foo__i64(fieldN)._cpp_obj))
            deref(c_inst).__isset.fieldN = True
        if fieldO is not None:
            deref(c_inst).fieldO_ref().assign(deref(List__Bar__double(fieldO)._cpp_obj))
            deref(c_inst).__isset.fieldO = True
        if fieldP is not None:
            deref(c_inst).fieldP_ref().assign(deref(List__Baz__i32(fieldP)._cpp_obj))
            deref(c_inst).__isset.fieldP = True
        if fieldQ is not None:
            deref(c_inst).fieldQ_ref().assign(<cMyEnumA><int>fieldQ)
            deref(c_inst).__isset.fieldQ = True
        if fieldR is not None:
            deref(c_inst).fieldR = make_unique[cmap[string,cbool]](deref(Map__string_bool(fieldR)._cpp_obj))
        if fieldS is not None:
            deref(c_inst).fieldS = make_unique[cSmallStruct](deref((<SmallStruct?>fieldS)._cpp_obj))
        if fieldT is not None:
            deref(c_inst).fieldT = (<SmallStruct?>fieldT)._cpp_obj
        if fieldU is not None:
            deref(c_inst).fieldU = const_pointer_cast((<SmallStruct?>fieldU)._cpp_obj)
        if fieldX is not None:
            deref(c_inst).fieldX = make_unique[cSmallStruct](deref((<SmallStruct?>fieldX)._cpp_obj))
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return cmove(c_inst)

    cdef object __fbthrift_isset(self):
        return thrift.py3.types._IsSet("containerStruct", {
          "fieldA": deref(self._cpp_obj).fieldA_ref().has_value(),
          "fieldB": deref(self._cpp_obj).fieldB_ref().has_value(),
          "fieldC": deref(self._cpp_obj).fieldC_ref().has_value(),
          "fieldD": deref(self._cpp_obj).fieldD_ref().has_value(),
          "fieldE": deref(self._cpp_obj).fieldE_ref().has_value(),
          "fieldF": deref(self._cpp_obj).fieldF_ref().has_value(),
          "fieldG": deref(self._cpp_obj).fieldG_ref().has_value(),
          "fieldH": deref(self._cpp_obj).fieldH_ref().has_value(),
          "fieldI": deref(self._cpp_obj).fieldI_ref().has_value(),
          "fieldJ": deref(self._cpp_obj).fieldJ_ref().has_value(),
          "fieldK": deref(self._cpp_obj).fieldK_ref().has_value(),
          "fieldL": deref(self._cpp_obj).fieldL_ref().has_value(),
          "fieldM": deref(self._cpp_obj).fieldM_ref().has_value(),
          "fieldN": deref(self._cpp_obj).fieldN_ref().has_value(),
          "fieldO": deref(self._cpp_obj).fieldO_ref().has_value(),
          "fieldP": deref(self._cpp_obj).fieldP_ref().has_value(),
          "fieldQ": deref(self._cpp_obj).fieldQ_ref().has_value(),
        })

    def __iter__(self):
        yield 'fieldA', self.fieldA
        yield 'fieldB', self.fieldB
        yield 'fieldC', self.fieldC
        yield 'fieldD', self.fieldD
        yield 'fieldE', self.fieldE
        yield 'fieldF', self.fieldF
        yield 'fieldG', self.fieldG
        yield 'fieldH', self.fieldH
        yield 'fieldI', self.fieldI
        yield 'fieldJ', self.fieldJ
        yield 'fieldK', self.fieldK
        yield 'fieldL', self.fieldL
        yield 'fieldM', self.fieldM
        yield 'fieldN', self.fieldN
        yield 'fieldO', self.fieldO
        yield 'fieldP', self.fieldP
        yield 'fieldQ', self.fieldQ
        yield 'fieldR', self.fieldR
        yield 'fieldS', self.fieldS
        yield 'fieldT', self.fieldT
        yield 'fieldU', self.fieldU
        yield 'fieldX', self.fieldX

    @staticmethod
    cdef create(shared_ptr[ccontainerStruct] cpp_obj):
        __fbthrift_inst = <containerStruct>containerStruct.__new__(containerStruct)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def fieldA(self):

        return <pbool> deref(self._cpp_obj).fieldA_ref().value()

    @property
    def fieldB(self):

        if self.__field_fieldB is None:
            self.__field_fieldB = Map__string_bool.create(__reference_shared_ptr(deref(self._cpp_obj).fieldB_ref().ref(), self._cpp_obj))
        return self.__field_fieldB

    @property
    def fieldC(self):

        if self.__field_fieldC is None:
            self.__field_fieldC = Set__i32.create(__reference_shared_ptr(deref(self._cpp_obj).fieldC_ref().ref(), self._cpp_obj))
        return self.__field_fieldC

    @property
    def fieldD(self):

        return (<bytes>deref(self._cpp_obj).fieldD_ref().value()).decode('UTF-8')

    @property
    def fieldE(self):

        return (<bytes>deref(self._cpp_obj).fieldE_ref().value()).decode('UTF-8')

    @property
    def fieldF(self):

        if self.__field_fieldF is None:
            self.__field_fieldF = List__List__List__i32.create(__reference_shared_ptr(deref(self._cpp_obj).fieldF_ref().ref(), self._cpp_obj))
        return self.__field_fieldF

    @property
    def fieldG(self):

        if self.__field_fieldG is None:
            self.__field_fieldG = Map__string_Map__string_Map__string_i32.create(__reference_shared_ptr(deref(self._cpp_obj).fieldG_ref().ref(), self._cpp_obj))
        return self.__field_fieldG

    @property
    def fieldH(self):

        if self.__field_fieldH is None:
            self.__field_fieldH = List__Set__i32.create(__reference_shared_ptr(deref(self._cpp_obj).fieldH_ref().ref(), self._cpp_obj))
        return self.__field_fieldH

    @property
    def fieldI(self):

        return <pbool> deref(self._cpp_obj).fieldI_ref().value()

    @property
    def fieldJ(self):

        if self.__field_fieldJ is None:
            self.__field_fieldJ = Map__string_List__i32.create(__reference_shared_ptr(deref(self._cpp_obj).fieldJ_ref().ref(), self._cpp_obj))
        return self.__field_fieldJ

    @property
    def fieldK(self):

        if self.__field_fieldK is None:
            self.__field_fieldK = List__List__List__List__i32.create(__reference_shared_ptr(deref(self._cpp_obj).fieldK_ref().ref(), self._cpp_obj))
        return self.__field_fieldK

    @property
    def fieldL(self):

        if self.__field_fieldL is None:
            self.__field_fieldL = Set__Set__Set__bool.create(__reference_shared_ptr(deref(self._cpp_obj).fieldL_ref().ref(), self._cpp_obj))
        return self.__field_fieldL

    @property
    def fieldM(self):

        if self.__field_fieldM is None:
            self.__field_fieldM = Map__Set__List__i32_Map__List__Set__string_string.create(__reference_shared_ptr(deref(self._cpp_obj).fieldM_ref().ref(), self._cpp_obj))
        return self.__field_fieldM

    @property
    def fieldN(self):

        if self.__field_fieldN is None:
            self.__field_fieldN = List__Foo__i64.create(__reference_shared_ptr(deref(self._cpp_obj).fieldN_ref().ref(), self._cpp_obj))
        return self.__field_fieldN

    @property
    def fieldO(self):

        if self.__field_fieldO is None:
            self.__field_fieldO = List__Bar__double.create(__reference_shared_ptr(deref(self._cpp_obj).fieldO_ref().ref(), self._cpp_obj))
        return self.__field_fieldO

    @property
    def fieldP(self):

        if self.__field_fieldP is None:
            self.__field_fieldP = List__Baz__i32.create(__reference_shared_ptr(deref(self._cpp_obj).fieldP_ref().ref(), self._cpp_obj))
        return self.__field_fieldP

    @property
    def fieldQ(self):

        return translate_cpp_enum_to_python(MyEnumA, <int>(deref(self._cpp_obj).fieldQ_ref().value()))

    @property
    def fieldR(self):

        if self.__field_fieldR is None:
            if not deref(self._cpp_obj).fieldR:
                return None
            self.__field_fieldR = Map__string_bool.create(__reference_shared_ptr(deref(deref(self._cpp_obj).fieldR), self._cpp_obj))
        return self.__field_fieldR

    @property
    def fieldS(self):

        if self.__field_fieldS is None:
            if not deref(self._cpp_obj).fieldS:
                return None
            self.__field_fieldS = SmallStruct.create(__reference_shared_ptr(deref(deref(self._cpp_obj).fieldS), self._cpp_obj))
        return self.__field_fieldS

    @property
    def fieldT(self):

        if self.__field_fieldT is None:
            if not deref(self._cpp_obj).fieldT:
                return None
            self.__field_fieldT = SmallStruct.create(__reference_shared_ptr(deref(deref(self._cpp_obj).fieldT), self._cpp_obj))
        return self.__field_fieldT

    @property
    def fieldU(self):

        if self.__field_fieldU is None:
            if not deref(self._cpp_obj).fieldU:
                return None
            self.__field_fieldU = SmallStruct.create(__reference_shared_ptr(deref(deref(self._cpp_obj).fieldU), self._cpp_obj))
        return self.__field_fieldU

    @property
    def fieldX(self):

        if self.__field_fieldX is None:
            if not deref(self._cpp_obj).fieldX:
                return None
            self.__field_fieldX = SmallStruct.create(__reference_shared_ptr(deref(deref(self._cpp_obj).fieldX), self._cpp_obj))
        return self.__field_fieldX


    def __hash__(containerStruct self):
        return  super().__hash__()

    def __copy__(containerStruct self):
        cdef shared_ptr[ccontainerStruct] cpp_obj = make_shared[ccontainerStruct](
            deref(self._cpp_obj)
        )
        return containerStruct.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self.__cmp_sametype(other, op)
        return __richcmp[ccontainerStruct](
            self._cpp_obj,
            (<containerStruct>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__containerStruct()

    cdef __iobuf.IOBuf _serialize(containerStruct self, __Protocol proto):
        cdef unique_ptr[__iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[ccontainerStruct](self._cpp_obj.get(), proto))
        return __iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(containerStruct self, const __iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[ccontainerStruct]()
        with nogil:
            needed = serializer.cdeserialize[ccontainerStruct](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class Map__string_bool(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_bool):
            self._cpp_obj = (<Map__string_bool> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_bool._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cbool]] c_items):
        __fbthrift_inst = <Map__string_bool>Map__string_bool.__new__(Map__string_bool)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_bool self):
        cdef shared_ptr[cmap[string,cbool]] cpp_obj = make_shared[cmap[string,cbool]](
            deref(self._cpp_obj)
        )
        return Map__string_bool.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,cbool]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cbool]] c_inst = make_shared[cmap[string,cbool]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, bool):
                    raise TypeError(f"{item!r} is not of type bool")

                deref(c_inst)[key.encode('UTF-8')] = item
        return c_inst

    cdef _check_key_type(self, key):
        if not self or key is None:
            return
        if isinstance(key, str):
            return key

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        key = self._check_key_type(key)
        if key is None:
            raise err
        cdef string ckey = key.encode('UTF-8')
        if not __map_contains(self._cpp_obj, ckey):
            raise err
        cdef cbool citem
        __map_getitem(self._cpp_obj, ckey, citem)
        return citem

    def __iter__(self):
        if not self:
            return
        cdef __map_iter[cmap[string,cbool]] itr = __map_iter[cmap[string,cbool]](self._cpp_obj)
        cdef string citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextKey(self._cpp_obj, citem)
            yield bytes(citem).decode('UTF-8')

    def __contains__(self, key):
        key = self._check_key_type(key)
        if key is None:
            return False
        cdef string ckey = key.encode('UTF-8')
        return __map_contains(self._cpp_obj, ckey)

    def values(self):
        if not self:
            return
        cdef __map_iter[cmap[string,cbool]] itr = __map_iter[cmap[string,cbool]](self._cpp_obj)
        cdef cbool citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextValue(self._cpp_obj, citem)
            yield citem

    def items(self):
        if not self:
            return
        cdef __map_iter[cmap[string,cbool]] itr = __map_iter[cmap[string,cbool]](self._cpp_obj)
        cdef string ckey
        cdef cbool citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextItem(self._cpp_obj, ckey, citem)
            yield (ckey.data().decode('UTF-8'), citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_bool()


Mapping.register(Map__string_bool)

@__cython.auto_pickle(False)
cdef class Set__i32(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._cpp_obj = (<Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[cint32_t]] c_items):
        __fbthrift_inst = <Set__i32>Set__i32.__new__(Set__i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Set__i32 self):
        cdef shared_ptr[cset[cint32_t]] cpp_obj = make_shared[cset[cint32_t]](
            deref(self._cpp_obj)
        )
        return Set__i32.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[cset[cint32_t]] c_inst = make_shared[cset[cint32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item
                deref(c_inst).insert(item)
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __iter__(self):
        if not self:
            return
        cdef __set_iter[cset[cint32_t]] itr = __set_iter[cset[cint32_t]](self._cpp_obj)
        cdef cint32_t citem = 0
        for i in range(deref(self._cpp_obj).size()):
            itr.genNext(self._cpp_obj, citem)
            yield citem

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, int op):
        if isinstance(other, Set__i32):
            # C level comparisons
            return __setcmp(
                self._cpp_obj,
                (<Set__i32> other)._cpp_obj,
                op,
            )
        return self.__py_richcmp(other, op)

    cdef __do_set_op(self, other, __cSetOp op):
        if not isinstance(other, Set__i32):
            other = Set__i32(other)
        cdef shared_ptr[cset[cint32_t]] result
        return Set__i32.create(__set_op[cset[cint32_t]](
            self._cpp_obj,
            (<Set__i32>other)._cpp_obj,
            op,
        ))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__i32()


Set.register(Set__i32)

@__cython.auto_pickle(False)
cdef class List__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cint32_t]] c_items):
        __fbthrift_inst = <List__i32>List__i32.__new__(List__i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__i32 self):
        cdef shared_ptr[vector[cint32_t]] cpp_obj = make_shared[vector[cint32_t]](
            deref(self._cpp_obj)
        )
        return List__i32.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cint32_t]] c_inst = make_shared[vector[cint32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item
                deref(c_inst).push_back(item)
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__i32.create(
            __list_slice[vector[cint32_t]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef cint32_t citem = 0
        __list_getitem(self._cpp_obj, index, citem)
        return citem

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, int):
            return item

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef cint32_t citem = item
        cdef std_libcpp.optional[size_t] found = __list_index[vector[cint32_t]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef cint32_t citem = item
        return __list_count[vector[cint32_t]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__i32()


Sequence.register(List__i32)

@__cython.auto_pickle(False)
cdef class List__List__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__List__i32):
            self._cpp_obj = (<List__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[vector[cint32_t]]] c_items):
        __fbthrift_inst = <List__List__i32>List__List__i32.__new__(List__List__i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__List__i32 self):
        cdef shared_ptr[vector[vector[cint32_t]]] cpp_obj = make_shared[vector[vector[cint32_t]]](
            deref(self._cpp_obj)
        )
        return List__List__i32.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[vector[cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[vector[cint32_t]]] c_inst = make_shared[vector[vector[cint32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[int]")
                if not isinstance(item, List__i32):
                    item = List__i32(item)
                deref(c_inst).push_back(deref((<List__i32>item)._cpp_obj))
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__List__i32.create(
            __list_slice[vector[vector[cint32_t]]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef shared_ptr[vector[cint32_t]] citem
        __list_getitem(self._cpp_obj, index, citem)
        return List__i32.create(citem)

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, List__i32):
            return item
        try:
            return List__i32(item)
        except:
            pass

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef vector[cint32_t] citem = deref((<List__i32>item)._cpp_obj)
        cdef std_libcpp.optional[size_t] found = __list_index[vector[vector[cint32_t]]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef vector[cint32_t] citem = deref((<List__i32>item)._cpp_obj)
        return __list_count[vector[vector[cint32_t]]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__List__i32()


Sequence.register(List__List__i32)

@__cython.auto_pickle(False)
cdef class List__List__List__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__List__List__i32):
            self._cpp_obj = (<List__List__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__List__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[vector[vector[cint32_t]]]] c_items):
        __fbthrift_inst = <List__List__List__i32>List__List__List__i32.__new__(List__List__List__i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__List__List__i32 self):
        cdef shared_ptr[vector[vector[vector[cint32_t]]]] cpp_obj = make_shared[vector[vector[vector[cint32_t]]]](
            deref(self._cpp_obj)
        )
        return List__List__List__i32.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[vector[vector[cint32_t]]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[vector[vector[cint32_t]]]] c_inst = make_shared[vector[vector[vector[cint32_t]]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[_typing.Sequence[int]]")
                if not isinstance(item, List__List__i32):
                    item = List__List__i32(item)
                deref(c_inst).push_back(deref((<List__List__i32>item)._cpp_obj))
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__List__List__i32.create(
            __list_slice[vector[vector[vector[cint32_t]]]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef shared_ptr[vector[vector[cint32_t]]] citem
        __list_getitem(self._cpp_obj, index, citem)
        return List__List__i32.create(citem)

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, List__List__i32):
            return item
        try:
            return List__List__i32(item)
        except:
            pass

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef vector[vector[cint32_t]] citem = deref((<List__List__i32>item)._cpp_obj)
        cdef std_libcpp.optional[size_t] found = __list_index[vector[vector[vector[cint32_t]]]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef vector[vector[cint32_t]] citem = deref((<List__List__i32>item)._cpp_obj)
        return __list_count[vector[vector[vector[cint32_t]]]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__List__List__i32()


Sequence.register(List__List__List__i32)

@__cython.auto_pickle(False)
cdef class Map__string_i32(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_i32):
            self._cpp_obj = (<Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cint32_t]] c_items):
        __fbthrift_inst = <Map__string_i32>Map__string_i32.__new__(Map__string_i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_i32 self):
        cdef shared_ptr[cmap[string,cint32_t]] cpp_obj = make_shared[cmap[string,cint32_t]](
            deref(self._cpp_obj)
        )
        return Map__string_i32.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cint32_t]] c_inst = make_shared[cmap[string,cint32_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item

                deref(c_inst)[key.encode('UTF-8')] = item
        return c_inst

    cdef _check_key_type(self, key):
        if not self or key is None:
            return
        if isinstance(key, str):
            return key

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        key = self._check_key_type(key)
        if key is None:
            raise err
        cdef string ckey = key.encode('UTF-8')
        if not __map_contains(self._cpp_obj, ckey):
            raise err
        cdef cint32_t citem = 0
        __map_getitem(self._cpp_obj, ckey, citem)
        return citem

    def __iter__(self):
        if not self:
            return
        cdef __map_iter[cmap[string,cint32_t]] itr = __map_iter[cmap[string,cint32_t]](self._cpp_obj)
        cdef string citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextKey(self._cpp_obj, citem)
            yield bytes(citem).decode('UTF-8')

    def __contains__(self, key):
        key = self._check_key_type(key)
        if key is None:
            return False
        cdef string ckey = key.encode('UTF-8')
        return __map_contains(self._cpp_obj, ckey)

    def values(self):
        if not self:
            return
        cdef __map_iter[cmap[string,cint32_t]] itr = __map_iter[cmap[string,cint32_t]](self._cpp_obj)
        cdef cint32_t citem = 0
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextValue(self._cpp_obj, citem)
            yield citem

    def items(self):
        if not self:
            return
        cdef __map_iter[cmap[string,cint32_t]] itr = __map_iter[cmap[string,cint32_t]](self._cpp_obj)
        cdef string ckey
        cdef cint32_t citem = 0
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextItem(self._cpp_obj, ckey, citem)
            yield (ckey.data().decode('UTF-8'), citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_i32()


Mapping.register(Map__string_i32)

@__cython.auto_pickle(False)
cdef class Map__string_Map__string_i32(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_Map__string_i32):
            self._cpp_obj = (<Map__string_Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_Map__string_i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cmap[string,cint32_t]]] c_items):
        __fbthrift_inst = <Map__string_Map__string_i32>Map__string_Map__string_i32.__new__(Map__string_Map__string_i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_Map__string_i32 self):
        cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] cpp_obj = make_shared[cmap[string,cmap[string,cint32_t]]](
            deref(self._cpp_obj)
        )
        return Map__string_Map__string_i32.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] c_inst = make_shared[cmap[string,cmap[string,cint32_t]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[str, int]")
                if not isinstance(item, Map__string_i32):
                    item = Map__string_i32(item)

                deref(c_inst)[key.encode('UTF-8')] = deref((<Map__string_i32>item)._cpp_obj)
        return c_inst

    cdef _check_key_type(self, key):
        if not self or key is None:
            return
        if isinstance(key, str):
            return key

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        key = self._check_key_type(key)
        if key is None:
            raise err
        cdef string ckey = key.encode('UTF-8')
        if not __map_contains(self._cpp_obj, ckey):
            raise err
        cdef shared_ptr[cmap[string,cint32_t]] citem
        __map_getitem(self._cpp_obj, ckey, citem)
        return Map__string_i32.create(citem)

    def __iter__(self):
        if not self:
            return
        cdef __map_iter[cmap[string,cmap[string,cint32_t]]] itr = __map_iter[cmap[string,cmap[string,cint32_t]]](self._cpp_obj)
        cdef string citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextKey(self._cpp_obj, citem)
            yield bytes(citem).decode('UTF-8')

    def __contains__(self, key):
        key = self._check_key_type(key)
        if key is None:
            return False
        cdef string ckey = key.encode('UTF-8')
        return __map_contains(self._cpp_obj, ckey)

    def values(self):
        if not self:
            return
        cdef __map_iter[cmap[string,cmap[string,cint32_t]]] itr = __map_iter[cmap[string,cmap[string,cint32_t]]](self._cpp_obj)
        cdef shared_ptr[cmap[string,cint32_t]] citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextValue(self._cpp_obj, citem)
            yield Map__string_i32.create(citem)

    def items(self):
        if not self:
            return
        cdef __map_iter[cmap[string,cmap[string,cint32_t]]] itr = __map_iter[cmap[string,cmap[string,cint32_t]]](self._cpp_obj)
        cdef string ckey
        cdef shared_ptr[cmap[string,cint32_t]] citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextItem(self._cpp_obj, ckey, citem)
            yield (ckey.data().decode('UTF-8'), Map__string_i32.create(citem))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_Map__string_i32()


Mapping.register(Map__string_Map__string_i32)

@__cython.auto_pickle(False)
cdef class Map__string_Map__string_Map__string_i32(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_Map__string_Map__string_i32):
            self._cpp_obj = (<Map__string_Map__string_Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_Map__string_Map__string_i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cmap[string,cmap[string,cint32_t]]]] c_items):
        __fbthrift_inst = <Map__string_Map__string_Map__string_i32>Map__string_Map__string_Map__string_i32.__new__(Map__string_Map__string_Map__string_i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_Map__string_Map__string_i32 self):
        cdef shared_ptr[cmap[string,cmap[string,cmap[string,cint32_t]]]] cpp_obj = make_shared[cmap[string,cmap[string,cmap[string,cint32_t]]]](
            deref(self._cpp_obj)
        )
        return Map__string_Map__string_Map__string_i32.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,cmap[string,cmap[string,cint32_t]]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cmap[string,cmap[string,cint32_t]]]] c_inst = make_shared[cmap[string,cmap[string,cmap[string,cint32_t]]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[str, _typing.Mapping[str, int]]")
                if not isinstance(item, Map__string_Map__string_i32):
                    item = Map__string_Map__string_i32(item)

                deref(c_inst)[key.encode('UTF-8')] = deref((<Map__string_Map__string_i32>item)._cpp_obj)
        return c_inst

    cdef _check_key_type(self, key):
        if not self or key is None:
            return
        if isinstance(key, str):
            return key

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        key = self._check_key_type(key)
        if key is None:
            raise err
        cdef string ckey = key.encode('UTF-8')
        if not __map_contains(self._cpp_obj, ckey):
            raise err
        cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] citem
        __map_getitem(self._cpp_obj, ckey, citem)
        return Map__string_Map__string_i32.create(citem)

    def __iter__(self):
        if not self:
            return
        cdef __map_iter[cmap[string,cmap[string,cmap[string,cint32_t]]]] itr = __map_iter[cmap[string,cmap[string,cmap[string,cint32_t]]]](self._cpp_obj)
        cdef string citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextKey(self._cpp_obj, citem)
            yield bytes(citem).decode('UTF-8')

    def __contains__(self, key):
        key = self._check_key_type(key)
        if key is None:
            return False
        cdef string ckey = key.encode('UTF-8')
        return __map_contains(self._cpp_obj, ckey)

    def values(self):
        if not self:
            return
        cdef __map_iter[cmap[string,cmap[string,cmap[string,cint32_t]]]] itr = __map_iter[cmap[string,cmap[string,cmap[string,cint32_t]]]](self._cpp_obj)
        cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextValue(self._cpp_obj, citem)
            yield Map__string_Map__string_i32.create(citem)

    def items(self):
        if not self:
            return
        cdef __map_iter[cmap[string,cmap[string,cmap[string,cint32_t]]]] itr = __map_iter[cmap[string,cmap[string,cmap[string,cint32_t]]]](self._cpp_obj)
        cdef string ckey
        cdef shared_ptr[cmap[string,cmap[string,cint32_t]]] citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextItem(self._cpp_obj, ckey, citem)
            yield (ckey.data().decode('UTF-8'), Map__string_Map__string_i32.create(citem))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_Map__string_Map__string_i32()


Mapping.register(Map__string_Map__string_Map__string_i32)

@__cython.auto_pickle(False)
cdef class List__Set__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__Set__i32):
            self._cpp_obj = (<List__Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cset[cint32_t]]] c_items):
        __fbthrift_inst = <List__Set__i32>List__Set__i32.__new__(List__Set__i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__Set__i32 self):
        cdef shared_ptr[vector[cset[cint32_t]]] cpp_obj = make_shared[vector[cset[cint32_t]]](
            deref(self._cpp_obj)
        )
        return List__Set__i32.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cset[cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cset[cint32_t]]] c_inst = make_shared[vector[cset[cint32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.AbstractSet[int]")
                if not isinstance(item, Set__i32):
                    item = Set__i32(item)
                deref(c_inst).push_back(deref((<Set__i32>item)._cpp_obj))
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__Set__i32.create(
            __list_slice[vector[cset[cint32_t]]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef shared_ptr[cset[cint32_t]] citem
        __list_getitem(self._cpp_obj, index, citem)
        return Set__i32.create(citem)

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, Set__i32):
            return item
        try:
            return Set__i32(item)
        except:
            pass

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef cset[cint32_t] citem = deref((<Set__i32>item)._cpp_obj)
        cdef std_libcpp.optional[size_t] found = __list_index[vector[cset[cint32_t]]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef cset[cint32_t] citem = deref((<Set__i32>item)._cpp_obj)
        return __list_count[vector[cset[cint32_t]]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__Set__i32()


Sequence.register(List__Set__i32)

@__cython.auto_pickle(False)
cdef class Map__string_List__i32(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_List__i32):
            self._cpp_obj = (<Map__string_List__i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,vector[cint32_t]]] c_items):
        __fbthrift_inst = <Map__string_List__i32>Map__string_List__i32.__new__(Map__string_List__i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_List__i32 self):
        cdef shared_ptr[cmap[string,vector[cint32_t]]] cpp_obj = make_shared[cmap[string,vector[cint32_t]]](
            deref(self._cpp_obj)
        )
        return Map__string_List__i32.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,vector[cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,vector[cint32_t]]] c_inst = make_shared[cmap[string,vector[cint32_t]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence[int]")
                if not isinstance(item, List__i32):
                    item = List__i32(item)

                deref(c_inst)[key.encode('UTF-8')] = deref((<List__i32>item)._cpp_obj)
        return c_inst

    cdef _check_key_type(self, key):
        if not self or key is None:
            return
        if isinstance(key, str):
            return key

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        key = self._check_key_type(key)
        if key is None:
            raise err
        cdef string ckey = key.encode('UTF-8')
        if not __map_contains(self._cpp_obj, ckey):
            raise err
        cdef shared_ptr[vector[cint32_t]] citem
        __map_getitem(self._cpp_obj, ckey, citem)
        return List__i32.create(citem)

    def __iter__(self):
        if not self:
            return
        cdef __map_iter[cmap[string,vector[cint32_t]]] itr = __map_iter[cmap[string,vector[cint32_t]]](self._cpp_obj)
        cdef string citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextKey(self._cpp_obj, citem)
            yield bytes(citem).decode('UTF-8')

    def __contains__(self, key):
        key = self._check_key_type(key)
        if key is None:
            return False
        cdef string ckey = key.encode('UTF-8')
        return __map_contains(self._cpp_obj, ckey)

    def values(self):
        if not self:
            return
        cdef __map_iter[cmap[string,vector[cint32_t]]] itr = __map_iter[cmap[string,vector[cint32_t]]](self._cpp_obj)
        cdef shared_ptr[vector[cint32_t]] citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextValue(self._cpp_obj, citem)
            yield List__i32.create(citem)

    def items(self):
        if not self:
            return
        cdef __map_iter[cmap[string,vector[cint32_t]]] itr = __map_iter[cmap[string,vector[cint32_t]]](self._cpp_obj)
        cdef string ckey
        cdef shared_ptr[vector[cint32_t]] citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextItem(self._cpp_obj, ckey, citem)
            yield (ckey.data().decode('UTF-8'), List__i32.create(citem))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_List__i32()


Mapping.register(Map__string_List__i32)

@__cython.auto_pickle(False)
cdef class List__List__List__List__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__List__List__List__i32):
            self._cpp_obj = (<List__List__List__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__List__List__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[vector[vector[vector[cint32_t]]]]] c_items):
        __fbthrift_inst = <List__List__List__List__i32>List__List__List__List__i32.__new__(List__List__List__List__i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__List__List__List__i32 self):
        cdef shared_ptr[vector[vector[vector[vector[cint32_t]]]]] cpp_obj = make_shared[vector[vector[vector[vector[cint32_t]]]]](
            deref(self._cpp_obj)
        )
        return List__List__List__List__i32.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[vector[vector[vector[cint32_t]]]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[vector[vector[vector[cint32_t]]]]] c_inst = make_shared[vector[vector[vector[vector[cint32_t]]]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]")
                if not isinstance(item, List__List__List__i32):
                    item = List__List__List__i32(item)
                deref(c_inst).push_back(deref((<List__List__List__i32>item)._cpp_obj))
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__List__List__List__i32.create(
            __list_slice[vector[vector[vector[vector[cint32_t]]]]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef shared_ptr[vector[vector[vector[cint32_t]]]] citem
        __list_getitem(self._cpp_obj, index, citem)
        return List__List__List__i32.create(citem)

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, List__List__List__i32):
            return item
        try:
            return List__List__List__i32(item)
        except:
            pass

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef vector[vector[vector[cint32_t]]] citem = deref((<List__List__List__i32>item)._cpp_obj)
        cdef std_libcpp.optional[size_t] found = __list_index[vector[vector[vector[vector[cint32_t]]]]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef vector[vector[vector[cint32_t]]] citem = deref((<List__List__List__i32>item)._cpp_obj)
        return __list_count[vector[vector[vector[vector[cint32_t]]]]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__List__List__List__i32()


Sequence.register(List__List__List__List__i32)

@__cython.auto_pickle(False)
cdef class Set__bool(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__bool):
            self._cpp_obj = (<Set__bool> items)._cpp_obj
        else:
            self._cpp_obj = Set__bool._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[cbool]] c_items):
        __fbthrift_inst = <Set__bool>Set__bool.__new__(Set__bool)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Set__bool self):
        cdef shared_ptr[cset[cbool]] cpp_obj = make_shared[cset[cbool]](
            deref(self._cpp_obj)
        )
        return Set__bool.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[cbool]] _make_instance(object items) except *:
        cdef shared_ptr[cset[cbool]] c_inst = make_shared[cset[cbool]]()
        if items is not None:
            for item in items:
                if not isinstance(item, bool):
                    raise TypeError(f"{item!r} is not of type bool")
                deref(c_inst).insert(item)
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, bool):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __iter__(self):
        if not self:
            return
        cdef __set_iter[cset[cbool]] itr = __set_iter[cset[cbool]](self._cpp_obj)
        cdef cbool citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNext(self._cpp_obj, citem)
            yield citem

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, int op):
        if isinstance(other, Set__bool):
            # C level comparisons
            return __setcmp(
                self._cpp_obj,
                (<Set__bool> other)._cpp_obj,
                op,
            )
        return self.__py_richcmp(other, op)

    cdef __do_set_op(self, other, __cSetOp op):
        if not isinstance(other, Set__bool):
            other = Set__bool(other)
        cdef shared_ptr[cset[cbool]] result
        return Set__bool.create(__set_op[cset[cbool]](
            self._cpp_obj,
            (<Set__bool>other)._cpp_obj,
            op,
        ))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__bool()


Set.register(Set__bool)

@__cython.auto_pickle(False)
cdef class Set__Set__bool(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__Set__bool):
            self._cpp_obj = (<Set__Set__bool> items)._cpp_obj
        else:
            self._cpp_obj = Set__Set__bool._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[cset[cbool]]] c_items):
        __fbthrift_inst = <Set__Set__bool>Set__Set__bool.__new__(Set__Set__bool)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Set__Set__bool self):
        cdef shared_ptr[cset[cset[cbool]]] cpp_obj = make_shared[cset[cset[cbool]]](
            deref(self._cpp_obj)
        )
        return Set__Set__bool.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[cset[cbool]]] _make_instance(object items) except *:
        cdef shared_ptr[cset[cset[cbool]]] c_inst = make_shared[cset[cset[cbool]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of type _typing.AbstractSet[bool]")
                if not isinstance(item, Set__bool):
                    item = Set__bool(item)
                deref(c_inst).insert(deref((<Set__bool>item)._cpp_obj))
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__bool):
                item = Set__bool(item)
        except Exception:
            return False
        if not isinstance(item, Set__bool):
            return False
        return pbool(deref(self._cpp_obj).count(deref((<Set__bool>item)._cpp_obj)))


    def __iter__(self):
        if not self:
            return
        cdef __set_iter[cset[cset[cbool]]] itr = __set_iter[cset[cset[cbool]]](self._cpp_obj)
        cdef shared_ptr[cset[cbool]] citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNext(self._cpp_obj, citem)
            yield Set__bool.create(citem)

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, int op):
        if isinstance(other, Set__Set__bool):
            # C level comparisons
            return __setcmp(
                self._cpp_obj,
                (<Set__Set__bool> other)._cpp_obj,
                op,
            )
        return self.__py_richcmp(other, op)

    cdef __do_set_op(self, other, __cSetOp op):
        if not isinstance(other, Set__Set__bool):
            other = Set__Set__bool(other)
        cdef shared_ptr[cset[cset[cbool]]] result
        return Set__Set__bool.create(__set_op[cset[cset[cbool]]](
            self._cpp_obj,
            (<Set__Set__bool>other)._cpp_obj,
            op,
        ))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__Set__bool()


Set.register(Set__Set__bool)

@__cython.auto_pickle(False)
cdef class Set__Set__Set__bool(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__Set__Set__bool):
            self._cpp_obj = (<Set__Set__Set__bool> items)._cpp_obj
        else:
            self._cpp_obj = Set__Set__Set__bool._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[cset[cset[cbool]]]] c_items):
        __fbthrift_inst = <Set__Set__Set__bool>Set__Set__Set__bool.__new__(Set__Set__Set__bool)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Set__Set__Set__bool self):
        cdef shared_ptr[cset[cset[cset[cbool]]]] cpp_obj = make_shared[cset[cset[cset[cbool]]]](
            deref(self._cpp_obj)
        )
        return Set__Set__Set__bool.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[cset[cset[cbool]]]] _make_instance(object items) except *:
        cdef shared_ptr[cset[cset[cset[cbool]]]] c_inst = make_shared[cset[cset[cset[cbool]]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of type _typing.AbstractSet[_typing.AbstractSet[bool]]")
                if not isinstance(item, Set__Set__bool):
                    item = Set__Set__bool(item)
                deref(c_inst).insert(deref((<Set__Set__bool>item)._cpp_obj))
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Set__Set__bool):
                item = Set__Set__bool(item)
        except Exception:
            return False
        if not isinstance(item, Set__Set__bool):
            return False
        return pbool(deref(self._cpp_obj).count(deref((<Set__Set__bool>item)._cpp_obj)))


    def __iter__(self):
        if not self:
            return
        cdef __set_iter[cset[cset[cset[cbool]]]] itr = __set_iter[cset[cset[cset[cbool]]]](self._cpp_obj)
        cdef shared_ptr[cset[cset[cbool]]] citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNext(self._cpp_obj, citem)
            yield Set__Set__bool.create(citem)

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, int op):
        if isinstance(other, Set__Set__Set__bool):
            # C level comparisons
            return __setcmp(
                self._cpp_obj,
                (<Set__Set__Set__bool> other)._cpp_obj,
                op,
            )
        return self.__py_richcmp(other, op)

    cdef __do_set_op(self, other, __cSetOp op):
        if not isinstance(other, Set__Set__Set__bool):
            other = Set__Set__Set__bool(other)
        cdef shared_ptr[cset[cset[cset[cbool]]]] result
        return Set__Set__Set__bool.create(__set_op[cset[cset[cset[cbool]]]](
            self._cpp_obj,
            (<Set__Set__Set__bool>other)._cpp_obj,
            op,
        ))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__Set__Set__bool()


Set.register(Set__Set__Set__bool)

@__cython.auto_pickle(False)
cdef class Set__List__i32(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__List__i32):
            self._cpp_obj = (<Set__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = Set__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[vector[cint32_t]]] c_items):
        __fbthrift_inst = <Set__List__i32>Set__List__i32.__new__(Set__List__i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Set__List__i32 self):
        cdef shared_ptr[cset[vector[cint32_t]]] cpp_obj = make_shared[cset[vector[cint32_t]]](
            deref(self._cpp_obj)
        )
        return Set__List__i32.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[vector[cint32_t]]] _make_instance(object items) except *:
        cdef shared_ptr[cset[vector[cint32_t]]] c_inst = make_shared[cset[vector[cint32_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence[int]")
                if not isinstance(item, List__i32):
                    item = List__i32(item)
                deref(c_inst).insert(deref((<List__i32>item)._cpp_obj))
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, List__i32):
                item = List__i32(item)
        except Exception:
            return False
        if not isinstance(item, List__i32):
            return False
        return pbool(deref(self._cpp_obj).count(deref((<List__i32>item)._cpp_obj)))


    def __iter__(self):
        if not self:
            return
        cdef __set_iter[cset[vector[cint32_t]]] itr = __set_iter[cset[vector[cint32_t]]](self._cpp_obj)
        cdef shared_ptr[vector[cint32_t]] citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNext(self._cpp_obj, citem)
            yield List__i32.create(citem)

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, int op):
        if isinstance(other, Set__List__i32):
            # C level comparisons
            return __setcmp(
                self._cpp_obj,
                (<Set__List__i32> other)._cpp_obj,
                op,
            )
        return self.__py_richcmp(other, op)

    cdef __do_set_op(self, other, __cSetOp op):
        if not isinstance(other, Set__List__i32):
            other = Set__List__i32(other)
        cdef shared_ptr[cset[vector[cint32_t]]] result
        return Set__List__i32.create(__set_op[cset[vector[cint32_t]]](
            self._cpp_obj,
            (<Set__List__i32>other)._cpp_obj,
            op,
        ))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__List__i32()


Set.register(Set__List__i32)

@__cython.auto_pickle(False)
cdef class Set__string(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__string):
            self._cpp_obj = (<Set__string> items)._cpp_obj
        else:
            self._cpp_obj = Set__string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        __fbthrift_inst = <Set__string>Set__string.__new__(Set__string)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Set__string self):
        cdef shared_ptr[cset[string]] cpp_obj = make_shared[cset[string]](
            deref(self._cpp_obj)
        )
        return Set__string.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[string]] _make_instance(object items) except *:
        cdef shared_ptr[cset[string]] c_inst = make_shared[cset[string]]()
        if items is not None:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.AbstractSet[str] field, explicitly convert it first.")
            for item in items:
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")
                deref(c_inst).insert(item.encode('UTF-8'))
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, str):
            return False
        return pbool(deref(self._cpp_obj).count(item.encode('UTF-8')))


    def __iter__(self):
        if not self:
            return
        cdef __set_iter[cset[string]] itr = __set_iter[cset[string]](self._cpp_obj)
        cdef string citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNext(self._cpp_obj, citem)
            yield bytes(citem).decode('UTF-8')

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, int op):
        if isinstance(other, Set__string):
            # C level comparisons
            return __setcmp(
                self._cpp_obj,
                (<Set__string> other)._cpp_obj,
                op,
            )
        return self.__py_richcmp(other, op)

    cdef __do_set_op(self, other, __cSetOp op):
        if not isinstance(other, Set__string):
            other = Set__string(other)
        cdef shared_ptr[cset[string]] result
        return Set__string.create(__set_op[cset[string]](
            self._cpp_obj,
            (<Set__string>other)._cpp_obj,
            op,
        ))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__string()


Set.register(Set__string)

@__cython.auto_pickle(False)
cdef class List__Set__string(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__Set__string):
            self._cpp_obj = (<List__Set__string> items)._cpp_obj
        else:
            self._cpp_obj = List__Set__string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cset[string]]] c_items):
        __fbthrift_inst = <List__Set__string>List__Set__string.__new__(List__Set__string)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__Set__string self):
        cdef shared_ptr[vector[cset[string]]] cpp_obj = make_shared[vector[cset[string]]](
            deref(self._cpp_obj)
        )
        return List__Set__string.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cset[string]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cset[string]]] c_inst = make_shared[vector[cset[string]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.AbstractSet[str]")
                if not isinstance(item, Set__string):
                    item = Set__string(item)
                deref(c_inst).push_back(deref((<Set__string>item)._cpp_obj))
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__Set__string.create(
            __list_slice[vector[cset[string]]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef shared_ptr[cset[string]] citem
        __list_getitem(self._cpp_obj, index, citem)
        return Set__string.create(citem)

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, Set__string):
            return item
        try:
            return Set__string(item)
        except:
            pass

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef cset[string] citem = deref((<Set__string>item)._cpp_obj)
        cdef std_libcpp.optional[size_t] found = __list_index[vector[cset[string]]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef cset[string] citem = deref((<Set__string>item)._cpp_obj)
        return __list_count[vector[cset[string]]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__Set__string()


Sequence.register(List__Set__string)

@__cython.auto_pickle(False)
cdef class Map__List__Set__string_string(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__List__Set__string_string):
            self._cpp_obj = (<Map__List__Set__string_string> items)._cpp_obj
        else:
            self._cpp_obj = Map__List__Set__string_string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[vector[cset[string]],string]] c_items):
        __fbthrift_inst = <Map__List__Set__string_string>Map__List__Set__string_string.__new__(Map__List__Set__string_string)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Map__List__Set__string_string self):
        cdef shared_ptr[cmap[vector[cset[string]],string]] cpp_obj = make_shared[cmap[vector[cset[string]],string]](
            deref(self._cpp_obj)
        )
        return Map__List__Set__string_string.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[vector[cset[string]],string]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[vector[cset[string]],string]] c_inst = make_shared[cmap[vector[cset[string]],string]]()
        if items is not None:
            for key, item in items.items():
                if key is None:
                    raise TypeError("None is not of type _typing.Sequence[_typing.AbstractSet[str]]")
                if not isinstance(key, List__Set__string):
                    key = List__Set__string(key)
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst)[deref((<List__Set__string>key)._cpp_obj)] = item.encode('UTF-8')
        return c_inst

    cdef _check_key_type(self, key):
        if not self or key is None:
            return
        if isinstance(key, List__Set__string):
            return key
        try:
            return List__Set__string(key)
        except:
            pass

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        key = self._check_key_type(key)
        if key is None:
            raise err
        cdef vector[cset[string]] ckey = deref((<List__Set__string>key)._cpp_obj)
        if not __map_contains(self._cpp_obj, ckey):
            raise err
        cdef string citem
        __map_getitem(self._cpp_obj, ckey, citem)
        return bytes(citem).decode('UTF-8')

    def __iter__(self):
        if not self:
            return
        cdef __map_iter[cmap[vector[cset[string]],string]] itr = __map_iter[cmap[vector[cset[string]],string]](self._cpp_obj)
        cdef shared_ptr[vector[cset[string]]] citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextKey(self._cpp_obj, citem)
            yield List__Set__string.create(citem)

    def __contains__(self, key):
        key = self._check_key_type(key)
        if key is None:
            return False
        cdef vector[cset[string]] ckey = deref((<List__Set__string>key)._cpp_obj)
        return __map_contains(self._cpp_obj, ckey)

    def values(self):
        if not self:
            return
        cdef __map_iter[cmap[vector[cset[string]],string]] itr = __map_iter[cmap[vector[cset[string]],string]](self._cpp_obj)
        cdef string citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextValue(self._cpp_obj, citem)
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            return
        cdef __map_iter[cmap[vector[cset[string]],string]] itr = __map_iter[cmap[vector[cset[string]],string]](self._cpp_obj)
        cdef shared_ptr[vector[cset[string]]] ckey
        cdef string citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextItem(self._cpp_obj, ckey, citem)
            yield (List__Set__string.create(ckey), bytes(citem).decode('UTF-8'))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__List__Set__string_string()


Mapping.register(Map__List__Set__string_string)

@__cython.auto_pickle(False)
cdef class Map__Set__List__i32_Map__List__Set__string_string(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__Set__List__i32_Map__List__Set__string_string):
            self._cpp_obj = (<Map__Set__List__i32_Map__List__Set__string_string> items)._cpp_obj
        else:
            self._cpp_obj = Map__Set__List__i32_Map__List__Set__string_string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]] c_items):
        __fbthrift_inst = <Map__Set__List__i32_Map__List__Set__string_string>Map__Set__List__i32_Map__List__Set__string_string.__new__(Map__Set__List__i32_Map__List__Set__string_string)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Map__Set__List__i32_Map__List__Set__string_string self):
        cdef shared_ptr[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]] cpp_obj = make_shared[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]](
            deref(self._cpp_obj)
        )
        return Map__Set__List__i32_Map__List__Set__string_string.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]] c_inst = make_shared[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]]()
        if items is not None:
            for key, item in items.items():
                if key is None:
                    raise TypeError("None is not of type _typing.AbstractSet[_typing.Sequence[int]]")
                if not isinstance(key, Set__List__i32):
                    key = Set__List__i32(key)
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]")
                if not isinstance(item, Map__List__Set__string_string):
                    item = Map__List__Set__string_string(item)

                deref(c_inst)[deref((<Set__List__i32>key)._cpp_obj)] = deref((<Map__List__Set__string_string>item)._cpp_obj)
        return c_inst

    cdef _check_key_type(self, key):
        if not self or key is None:
            return
        if isinstance(key, Set__List__i32):
            return key
        try:
            return Set__List__i32(key)
        except:
            pass

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        key = self._check_key_type(key)
        if key is None:
            raise err
        cdef cset[vector[cint32_t]] ckey = deref((<Set__List__i32>key)._cpp_obj)
        if not __map_contains(self._cpp_obj, ckey):
            raise err
        cdef shared_ptr[cmap[vector[cset[string]],string]] citem
        __map_getitem(self._cpp_obj, ckey, citem)
        return Map__List__Set__string_string.create(citem)

    def __iter__(self):
        if not self:
            return
        cdef __map_iter[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]] itr = __map_iter[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]](self._cpp_obj)
        cdef shared_ptr[cset[vector[cint32_t]]] citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextKey(self._cpp_obj, citem)
            yield Set__List__i32.create(citem)

    def __contains__(self, key):
        key = self._check_key_type(key)
        if key is None:
            return False
        cdef cset[vector[cint32_t]] ckey = deref((<Set__List__i32>key)._cpp_obj)
        return __map_contains(self._cpp_obj, ckey)

    def values(self):
        if not self:
            return
        cdef __map_iter[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]] itr = __map_iter[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]](self._cpp_obj)
        cdef shared_ptr[cmap[vector[cset[string]],string]] citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextValue(self._cpp_obj, citem)
            yield Map__List__Set__string_string.create(citem)

    def items(self):
        if not self:
            return
        cdef __map_iter[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]] itr = __map_iter[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]](self._cpp_obj)
        cdef shared_ptr[cset[vector[cint32_t]]] ckey
        cdef shared_ptr[cmap[vector[cset[string]],string]] citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextItem(self._cpp_obj, ckey, citem)
            yield (Set__List__i32.create(ckey), Map__List__Set__string_string.create(citem))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__Set__List__i32_Map__List__Set__string_string()


Mapping.register(Map__Set__List__i32_Map__List__Set__string_string)

@__cython.auto_pickle(False)
cdef class List__Foo__i64(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__Foo__i64):
            self._cpp_obj = (<List__Foo__i64> items)._cpp_obj
        else:
            self._cpp_obj = List__Foo__i64._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[Foo]] c_items):
        __fbthrift_inst = <List__Foo__i64>List__Foo__i64.__new__(List__Foo__i64)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__Foo__i64 self):
        cdef shared_ptr[vector[Foo]] cpp_obj = make_shared[vector[Foo]](
            deref(self._cpp_obj)
        )
        return List__Foo__i64.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[Foo]] _make_instance(object items) except *:
        cdef shared_ptr[vector[Foo]] c_inst = make_shared[vector[Foo]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint64_t> item
                deref(c_inst).push_back(item)
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__Foo__i64.create(
            __list_slice[vector[Foo]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef Foo citem = 0
        __list_getitem(self._cpp_obj, index, citem)
        return citem

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, int):
            return item

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef Foo citem = item
        cdef std_libcpp.optional[size_t] found = __list_index[vector[Foo]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef Foo citem = item
        return __list_count[vector[Foo]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__Foo__i64()


Sequence.register(List__Foo__i64)

@__cython.auto_pickle(False)
cdef class List__Bar__double(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__Bar__double):
            self._cpp_obj = (<List__Bar__double> items)._cpp_obj
        else:
            self._cpp_obj = List__Bar__double._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[Bar]] c_items):
        __fbthrift_inst = <List__Bar__double>List__Bar__double.__new__(List__Bar__double)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__Bar__double self):
        cdef shared_ptr[vector[Bar]] cpp_obj = make_shared[vector[Bar]](
            deref(self._cpp_obj)
        )
        return List__Bar__double.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[Bar]] _make_instance(object items) except *:
        cdef shared_ptr[vector[Bar]] c_inst = make_shared[vector[Bar]]()
        if items is not None:
            for item in items:
                if not isinstance(item, (float, int)):
                    raise TypeError(f"{item!r} is not of type float")
                deref(c_inst).push_back(item)
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__Bar__double.create(
            __list_slice[vector[Bar]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef Bar citem = 0
        __list_getitem(self._cpp_obj, index, citem)
        return citem

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, float):
            return item

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef Bar citem = item
        cdef std_libcpp.optional[size_t] found = __list_index[vector[Bar]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef Bar citem = item
        return __list_count[vector[Bar]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__Bar__double()


Sequence.register(List__Bar__double)

@__cython.auto_pickle(False)
cdef class List__Baz__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__Baz__i32):
            self._cpp_obj = (<List__Baz__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__Baz__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[Baz]] c_items):
        __fbthrift_inst = <List__Baz__i32>List__Baz__i32.__new__(List__Baz__i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__Baz__i32 self):
        cdef shared_ptr[vector[Baz]] cpp_obj = make_shared[vector[Baz]](
            deref(self._cpp_obj)
        )
        return List__Baz__i32.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[Baz]] _make_instance(object items) except *:
        cdef shared_ptr[vector[Baz]] c_inst = make_shared[vector[Baz]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item
                deref(c_inst).push_back(item)
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__Baz__i32.create(
            __list_slice[vector[Baz]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef Baz citem = 0
        __list_getitem(self._cpp_obj, index, citem)
        return citem

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, int):
            return item

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef Baz citem = item
        cdef std_libcpp.optional[size_t] found = __list_index[vector[Baz]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef Baz citem = item
        return __list_count[vector[Baz]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__Baz__i32()


Sequence.register(List__Baz__i32)

IndirectionA = int
IndirectionC = int
IndirectionB = float
