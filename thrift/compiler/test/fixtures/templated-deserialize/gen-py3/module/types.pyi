#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

import thrift.py3.types
import thrift.py3.exceptions
from thrift.py3.types import NOTSET
from thrift.py3.serializer import Protocol
import typing as _typing

import sys
import itertools
from enum import Enum


class MyEnumA(Enum):
    fieldA: ...
    fieldB: ...
    fieldC: ...
    value: int


# Forward Definitions for Structs
class SmallStruct(thrift.py3.types.Struct): ...
class containerStruct(thrift.py3.types.Struct): ...
# Forward Definitions for Containers
class Map__string_bool(_typing.Mapping[str, bool]): ...
class Set__i32(_typing.AbstractSet[int]): ...
class List__i32(_typing.Sequence[int]): ...
class List__List__i32(_typing.Sequence[_typing.Sequence[int]]): ...
class List__List__List__i32(_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]): ...
class Map__string_i32(_typing.Mapping[str, int]): ...
class Map__string_Map__string_i32(_typing.Mapping[str, _typing.Mapping[str, int]]): ...
class Map__string_Map__string_Map__string_i32(_typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]): ...
class List__Set__i32(_typing.Sequence[_typing.AbstractSet[int]]): ...
class Map__string_List__i32(_typing.Mapping[str, _typing.Sequence[int]]): ...
class List__List__List__List__i32(_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]): ...
class Set__bool(_typing.AbstractSet[bool]): ...
class Set__Set__bool(_typing.AbstractSet[_typing.AbstractSet[bool]]): ...
class Set__Set__Set__bool(_typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]): ...
class Set__List__i32(_typing.AbstractSet[_typing.Sequence[int]]): ...
class Set__string(_typing.AbstractSet[str]): ...
class List__Set__string(_typing.Sequence[_typing.AbstractSet[str]]): ...
class Map__List__Set__string_string(_typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]): ...
class Map__Set__List__i32_Map__List__Set__string_string(_typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]): ...
class List__i64(_typing.Sequence[int]): ...
class List__double(_typing.Sequence[float]): ...


class SmallStruct(thrift.py3.types.Struct):
    def __init__(
        self, *,
        small_A: bool=None,
        small_B: int=None
    ) -> None: ...

    def __call__(
        self, *,
        small_A: _typing.Union[bool, NOTSET, None]=NOTSET,
        small_B: _typing.Union[int, NOTSET, None]=NOTSET
    ): ...

    def __reduce__(self) -> _typing.Tuple[Callable, _typing.Tuple[_typing.Type[SmallStruct], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: SmallStruct) -> bool: ...
    def __lt__(self, other: SmallStruct) -> bool: ...

    @property
    def small_A(self) -> bool: ...
    @property
    def small_B(self) -> int: ...


class containerStruct(thrift.py3.types.Struct):
    def __init__(
        self, *,
        fieldA: bool=None,
        fieldB: _typing.Mapping[str, bool]=None,
        fieldC: _typing.AbstractSet[int]=None,
        fieldD: str=None,
        fieldE: str=None,
        fieldF: _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]=None,
        fieldG: _typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]=None,
        fieldH: _typing.Sequence[_typing.AbstractSet[int]]=None,
        fieldI: bool=None,
        fieldJ: _typing.Mapping[str, _typing.Sequence[int]]=None,
        fieldK: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]=None,
        fieldL: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]=None,
        fieldM: _typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]=None,
        fieldN: _typing.Sequence[int]=None,
        fieldO: _typing.Sequence[float]=None,
        fieldP: _typing.Sequence[int]=None,
        fieldQ: MyEnumA=None,
        fieldR: _typing.Mapping[str, bool]=None,
        fieldS: SmallStruct=None,
        fieldT: SmallStruct=None,
        fieldU: SmallStruct=None,
        fieldX: SmallStruct=None
    ) -> None: ...

    def __call__(
        self, *,
        fieldA: _typing.Union[bool, NOTSET, None]=NOTSET,
        fieldB: _typing.Union[_typing.Mapping[str, bool], NOTSET, None]=NOTSET,
        fieldC: _typing.Union[_typing.AbstractSet[int], NOTSET, None]=NOTSET,
        fieldD: _typing.Union[str, NOTSET, None]=NOTSET,
        fieldE: _typing.Union[str, NOTSET, None]=NOTSET,
        fieldF: _typing.Union[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]], NOTSET, None]=NOTSET,
        fieldG: _typing.Union[_typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]], NOTSET, None]=NOTSET,
        fieldH: _typing.Union[_typing.Sequence[_typing.AbstractSet[int]], NOTSET, None]=NOTSET,
        fieldI: _typing.Union[bool, NOTSET, None]=NOTSET,
        fieldJ: _typing.Union[_typing.Mapping[str, _typing.Sequence[int]], NOTSET, None]=NOTSET,
        fieldK: _typing.Union[_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]], NOTSET, None]=NOTSET,
        fieldL: _typing.Union[_typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]], NOTSET, None]=NOTSET,
        fieldM: _typing.Union[_typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]], NOTSET, None]=NOTSET,
        fieldN: _typing.Union[_typing.Sequence[int], NOTSET, None]=NOTSET,
        fieldO: _typing.Union[_typing.Sequence[float], NOTSET, None]=NOTSET,
        fieldP: _typing.Union[_typing.Sequence[int], NOTSET, None]=NOTSET,
        fieldQ: _typing.Union[MyEnumA, NOTSET, None]=NOTSET,
        fieldR: _typing.Union[_typing.Mapping[str, bool], NOTSET, None]=NOTSET,
        fieldS: _typing.Union[SmallStruct, NOTSET, None]=NOTSET,
        fieldT: _typing.Union[SmallStruct, NOTSET, None]=NOTSET,
        fieldU: _typing.Union[SmallStruct, NOTSET, None]=NOTSET,
        fieldX: _typing.Union[SmallStruct, NOTSET, None]=NOTSET
    ): ...

    def __reduce__(self) -> _typing.Tuple[Callable, _typing.Tuple[_typing.Type[containerStruct], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: containerStruct) -> bool: ...
    def __lt__(self, other: containerStruct) -> bool: ...

    @property
    def fieldA(self) -> bool: ...
    @property
    def fieldB(self) -> Map__string_bool: ...
    @property
    def fieldC(self) -> Set__i32: ...
    @property
    def fieldD(self) -> str: ...
    @property
    def fieldE(self) -> str: ...
    @property
    def fieldF(self) -> List__List__List__i32: ...
    @property
    def fieldG(self) -> Map__string_Map__string_Map__string_i32: ...
    @property
    def fieldH(self) -> List__Set__i32: ...
    @property
    def fieldI(self) -> bool: ...
    @property
    def fieldJ(self) -> Map__string_List__i32: ...
    @property
    def fieldK(self) -> List__List__List__List__i32: ...
    @property
    def fieldL(self) -> Set__Set__Set__bool: ...
    @property
    def fieldM(self) -> Map__Set__List__i32_Map__List__Set__string_string: ...
    @property
    def fieldN(self) -> List__i64: ...
    @property
    def fieldO(self) -> List__double: ...
    @property
    def fieldP(self) -> List__i32: ...
    @property
    def fieldQ(self) -> MyEnumA: ...
    @property
    def fieldR(self) -> Map__string_bool: ...
    @property
    def fieldS(self) -> SmallStruct: ...
    @property
    def fieldT(self) -> SmallStruct: ...
    @property
    def fieldU(self) -> SmallStruct: ...
    @property
    def fieldX(self) -> SmallStruct: ...


class Map__string_bool(_typing.Mapping[str, bool]):
    def __init__(self, items: _typing.Mapping[str, bool]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[str, bool]) -> bool: ...
    def __getitem__(self, key: str) -> bool: ...
    def __iter__(self) -> _typing.Iterator[str]: ...
    def __contains__(self, key: str) -> bool: ...
    def get(self, key: str, default: bool=None) -> bool: ...
    def keys(self) -> _typing.Iterator[str]: ...
    def values(self) -> _typing.Iterator[bool]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[str, bool]]: ...


class Set__i32(_typing.AbstractSet[int]):
    def __init__(self, items: _typing.AbstractSet[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[int]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[int]) -> bool: ...
    def __contains__(self, item: int) -> bool: ...
    def __iter__(self) -> int): ...
    def __add__(self, other: _typing.AbstractSet[int]) -> Set__i32: ...
    def __or__(self, other: _typing.AbstractSet[int]) -> Set__i32: ...
    def __xor__(self, other: _typing.AbstractSet[int]) -> Set__i32: ...
    def isdisjoint(self, other: _typing.AbstractSet[int]) -> bool: ...
    def union(self, other: _typing.AbstractSet[int]) -> Set__i32: ...
    def intersection(self, other: _typing.AbstractSet[int]) -> Set__i32: ...
    def difference(self, other: _typing.AbstractSet[int]) -> Set__i32: ...
    def symmetric_difference(self, other: _typing.AbstractSet[int]) -> Set__i32: ...
    def issubset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[int]) -> bool: ...


_List__i32T = _typing.TypeVar('_List__i32T', bound=_typing.Sequence[int])


class List__i32(_typing.Sequence[int]):
    def __init__(self, items: _typing.Sequence[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: int) -> int: ...
    def count(self, item: int) -> int: ...
    def __add__(self, other: _typing.Sequence[int]) -> List__i32: ...
    def __radd__(self, other: _List__i32T) -> _List__i32T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__i32: ...
    def __getitem__(self, index: int) -> int: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...
    def __contains__(self, item: int) -> bool: ...
    def __eq__(self, other: _typing.Sequence[int]) -> bool: ...


_List__List__i32T = _typing.TypeVar('_List__List__i32T', bound=_typing.Sequence[_typing.Sequence[int]])


class List__List__i32(_typing.Sequence[_typing.Sequence[int]]):
    def __init__(self, items: _typing.Sequence[_typing.Sequence[int]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: _typing.Sequence[int]) -> int: ...
    def count(self, item: _typing.Sequence[int]) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[int]]) -> List__List__i32: ...
    def __radd__(self, other: _List__List__i32T) -> _List__List__i32T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__List__i32: ...
    def __getitem__(self, index: int) -> _typing.Sequence[int]: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[int]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[int]]: ...
    def __contains__(self, item: _typing.Sequence[int]) -> bool: ...
    def __eq__(self, other: _typing.Sequence[_typing.Sequence[int]]) -> bool: ...


_List__List__List__i32T = _typing.TypeVar('_List__List__List__i32T', bound=_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]])


class List__List__List__i32(_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]):
    def __init__(self, items: _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: _typing.Sequence[_typing.Sequence[int]]) -> int: ...
    def count(self, item: _typing.Sequence[_typing.Sequence[int]]) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]) -> List__List__List__i32: ...
    def __radd__(self, other: _List__List__List__i32T) -> _List__List__List__i32T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__List__List__i32: ...
    def __getitem__(self, index: int) -> _typing.Sequence[_typing.Sequence[int]]: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[int]]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[int]]]: ...
    def __contains__(self, item: _typing.Sequence[_typing.Sequence[int]]) -> bool: ...
    def __eq__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]) -> bool: ...


class Map__string_i32(_typing.Mapping[str, int]):
    def __init__(self, items: _typing.Mapping[str, int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[str, int]) -> bool: ...
    def __getitem__(self, key: str) -> int: ...
    def __iter__(self) -> _typing.Iterator[str]: ...
    def __contains__(self, key: str) -> bool: ...
    def get(self, key: str, default: int=None) -> int: ...
    def keys(self) -> _typing.Iterator[str]: ...
    def values(self) -> _typing.Iterator[int]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[str, int]]: ...


class Map__string_Map__string_i32(_typing.Mapping[str, _typing.Mapping[str, int]]):
    def __init__(self, items: _typing.Mapping[str, _typing.Mapping[str, int]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[str, _typing.Mapping[str, int]]) -> bool: ...
    def __getitem__(self, key: str) -> _typing.Mapping[str, int]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...
    def __contains__(self, key: str) -> bool: ...
    def get(self, key: str, default: _typing.Mapping[str, int]=None) -> _typing.Mapping[str, int]: ...
    def keys(self) -> _typing.Iterator[str]: ...
    def values(self) -> _typing.Iterator[_typing.Mapping[str, int]]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Mapping[str, int]]]: ...


class Map__string_Map__string_Map__string_i32(_typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]):
    def __init__(self, items: _typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]) -> bool: ...
    def __getitem__(self, key: str) -> _typing.Mapping[str, _typing.Mapping[str, int]]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...
    def __contains__(self, key: str) -> bool: ...
    def get(self, key: str, default: _typing.Mapping[str, _typing.Mapping[str, int]]=None) -> _typing.Mapping[str, _typing.Mapping[str, int]]: ...
    def keys(self) -> _typing.Iterator[str]: ...
    def values(self) -> _typing.Iterator[_typing.Mapping[str, _typing.Mapping[str, int]]]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Mapping[str, _typing.Mapping[str, int]]]]: ...


_List__Set__i32T = _typing.TypeVar('_List__Set__i32T', bound=_typing.Sequence[_typing.AbstractSet[int]])


class List__Set__i32(_typing.Sequence[_typing.AbstractSet[int]]):
    def __init__(self, items: _typing.Sequence[_typing.AbstractSet[int]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: _typing.AbstractSet[int]) -> int: ...
    def count(self, item: _typing.AbstractSet[int]) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.AbstractSet[int]]) -> List__Set__i32: ...
    def __radd__(self, other: _List__Set__i32T) -> _List__Set__i32T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__Set__i32: ...
    def __getitem__(self, index: int) -> _typing.AbstractSet[int]: ...
    def __reversed__(self) -> _typing.Iterator[_typing.AbstractSet[int]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[int]]: ...
    def __contains__(self, item: _typing.AbstractSet[int]) -> bool: ...
    def __eq__(self, other: _typing.Sequence[_typing.AbstractSet[int]]) -> bool: ...


class Map__string_List__i32(_typing.Mapping[str, _typing.Sequence[int]]):
    def __init__(self, items: _typing.Mapping[str, _typing.Sequence[int]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[str, _typing.Sequence[int]]) -> bool: ...
    def __getitem__(self, key: str) -> _typing.Sequence[int]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...
    def __contains__(self, key: str) -> bool: ...
    def get(self, key: str, default: _typing.Sequence[int]=None) -> _typing.Sequence[int]: ...
    def keys(self) -> _typing.Iterator[str]: ...
    def values(self) -> _typing.Iterator[_typing.Sequence[int]]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Sequence[int]]]: ...


_List__List__List__List__i32T = _typing.TypeVar('_List__List__List__List__i32T', bound=_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]])


class List__List__List__List__i32(_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]):
    def __init__(self, items: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]) -> int: ...
    def count(self, item: _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]) -> List__List__List__List__i32: ...
    def __radd__(self, other: _List__List__List__List__i32T) -> _List__List__List__List__i32T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__List__List__List__i32: ...
    def __getitem__(self, index: int) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]: ...
    def __contains__(self, item: _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]) -> bool: ...
    def __eq__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]) -> bool: ...


class Set__bool(_typing.AbstractSet[bool]):
    def __init__(self, items: _typing.AbstractSet[bool]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[bool]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[bool]) -> bool: ...
    def __contains__(self, item: bool) -> bool: ...
    def __iter__(self) -> bool): ...
    def __add__(self, other: _typing.AbstractSet[bool]) -> Set__bool: ...
    def __or__(self, other: _typing.AbstractSet[bool]) -> Set__bool: ...
    def __xor__(self, other: _typing.AbstractSet[bool]) -> Set__bool: ...
    def isdisjoint(self, other: _typing.AbstractSet[bool]) -> bool: ...
    def union(self, other: _typing.AbstractSet[bool]) -> Set__bool: ...
    def intersection(self, other: _typing.AbstractSet[bool]) -> Set__bool: ...
    def difference(self, other: _typing.AbstractSet[bool]) -> Set__bool: ...
    def symmetric_difference(self, other: _typing.AbstractSet[bool]) -> Set__bool: ...
    def issubset(self, other: _typing.AbstractSet[bool]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[bool]) -> bool: ...


class Set__Set__bool(_typing.AbstractSet[_typing.AbstractSet[bool]]):
    def __init__(self, items: _typing.AbstractSet[_typing.AbstractSet[bool]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> bool: ...
    def __contains__(self, item: _typing.AbstractSet[bool]) -> bool: ...
    def __iter__(self) -> _typing.AbstractSet[bool]): ...
    def __add__(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> Set__Set__bool: ...
    def __or__(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> Set__Set__bool: ...
    def __xor__(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> Set__Set__bool: ...
    def isdisjoint(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> Set__Set__bool: ...
    def intersection(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> Set__Set__bool: ...
    def difference(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> Set__Set__bool: ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> Set__Set__bool: ...
    def issubset(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> bool: ...


class Set__Set__Set__bool(_typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]):
    def __init__(self, items: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> bool: ...
    def __contains__(self, item: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> bool: ...
    def __iter__(self) -> _typing.AbstractSet[_typing.AbstractSet[bool]]): ...
    def __add__(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> Set__Set__Set__bool: ...
    def __or__(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> Set__Set__Set__bool: ...
    def __xor__(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> Set__Set__Set__bool: ...
    def isdisjoint(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> Set__Set__Set__bool: ...
    def intersection(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> Set__Set__Set__bool: ...
    def difference(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> Set__Set__Set__bool: ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> Set__Set__Set__bool: ...
    def issubset(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> bool: ...


class Set__List__i32(_typing.AbstractSet[_typing.Sequence[int]]):
    def __init__(self, items: _typing.AbstractSet[_typing.Sequence[int]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> bool: ...
    def __contains__(self, item: _typing.Sequence[int]) -> bool: ...
    def __iter__(self) -> _typing.Sequence[int]): ...
    def __add__(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> Set__List__i32: ...
    def __or__(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> Set__List__i32: ...
    def __xor__(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> Set__List__i32: ...
    def isdisjoint(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> Set__List__i32: ...
    def intersection(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> Set__List__i32: ...
    def difference(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> Set__List__i32: ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> Set__List__i32: ...
    def issubset(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> bool: ...


class Set__string(_typing.AbstractSet[str]):
    def __init__(self, items: _typing.AbstractSet[str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[str]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[str]) -> bool: ...
    def __contains__(self, item: str) -> bool: ...
    def __iter__(self) -> str): ...
    def __add__(self, other: _typing.AbstractSet[str]) -> Set__string: ...
    def __or__(self, other: _typing.AbstractSet[str]) -> Set__string: ...
    def __xor__(self, other: _typing.AbstractSet[str]) -> Set__string: ...
    def isdisjoint(self, other: _typing.AbstractSet[str]) -> bool: ...
    def union(self, other: _typing.AbstractSet[str]) -> Set__string: ...
    def intersection(self, other: _typing.AbstractSet[str]) -> Set__string: ...
    def difference(self, other: _typing.AbstractSet[str]) -> Set__string: ...
    def symmetric_difference(self, other: _typing.AbstractSet[str]) -> Set__string: ...
    def issubset(self, other: _typing.AbstractSet[str]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[str]) -> bool: ...


_List__Set__stringT = _typing.TypeVar('_List__Set__stringT', bound=_typing.Sequence[_typing.AbstractSet[str]])


class List__Set__string(_typing.Sequence[_typing.AbstractSet[str]]):
    def __init__(self, items: _typing.Sequence[_typing.AbstractSet[str]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: _typing.AbstractSet[str]) -> int: ...
    def count(self, item: _typing.AbstractSet[str]) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.AbstractSet[str]]) -> List__Set__string: ...
    def __radd__(self, other: _List__Set__stringT) -> _List__Set__stringT: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__Set__string: ...
    def __getitem__(self, index: int) -> _typing.AbstractSet[str]: ...
    def __reversed__(self) -> _typing.Iterator[_typing.AbstractSet[str]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[str]]: ...
    def __contains__(self, item: _typing.AbstractSet[str]) -> bool: ...
    def __eq__(self, other: _typing.Sequence[_typing.AbstractSet[str]]) -> bool: ...


class Map__List__Set__string_string(_typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]):
    def __init__(self, items: _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]) -> bool: ...
    def __getitem__(self, key: _typing.Sequence[_typing.AbstractSet[str]]) -> str: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.AbstractSet[str]]]: ...
    def __contains__(self, key: _typing.Sequence[_typing.AbstractSet[str]]) -> bool: ...
    def get(self, key: _typing.Sequence[_typing.AbstractSet[str]], default: str=None) -> str: ...
    def keys(self) -> _typing.Iterator[_typing.Sequence[_typing.AbstractSet[str]]]: ...
    def values(self) -> _typing.Iterator[str]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[_typing.Sequence[_typing.AbstractSet[str]], str]]: ...


class Map__Set__List__i32_Map__List__Set__string_string(_typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]):
    def __init__(self, items: _typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]) -> bool: ...
    def __getitem__(self, key: _typing.AbstractSet[_typing.Sequence[int]]) -> _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]: ...
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[_typing.Sequence[int]]]: ...
    def __contains__(self, key: _typing.AbstractSet[_typing.Sequence[int]]) -> bool: ...
    def get(self, key: _typing.AbstractSet[_typing.Sequence[int]], default: _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]=None) -> _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]: ...
    def keys(self) -> _typing.Iterator[_typing.AbstractSet[_typing.Sequence[int]]]: ...
    def values(self) -> _typing.Iterator[_typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]]: ...


_List__i64T = _typing.TypeVar('_List__i64T', bound=_typing.Sequence[int])


class List__i64(_typing.Sequence[int]):
    def __init__(self, items: _typing.Sequence[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: int) -> int: ...
    def count(self, item: int) -> int: ...
    def __add__(self, other: _typing.Sequence[int]) -> List__i64: ...
    def __radd__(self, other: _List__i64T) -> _List__i64T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__i64: ...
    def __getitem__(self, index: int) -> int: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...
    def __contains__(self, item: int) -> bool: ...
    def __eq__(self, other: _typing.Sequence[int]) -> bool: ...


_List__doubleT = _typing.TypeVar('_List__doubleT', bound=_typing.Sequence[float])


class List__double(_typing.Sequence[float]):
    def __init__(self, items: _typing.Sequence[float]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: float) -> int: ...
    def count(self, item: float) -> int: ...
    def __add__(self, other: _typing.Sequence[float]) -> List__double: ...
    def __radd__(self, other: _List__doubleT) -> _List__doubleT: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__double: ...
    def __getitem__(self, index: int) -> float: ...
    def __reversed__(self) -> _typing.Iterator[float]: ...
    def __iter__(self) -> _typing.Iterator[float]: ...
    def __contains__(self, item: float) -> bool: ...
    def __eq__(self, other: _typing.Sequence[float]) -> bool: ...


