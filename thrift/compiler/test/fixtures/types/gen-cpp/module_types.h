/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp/Thrift.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <thrift/lib/cpp/protocol/TProtocol.h>
#include <thrift/lib/cpp/transport/TTransport.h>

namespace apache { namespace thrift { namespace reflection {
class Schema;
}}}
#include "thrift/compiler/test/fixtures/types/gen-cpp/include_types.h"


namespace apache { namespace thrift { namespace fixtures { namespace types {

enum has_bitwise_ops {
  none = 0,
  zero = 1,
  one = 2,
  two = 4,
  three = 8,
};

using _has_bitwise_ops_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<has_bitwise_ops, int>;

extern const _has_bitwise_ops_EnumMapFactory::ValuesToNamesMapType _has_bitwise_ops_VALUES_TO_NAMES;

extern const _has_bitwise_ops_EnumMapFactory::NamesToValuesMapType _has_bitwise_ops_NAMES_TO_VALUES;

}}}} // namespace
namespace apache { namespace thrift {
template <> struct TEnumDataStorage< ::apache::thrift::fixtures::types::has_bitwise_ops>;
template <> inline constexpr  ::apache::thrift::fixtures::types::has_bitwise_ops TEnumTraits< ::apache::thrift::fixtures::types::has_bitwise_ops>::min() {
return  ::apache::thrift::fixtures::types::has_bitwise_ops::none;
}
template <> inline constexpr  ::apache::thrift::fixtures::types::has_bitwise_ops TEnumTraits< ::apache::thrift::fixtures::types::has_bitwise_ops>::max() {
return  ::apache::thrift::fixtures::types::has_bitwise_ops::three;
}
}} // apache::thrift

namespace apache { namespace thrift { namespace fixtures { namespace types {

enum is_unscoped {
  hello = 0,
  world = 1,
};

using _is_unscoped_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<is_unscoped, int>;

extern const _is_unscoped_EnumMapFactory::ValuesToNamesMapType _is_unscoped_VALUES_TO_NAMES;

extern const _is_unscoped_EnumMapFactory::NamesToValuesMapType _is_unscoped_NAMES_TO_VALUES;

}}}} // namespace
namespace apache { namespace thrift {
template <> struct TEnumDataStorage< ::apache::thrift::fixtures::types::is_unscoped>;
template <> inline constexpr  ::apache::thrift::fixtures::types::is_unscoped TEnumTraits< ::apache::thrift::fixtures::types::is_unscoped>::min() {
return  ::apache::thrift::fixtures::types::is_unscoped::hello;
}
template <> inline constexpr  ::apache::thrift::fixtures::types::is_unscoped TEnumTraits< ::apache::thrift::fixtures::types::is_unscoped>::max() {
return  ::apache::thrift::fixtures::types::is_unscoped::world;
}
}} // apache::thrift

namespace apache { namespace thrift { namespace fixtures { namespace types {

enum MyForwardRefEnum {
  ZERO = 0,
  NONZERO = 12,
};

using _MyForwardRefEnum_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<MyForwardRefEnum, int>;

extern const _MyForwardRefEnum_EnumMapFactory::ValuesToNamesMapType _MyForwardRefEnum_VALUES_TO_NAMES;

extern const _MyForwardRefEnum_EnumMapFactory::NamesToValuesMapType _MyForwardRefEnum_NAMES_TO_VALUES;

}}}} // namespace
namespace apache { namespace thrift {
template <> struct TEnumDataStorage< ::apache::thrift::fixtures::types::MyForwardRefEnum>;
template <> inline constexpr  ::apache::thrift::fixtures::types::MyForwardRefEnum TEnumTraits< ::apache::thrift::fixtures::types::MyForwardRefEnum>::min() {
return  ::apache::thrift::fixtures::types::MyForwardRefEnum::ZERO;
}
template <> inline constexpr  ::apache::thrift::fixtures::types::MyForwardRefEnum TEnumTraits< ::apache::thrift::fixtures::types::MyForwardRefEnum>::max() {
return  ::apache::thrift::fixtures::types::MyForwardRefEnum::NONZERO;
}
}} // apache::thrift

namespace apache { namespace thrift { namespace fixtures { namespace types {

class decorated_struct;

class ContainerStruct;

class VirtualStruct;

class MyStructWithForwardRefEnum;

void swap(decorated_struct &a, decorated_struct &b);

class decorated_struct final : public apache::thrift::TStructType<decorated_struct> {
 public:

  static const uint64_t _reflection_id = 2133116297910176940U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  decorated_struct() {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit decorated_struct(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    decorated_struct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    field = arg.move();
    __isset.field = true;
  }

  decorated_struct(const decorated_struct&) = default;
  decorated_struct& operator=(const decorated_struct& src)= default;
  decorated_struct(decorated_struct&&) = default;
  decorated_struct& operator=(decorated_struct&&) = default;

  void __clear();
  std::string field;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      field = false;
    }
    bool field;
  } __isset;

  bool operator == (const decorated_struct &) const;
  bool operator != (const decorated_struct& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const decorated_struct & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class decorated_struct;
void merge(const decorated_struct& from, decorated_struct& to);
void merge(decorated_struct&& from, decorated_struct& to);
}}}} // namespace

namespace std {
template<> struct hash<typename  ::apache::thrift::fixtures::types::decorated_struct> {
size_t operator()(const  ::apache::thrift::fixtures::types::decorated_struct&) const;
};
template<> struct equal_to<typename  ::apache::thrift::fixtures::types::decorated_struct> {
bool operator()(const  ::apache::thrift::fixtures::types::decorated_struct&, 
const  ::apache::thrift::fixtures::types::decorated_struct&) const;
};
} // namespace

namespace apache { namespace thrift { namespace fixtures { namespace types {

void swap(ContainerStruct &a, ContainerStruct &b);

class ContainerStruct final : public apache::thrift::TStructType<ContainerStruct> {
 public:

  static const uint64_t _reflection_id = 11962737781608441260U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  ContainerStruct() {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit ContainerStruct(
    ::apache::thrift::detail::argument_wrapper<12, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    ContainerStruct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldA = arg.move();
    __isset.fieldA = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit ContainerStruct(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    ContainerStruct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldB = arg.move();
    __isset.fieldB = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit ContainerStruct(
    ::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    ContainerStruct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldC = arg.move();
    __isset.fieldC = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit ContainerStruct(
    ::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    ContainerStruct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldD = arg.move();
    __isset.fieldD = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit ContainerStruct(
    ::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    ContainerStruct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldE = arg.move();
    __isset.fieldE = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit ContainerStruct(
    ::apache::thrift::detail::argument_wrapper<6, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    ContainerStruct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldF = arg.move();
    __isset.fieldF = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit ContainerStruct(
    ::apache::thrift::detail::argument_wrapper<7, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    ContainerStruct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldG = arg.move();
    __isset.fieldG = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit ContainerStruct(
    ::apache::thrift::detail::argument_wrapper<8, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    ContainerStruct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    fieldH = arg.move();
    __isset.fieldH = true;
  }

  ContainerStruct(const ContainerStruct&) = default;
  ContainerStruct& operator=(const ContainerStruct& src)= default;
  ContainerStruct(ContainerStruct&&) = default;
  ContainerStruct& operator=(ContainerStruct&&) = default;

  void __clear();
  std::vector<int32_t>  fieldA;
  std::list<int32_t>  fieldB;
  std::deque<int32_t>  fieldC;
  folly::fbvector<int32_t>  fieldD;
  folly::small_vector<int32_t>  fieldE;
  folly::sorted_vector_set<int32_t>  fieldF;
  folly::sorted_vector_map<int32_t, std::string>  fieldG;
   ::apache::thrift::fixtures::types::SomeMap fieldH;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      fieldA = false;
      fieldB = false;
      fieldC = false;
      fieldD = false;
      fieldE = false;
      fieldF = false;
      fieldG = false;
      fieldH = false;
    }
    bool fieldA;
    bool fieldB;
    bool fieldC;
    bool fieldD;
    bool fieldE;
    bool fieldF;
    bool fieldG;
    bool fieldH;
  } __isset;

  bool operator == (const ContainerStruct &) const;
  bool operator != (const ContainerStruct& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ContainerStruct & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class ContainerStruct;
void merge(const ContainerStruct& from, ContainerStruct& to);
void merge(ContainerStruct&& from, ContainerStruct& to);
void swap(VirtualStruct &a, VirtualStruct &b);

class VirtualStruct : public apache::thrift::TStructType<VirtualStruct> {
 public:

  static const uint64_t _reflection_id = 6433147857901895308U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  VirtualStruct() : MyIntField(0) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit VirtualStruct(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    VirtualStruct(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    MyIntField = arg.move();
    __isset.MyIntField = true;
  }

  VirtualStruct(const VirtualStruct&) = default;
  VirtualStruct& operator=(const VirtualStruct& src)= default;
  VirtualStruct(VirtualStruct&&) = default;
  VirtualStruct& operator=(VirtualStruct&&) = default;

  void __clear();

  virtual ~VirtualStruct() noexcept {}

  int64_t MyIntField;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      MyIntField = false;
    }
    bool MyIntField;
  } __isset;

  bool operator == (const VirtualStruct &) const;
  bool operator != (const VirtualStruct& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VirtualStruct & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class VirtualStruct;
void merge(const VirtualStruct& from, VirtualStruct& to);
void merge(VirtualStruct&& from, VirtualStruct& to);
void swap(MyStructWithForwardRefEnum &a, MyStructWithForwardRefEnum &b);

class MyStructWithForwardRefEnum final : public apache::thrift::TStructType<MyStructWithForwardRefEnum> {
 public:

  static const uint64_t _reflection_id = 4311102400659715084U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MyStructWithForwardRefEnum() : a(MyForwardRefEnum::NONZERO), b(MyForwardRefEnum::NONZERO) {
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyStructWithForwardRefEnum(
    ::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyStructWithForwardRefEnum(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    a = arg.move();
    __isset.a = true;
  }
  template <
    typename T__ThriftWrappedArgument__Ctor,
    typename... Args__ThriftWrappedArgument__Ctor
  >
  explicit MyStructWithForwardRefEnum(
    ::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg,
    Args__ThriftWrappedArgument__Ctor&&... args
  ):
    MyStructWithForwardRefEnum(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    b = arg.move();
    __isset.b = true;
  }

  MyStructWithForwardRefEnum(const MyStructWithForwardRefEnum&) = default;
  MyStructWithForwardRefEnum& operator=(const MyStructWithForwardRefEnum& src)= default;
  MyStructWithForwardRefEnum(MyStructWithForwardRefEnum&&) = default;
  MyStructWithForwardRefEnum& operator=(MyStructWithForwardRefEnum&&) = default;

  void __clear();
  MyForwardRefEnum a;
  MyForwardRefEnum b;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      a = false;
      b = false;
    }
    bool a;
    bool b;
  } __isset;

  bool operator == (const MyStructWithForwardRefEnum &) const;
  bool operator != (const MyStructWithForwardRefEnum& rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MyStructWithForwardRefEnum & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  static void translateFieldName(
      folly::StringPiece _fname,
      int16_t& fid,
      apache::thrift::protocol::TType& _ftype);
};

class MyStructWithForwardRefEnum;
void merge(const MyStructWithForwardRefEnum& from, MyStructWithForwardRefEnum& to);
void merge(MyStructWithForwardRefEnum&& from, MyStructWithForwardRefEnum& to);
}}}} // namespace

