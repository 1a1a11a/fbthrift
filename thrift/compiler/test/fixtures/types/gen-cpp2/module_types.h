/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>


#include "thrift/compiler/test/fixtures/types/gen-cpp2/include_types.h"

namespace apache {
namespace thrift {
namespace tag {
struct field;
struct fieldA;
struct fieldB;
struct fieldC;
struct fieldD;
struct fieldE;
struct fieldF;
struct fieldG;
struct fieldH;
struct fieldA;
struct MyIntField;
struct a;
struct b;
struct a;
struct b;
struct z;
struct n;
struct a;
struct b;
struct z;
struct n;
struct small;
struct big;
struct medium;
struct biggish;
struct tiny;
struct MyIntField;
struct MyStringField;
struct majorVer;
struct data;
struct bar;
struct binary_field;
struct list_field;
struct foo;
struct ForwardUsageStruct;
struct ForwardUsageByRef;
struct foo;
struct boolField;
struct MyBoolField;
struct MyIntField;
struct MyStringField;
struct MyStringField2;
struct MyBinaryField;
struct MyBinaryField2;
struct MyBinaryField3;
struct MyBinaryListField4;
struct MyMapEnumAndInt;
struct string_field;
struct i32_field;
} // namespace tag
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_field
#define APACHE_THRIFT_ACCESSOR_field
APACHE_THRIFT_DEFINE_ACCESSOR(field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldA
#define APACHE_THRIFT_ACCESSOR_fieldA
APACHE_THRIFT_DEFINE_ACCESSOR(fieldA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldB
#define APACHE_THRIFT_ACCESSOR_fieldB
APACHE_THRIFT_DEFINE_ACCESSOR(fieldB);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldC
#define APACHE_THRIFT_ACCESSOR_fieldC
APACHE_THRIFT_DEFINE_ACCESSOR(fieldC);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldD
#define APACHE_THRIFT_ACCESSOR_fieldD
APACHE_THRIFT_DEFINE_ACCESSOR(fieldD);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldE
#define APACHE_THRIFT_ACCESSOR_fieldE
APACHE_THRIFT_DEFINE_ACCESSOR(fieldE);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldF
#define APACHE_THRIFT_ACCESSOR_fieldF
APACHE_THRIFT_DEFINE_ACCESSOR(fieldF);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldG
#define APACHE_THRIFT_ACCESSOR_fieldG
APACHE_THRIFT_DEFINE_ACCESSOR(fieldG);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldH
#define APACHE_THRIFT_ACCESSOR_fieldH
APACHE_THRIFT_DEFINE_ACCESSOR(fieldH);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldA
#define APACHE_THRIFT_ACCESSOR_fieldA
APACHE_THRIFT_DEFINE_ACCESSOR(fieldA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyIntField
#define APACHE_THRIFT_ACCESSOR_MyIntField
APACHE_THRIFT_DEFINE_ACCESSOR(MyIntField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a
#define APACHE_THRIFT_ACCESSOR_a
APACHE_THRIFT_DEFINE_ACCESSOR(a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_b
#define APACHE_THRIFT_ACCESSOR_b
APACHE_THRIFT_DEFINE_ACCESSOR(b);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a
#define APACHE_THRIFT_ACCESSOR_a
APACHE_THRIFT_DEFINE_ACCESSOR(a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_b
#define APACHE_THRIFT_ACCESSOR_b
APACHE_THRIFT_DEFINE_ACCESSOR(b);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_z
#define APACHE_THRIFT_ACCESSOR_z
APACHE_THRIFT_DEFINE_ACCESSOR(z);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_n
#define APACHE_THRIFT_ACCESSOR_n
APACHE_THRIFT_DEFINE_ACCESSOR(n);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a
#define APACHE_THRIFT_ACCESSOR_a
APACHE_THRIFT_DEFINE_ACCESSOR(a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_b
#define APACHE_THRIFT_ACCESSOR_b
APACHE_THRIFT_DEFINE_ACCESSOR(b);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_z
#define APACHE_THRIFT_ACCESSOR_z
APACHE_THRIFT_DEFINE_ACCESSOR(z);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_n
#define APACHE_THRIFT_ACCESSOR_n
APACHE_THRIFT_DEFINE_ACCESSOR(n);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_small
#define APACHE_THRIFT_ACCESSOR_small
APACHE_THRIFT_DEFINE_ACCESSOR(small);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_big
#define APACHE_THRIFT_ACCESSOR_big
APACHE_THRIFT_DEFINE_ACCESSOR(big);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_medium
#define APACHE_THRIFT_ACCESSOR_medium
APACHE_THRIFT_DEFINE_ACCESSOR(medium);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_biggish
#define APACHE_THRIFT_ACCESSOR_biggish
APACHE_THRIFT_DEFINE_ACCESSOR(biggish);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tiny
#define APACHE_THRIFT_ACCESSOR_tiny
APACHE_THRIFT_DEFINE_ACCESSOR(tiny);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyIntField
#define APACHE_THRIFT_ACCESSOR_MyIntField
APACHE_THRIFT_DEFINE_ACCESSOR(MyIntField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyStringField
#define APACHE_THRIFT_ACCESSOR_MyStringField
APACHE_THRIFT_DEFINE_ACCESSOR(MyStringField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_majorVer
#define APACHE_THRIFT_ACCESSOR_majorVer
APACHE_THRIFT_DEFINE_ACCESSOR(majorVer);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_data
#define APACHE_THRIFT_ACCESSOR_data
APACHE_THRIFT_DEFINE_ACCESSOR(data);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_bar
#define APACHE_THRIFT_ACCESSOR_bar
APACHE_THRIFT_DEFINE_ACCESSOR(bar);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_binary_field
#define APACHE_THRIFT_ACCESSOR_binary_field
APACHE_THRIFT_DEFINE_ACCESSOR(binary_field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_list_field
#define APACHE_THRIFT_ACCESSOR_list_field
APACHE_THRIFT_DEFINE_ACCESSOR(list_field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_foo
#define APACHE_THRIFT_ACCESSOR_foo
APACHE_THRIFT_DEFINE_ACCESSOR(foo);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ForwardUsageStruct
#define APACHE_THRIFT_ACCESSOR_ForwardUsageStruct
APACHE_THRIFT_DEFINE_ACCESSOR(ForwardUsageStruct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ForwardUsageByRef
#define APACHE_THRIFT_ACCESSOR_ForwardUsageByRef
APACHE_THRIFT_DEFINE_ACCESSOR(ForwardUsageByRef);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_foo
#define APACHE_THRIFT_ACCESSOR_foo
APACHE_THRIFT_DEFINE_ACCESSOR(foo);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_boolField
#define APACHE_THRIFT_ACCESSOR_boolField
APACHE_THRIFT_DEFINE_ACCESSOR(boolField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBoolField
#define APACHE_THRIFT_ACCESSOR_MyBoolField
APACHE_THRIFT_DEFINE_ACCESSOR(MyBoolField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyIntField
#define APACHE_THRIFT_ACCESSOR_MyIntField
APACHE_THRIFT_DEFINE_ACCESSOR(MyIntField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyStringField
#define APACHE_THRIFT_ACCESSOR_MyStringField
APACHE_THRIFT_DEFINE_ACCESSOR(MyStringField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyStringField2
#define APACHE_THRIFT_ACCESSOR_MyStringField2
APACHE_THRIFT_DEFINE_ACCESSOR(MyStringField2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField
#define APACHE_THRIFT_ACCESSOR_MyBinaryField
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField2
#define APACHE_THRIFT_ACCESSOR_MyBinaryField2
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField3
#define APACHE_THRIFT_ACCESSOR_MyBinaryField3
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryListField4
#define APACHE_THRIFT_ACCESSOR_MyBinaryListField4
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryListField4);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyMapEnumAndInt
#define APACHE_THRIFT_ACCESSOR_MyMapEnumAndInt
APACHE_THRIFT_DEFINE_ACCESSOR(MyMapEnumAndInt);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_string_field
#define APACHE_THRIFT_ACCESSOR_string_field
APACHE_THRIFT_DEFINE_ACCESSOR(string_field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_i32_field
#define APACHE_THRIFT_ACCESSOR_i32_field
APACHE_THRIFT_DEFINE_ACCESSOR(i32_field);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums
namespace apache { namespace thrift { namespace fixtures { namespace types {

enum class has_bitwise_ops {
  none = 0,
  zero = 1,
  one = 2,
  two = 4,
  three = 8
};


inline constexpr has_bitwise_ops operator&(has_bitwise_ops a, has_bitwise_ops b) {
  using E = has_bitwise_ops;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) & static_cast<U>(b));
}
inline constexpr has_bitwise_ops& operator&=(has_bitwise_ops& a, has_bitwise_ops b) {
  return a = a & b;
}

inline constexpr has_bitwise_ops operator|(has_bitwise_ops a, has_bitwise_ops b) {
  using E = has_bitwise_ops;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) | static_cast<U>(b));
}
inline constexpr has_bitwise_ops& operator|=(has_bitwise_ops& a, has_bitwise_ops b) {
  return a = a | b;
}

inline constexpr has_bitwise_ops operator^(has_bitwise_ops a, has_bitwise_ops b) {
  using E = has_bitwise_ops;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) ^ static_cast<U>(b));
}
inline constexpr has_bitwise_ops& operator^=(has_bitwise_ops& a, has_bitwise_ops b) {
  return a = a ^ b;
}

inline constexpr has_bitwise_ops operator~(has_bitwise_ops a) {
  using E = has_bitwise_ops;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(~static_cast<U>(a));
}

enum is_unscoped : int {
  hello = 0,
  world = 1
};




enum class MyForwardRefEnum {
  ZERO = 0,
  NONZERO = 12
};




enum class MyEnumA {
  fieldA = 1,
  fieldB = 2,
  fieldC = 4
};




}}}} // apache::thrift::fixtures::types
namespace std {


template<> struct hash<typename ::apache::thrift::fixtures::types::has_bitwise_ops> : public apache::thrift::detail::enum_hash<typename ::apache::thrift::fixtures::types::has_bitwise_ops> {};
template<> struct equal_to<typename ::apache::thrift::fixtures::types::has_bitwise_ops> : public apache::thrift::detail::enum_equal_to<typename ::apache::thrift::fixtures::types::has_bitwise_ops> {};


template<> struct hash<typename ::apache::thrift::fixtures::types::is_unscoped> : public apache::thrift::detail::enum_hash<typename ::apache::thrift::fixtures::types::is_unscoped> {};
template<> struct equal_to<typename ::apache::thrift::fixtures::types::is_unscoped> : public apache::thrift::detail::enum_equal_to<typename ::apache::thrift::fixtures::types::is_unscoped> {};


template<> struct hash<typename ::apache::thrift::fixtures::types::MyForwardRefEnum> : public apache::thrift::detail::enum_hash<typename ::apache::thrift::fixtures::types::MyForwardRefEnum> {};
template<> struct equal_to<typename ::apache::thrift::fixtures::types::MyForwardRefEnum> : public apache::thrift::detail::enum_equal_to<typename ::apache::thrift::fixtures::types::MyForwardRefEnum> {};


template<> struct hash<typename ::apache::thrift::fixtures::types::MyEnumA> : public apache::thrift::detail::enum_hash<typename ::apache::thrift::fixtures::types::MyEnumA> {};
template<> struct equal_to<typename ::apache::thrift::fixtures::types::MyEnumA> : public apache::thrift::detail::enum_equal_to<typename ::apache::thrift::fixtures::types::MyEnumA> {};


} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage<::apache::thrift::fixtures::types::has_bitwise_ops>;

template <> struct TEnumTraits<::apache::thrift::fixtures::types::has_bitwise_ops> {
  using type = ::apache::thrift::fixtures::types::has_bitwise_ops;

  static constexpr std::size_t const size = 5;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::none; }
  static constexpr type max() { return type::three; }
};


template <> struct TEnumDataStorage<::apache::thrift::fixtures::types::is_unscoped>;

template <> struct TEnumTraits<::apache::thrift::fixtures::types::is_unscoped> {
  using type = ::apache::thrift::fixtures::types::is_unscoped;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::hello; }
  static constexpr type max() { return type::world; }
};


template <> struct TEnumDataStorage<::apache::thrift::fixtures::types::MyForwardRefEnum>;

template <> struct TEnumTraits<::apache::thrift::fixtures::types::MyForwardRefEnum> {
  using type = ::apache::thrift::fixtures::types::MyForwardRefEnum;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::ZERO; }
  static constexpr type max() { return type::NONZERO; }
};


template <> struct TEnumDataStorage<::apache::thrift::fixtures::types::MyEnumA>;

template <> struct TEnumTraits<::apache::thrift::fixtures::types::MyEnumA> {
  using type = ::apache::thrift::fixtures::types::MyEnumA;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::fieldA; }
  static constexpr type max() { return type::fieldC; }
};


}} // apache::thrift

namespace apache { namespace thrift { namespace fixtures { namespace types {

using _has_bitwise_ops_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<has_bitwise_ops>;
extern const _has_bitwise_ops_EnumMapFactory::ValuesToNamesMapType _has_bitwise_ops_VALUES_TO_NAMES;
extern const _has_bitwise_ops_EnumMapFactory::NamesToValuesMapType _has_bitwise_ops_NAMES_TO_VALUES;

using _is_unscoped_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<is_unscoped>;
extern const _is_unscoped_EnumMapFactory::ValuesToNamesMapType _is_unscoped_VALUES_TO_NAMES;
extern const _is_unscoped_EnumMapFactory::NamesToValuesMapType _is_unscoped_NAMES_TO_VALUES;

using _MyForwardRefEnum_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<MyForwardRefEnum>;
extern const _MyForwardRefEnum_EnumMapFactory::ValuesToNamesMapType _MyForwardRefEnum_VALUES_TO_NAMES;
extern const _MyForwardRefEnum_EnumMapFactory::NamesToValuesMapType _MyForwardRefEnum_NAMES_TO_VALUES;

using _MyEnumA_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<MyEnumA>;
extern const _MyEnumA_EnumMapFactory::ValuesToNamesMapType _MyEnumA_VALUES_TO_NAMES;
extern const _MyEnumA_EnumMapFactory::NamesToValuesMapType _MyEnumA_NAMES_TO_VALUES;

}}}} // apache::thrift::fixtures::types

// END declare_enums
// BEGIN struct_indirection

// END struct_indirection
// BEGIN forward_declare
namespace apache { namespace thrift { namespace fixtures { namespace types {
class decorated_struct;
class ContainerStruct;
class CppTypeStruct;
class VirtualStruct;
class MyStructWithForwardRefEnum;
class TrivialNumeric;
class TrivialNestedWithDefault;
class ComplexString;
class ComplexNestedWithDefault;
class MinPadding;
class MyDataItem;
class MyStruct;
class Renaming;
class AnnotatedTypes;
class ForwardUsageStruct;
class ForwardUsageRoot;
class ForwardUsageByRef;
class NoexceptMoveEmpty;
class NoexceptMoveSimpleStruct;
class NoexceptMoveComplexStruct;
class NoExceptMoveUnion;
}}}} // apache::thrift::fixtures::types
// END forward_declare
// BEGIN typedefs
namespace apache { namespace thrift { namespace fixtures { namespace types {
typedef ::std::string TBinary;

}}}} // apache::thrift::fixtures::types
// END typedefs
// BEGIN hash_and_equal_to
namespace std {

template<> struct hash<typename ::apache::thrift::fixtures::types::decorated_struct> {
  size_t operator()(const ::apache::thrift::fixtures::types::decorated_struct&) const;
};
template<> struct equal_to<typename ::apache::thrift::fixtures::types::decorated_struct> {
  bool operator()(const ::apache::thrift::fixtures::types::decorated_struct&,const ::apache::thrift::fixtures::types::decorated_struct&) const;
};
} // std
// END hash_and_equal_to
namespace apache { namespace thrift { namespace fixtures { namespace types {
class decorated_struct final : private apache::thrift::detail::st::ComparisonOperators<decorated_struct> {
 public:

  decorated_struct() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  decorated_struct(apache::thrift::FragileConstructor, ::std::string field__arg);

  decorated_struct(decorated_struct&&) = default;

  decorated_struct(const decorated_struct&) = default;

  decorated_struct& operator=(decorated_struct&&) = default;

  decorated_struct& operator=(const decorated_struct&) = default;
  void __clear();
 public:
  ::std::string field;

 public:
  struct __isset {
    bool field;
  } __isset = {};
  bool operator==(const decorated_struct& rhs) const;
  bool operator<(const decorated_struct& rhs) const;

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::string&> field_ref() const& {
    return {field, __isset.field};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::string&&> field_ref() const&& {
    return {std::move(field), __isset.field};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::string&> field_ref() & {
    return {field, __isset.field};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::string&&> field_ref() && {
    return {std::move(field), __isset.field};
  }

  const ::std::string& get_field() const& {
    return field;
  }

  ::std::string get_field() && {
    return std::move(field);
  }

  template <typename T_decorated_struct_field_struct_setter = ::std::string>
  ::std::string& set_field(T_decorated_struct_field_struct_setter&& field_) {
    field = std::forward<T_decorated_struct_field_struct_setter>(field_);
    __isset.field = true;
    return field;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< decorated_struct >;
};

void swap(decorated_struct& a, decorated_struct& b);

template <class Protocol_>
uint32_t decorated_struct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class ContainerStruct final : private apache::thrift::detail::st::ComparisonOperators<ContainerStruct> {
 public:

  ContainerStruct();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ContainerStruct(apache::thrift::FragileConstructor, ::std::vector<int32_t> fieldA__arg, std::list<int32_t> fieldB__arg, std::deque<int32_t> fieldC__arg, folly::fbvector<int32_t> fieldD__arg, folly::small_vector<int32_t> fieldE__arg, folly::sorted_vector_set<int32_t> fieldF__arg, folly::sorted_vector_map<int32_t, ::std::string> fieldG__arg,  ::apache::thrift::fixtures::types::SomeMap fieldH__arg);

  ContainerStruct(ContainerStruct&&) = default;

  ContainerStruct(const ContainerStruct&) = default;

  ContainerStruct& operator=(ContainerStruct&&) = default;

  ContainerStruct& operator=(const ContainerStruct&) = default;
  void __clear();

  ~ContainerStruct();

 public:
  ::std::vector<int32_t> fieldA;
 public:
  std::list<int32_t> fieldB;
 public:
  std::deque<int32_t> fieldC;
 public:
  folly::fbvector<int32_t> fieldD;
 public:
  folly::small_vector<int32_t> fieldE;
 public:
  folly::sorted_vector_set<int32_t> fieldF;
 public:
  folly::sorted_vector_map<int32_t, ::std::string> fieldG;
 public:
   ::apache::thrift::fixtures::types::SomeMap fieldH;

 public:
  struct __isset {
    bool fieldA;
    bool fieldB;
    bool fieldC;
    bool fieldD;
    bool fieldE;
    bool fieldF;
    bool fieldG;
    bool fieldH;
  } __isset = {};
  bool operator==(const ContainerStruct& rhs) const;
  bool operator<(const ContainerStruct& rhs) const;

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::vector<int32_t>&> fieldA_ref() const& {
    return {fieldA, __isset.fieldA};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::vector<int32_t>&&> fieldA_ref() const&& {
    return {std::move(fieldA), __isset.fieldA};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::vector<int32_t>&> fieldA_ref() & {
    return {fieldA, __isset.fieldA};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::vector<int32_t>&&> fieldA_ref() && {
    return {std::move(fieldA), __isset.fieldA};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const std::list<int32_t>&> fieldB_ref() const& {
    return {fieldB, __isset.fieldB};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const std::list<int32_t>&&> fieldB_ref() const&& {
    return {std::move(fieldB), __isset.fieldB};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<std::list<int32_t>&> fieldB_ref() & {
    return {fieldB, __isset.fieldB};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<std::list<int32_t>&&> fieldB_ref() && {
    return {std::move(fieldB), __isset.fieldB};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const std::deque<int32_t>&> fieldC_ref() const& {
    return {fieldC, __isset.fieldC};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const std::deque<int32_t>&&> fieldC_ref() const&& {
    return {std::move(fieldC), __isset.fieldC};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<std::deque<int32_t>&> fieldC_ref() & {
    return {fieldC, __isset.fieldC};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<std::deque<int32_t>&&> fieldC_ref() && {
    return {std::move(fieldC), __isset.fieldC};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const folly::fbvector<int32_t>&> fieldD_ref() const& {
    return {fieldD, __isset.fieldD};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const folly::fbvector<int32_t>&&> fieldD_ref() const&& {
    return {std::move(fieldD), __isset.fieldD};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<folly::fbvector<int32_t>&> fieldD_ref() & {
    return {fieldD, __isset.fieldD};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<folly::fbvector<int32_t>&&> fieldD_ref() && {
    return {std::move(fieldD), __isset.fieldD};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const folly::small_vector<int32_t>&> fieldE_ref() const& {
    return {fieldE, __isset.fieldE};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const folly::small_vector<int32_t>&&> fieldE_ref() const&& {
    return {std::move(fieldE), __isset.fieldE};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<folly::small_vector<int32_t>&> fieldE_ref() & {
    return {fieldE, __isset.fieldE};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<folly::small_vector<int32_t>&&> fieldE_ref() && {
    return {std::move(fieldE), __isset.fieldE};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const folly::sorted_vector_set<int32_t>&> fieldF_ref() const& {
    return {fieldF, __isset.fieldF};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const folly::sorted_vector_set<int32_t>&&> fieldF_ref() const&& {
    return {std::move(fieldF), __isset.fieldF};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<folly::sorted_vector_set<int32_t>&> fieldF_ref() & {
    return {fieldF, __isset.fieldF};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<folly::sorted_vector_set<int32_t>&&> fieldF_ref() && {
    return {std::move(fieldF), __isset.fieldF};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const folly::sorted_vector_map<int32_t, ::std::string>&> fieldG_ref() const& {
    return {fieldG, __isset.fieldG};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const folly::sorted_vector_map<int32_t, ::std::string>&&> fieldG_ref() const&& {
    return {std::move(fieldG), __isset.fieldG};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<folly::sorted_vector_map<int32_t, ::std::string>&> fieldG_ref() & {
    return {fieldG, __isset.fieldG};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<folly::sorted_vector_map<int32_t, ::std::string>&&> fieldG_ref() && {
    return {std::move(fieldG), __isset.fieldG};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const  ::apache::thrift::fixtures::types::SomeMap&> fieldH_ref() const& {
    return {fieldH, __isset.fieldH};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const  ::apache::thrift::fixtures::types::SomeMap&&> fieldH_ref() const&& {
    return {std::move(fieldH), __isset.fieldH};
  }

  FOLLY_ERASE ::apache::thrift::field_ref< ::apache::thrift::fixtures::types::SomeMap&> fieldH_ref() & {
    return {fieldH, __isset.fieldH};
  }

  FOLLY_ERASE ::apache::thrift::field_ref< ::apache::thrift::fixtures::types::SomeMap&&> fieldH_ref() && {
    return {std::move(fieldH), __isset.fieldH};
  }
  const ::std::vector<int32_t>& get_fieldA() const&;
  ::std::vector<int32_t> get_fieldA() &&;

  template <typename T_ContainerStruct_fieldA_struct_setter = ::std::vector<int32_t>>
  ::std::vector<int32_t>& set_fieldA(T_ContainerStruct_fieldA_struct_setter&& fieldA_) {
    fieldA = std::forward<T_ContainerStruct_fieldA_struct_setter>(fieldA_);
    __isset.fieldA = true;
    return fieldA;
  }
  const std::list<int32_t>& get_fieldB() const&;
  std::list<int32_t> get_fieldB() &&;

  template <typename T_ContainerStruct_fieldB_struct_setter = std::list<int32_t>>
  std::list<int32_t>& set_fieldB(T_ContainerStruct_fieldB_struct_setter&& fieldB_) {
    fieldB = std::forward<T_ContainerStruct_fieldB_struct_setter>(fieldB_);
    __isset.fieldB = true;
    return fieldB;
  }
  const std::deque<int32_t>& get_fieldC() const&;
  std::deque<int32_t> get_fieldC() &&;

  template <typename T_ContainerStruct_fieldC_struct_setter = std::deque<int32_t>>
  std::deque<int32_t>& set_fieldC(T_ContainerStruct_fieldC_struct_setter&& fieldC_) {
    fieldC = std::forward<T_ContainerStruct_fieldC_struct_setter>(fieldC_);
    __isset.fieldC = true;
    return fieldC;
  }
  const folly::fbvector<int32_t>& get_fieldD() const&;
  folly::fbvector<int32_t> get_fieldD() &&;

  template <typename T_ContainerStruct_fieldD_struct_setter = folly::fbvector<int32_t>>
  folly::fbvector<int32_t>& set_fieldD(T_ContainerStruct_fieldD_struct_setter&& fieldD_) {
    fieldD = std::forward<T_ContainerStruct_fieldD_struct_setter>(fieldD_);
    __isset.fieldD = true;
    return fieldD;
  }
  const folly::small_vector<int32_t>& get_fieldE() const&;
  folly::small_vector<int32_t> get_fieldE() &&;

  template <typename T_ContainerStruct_fieldE_struct_setter = folly::small_vector<int32_t>>
  folly::small_vector<int32_t>& set_fieldE(T_ContainerStruct_fieldE_struct_setter&& fieldE_) {
    fieldE = std::forward<T_ContainerStruct_fieldE_struct_setter>(fieldE_);
    __isset.fieldE = true;
    return fieldE;
  }
  const folly::sorted_vector_set<int32_t>& get_fieldF() const&;
  folly::sorted_vector_set<int32_t> get_fieldF() &&;

  template <typename T_ContainerStruct_fieldF_struct_setter = folly::sorted_vector_set<int32_t>>
  folly::sorted_vector_set<int32_t>& set_fieldF(T_ContainerStruct_fieldF_struct_setter&& fieldF_) {
    fieldF = std::forward<T_ContainerStruct_fieldF_struct_setter>(fieldF_);
    __isset.fieldF = true;
    return fieldF;
  }
  const folly::sorted_vector_map<int32_t, ::std::string>& get_fieldG() const&;
  folly::sorted_vector_map<int32_t, ::std::string> get_fieldG() &&;

  template <typename T_ContainerStruct_fieldG_struct_setter = folly::sorted_vector_map<int32_t, ::std::string>>
  folly::sorted_vector_map<int32_t, ::std::string>& set_fieldG(T_ContainerStruct_fieldG_struct_setter&& fieldG_) {
    fieldG = std::forward<T_ContainerStruct_fieldG_struct_setter>(fieldG_);
    __isset.fieldG = true;
    return fieldG;
  }
  const  ::apache::thrift::fixtures::types::SomeMap& get_fieldH() const&;
   ::apache::thrift::fixtures::types::SomeMap get_fieldH() &&;

  template <typename T_ContainerStruct_fieldH_struct_setter =  ::apache::thrift::fixtures::types::SomeMap>
   ::apache::thrift::fixtures::types::SomeMap& set_fieldH(T_ContainerStruct_fieldH_struct_setter&& fieldH_) {
    fieldH = std::forward<T_ContainerStruct_fieldH_struct_setter>(fieldH_);
    __isset.fieldH = true;
    return fieldH;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ContainerStruct >;
};

void swap(ContainerStruct& a, ContainerStruct& b);

template <class Protocol_>
uint32_t ContainerStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class CppTypeStruct final : private apache::thrift::detail::st::ComparisonOperators<CppTypeStruct> {
 public:

  CppTypeStruct() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CppTypeStruct(apache::thrift::FragileConstructor, std::list<int32_t> fieldA__arg);

  CppTypeStruct(CppTypeStruct&&) = default;

  CppTypeStruct(const CppTypeStruct&) = default;

  CppTypeStruct& operator=(CppTypeStruct&&) = default;

  CppTypeStruct& operator=(const CppTypeStruct&) = default;
  void __clear();
 public:
  std::list<int32_t> fieldA;

 public:
  struct __isset {
    bool fieldA;
  } __isset = {};
  bool operator==(const CppTypeStruct& rhs) const;
  bool operator<(const CppTypeStruct& rhs) const;

  FOLLY_ERASE ::apache::thrift::field_ref<const std::list<int32_t>&> fieldA_ref() const& {
    return {fieldA, __isset.fieldA};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const std::list<int32_t>&&> fieldA_ref() const&& {
    return {std::move(fieldA), __isset.fieldA};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<std::list<int32_t>&> fieldA_ref() & {
    return {fieldA, __isset.fieldA};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<std::list<int32_t>&&> fieldA_ref() && {
    return {std::move(fieldA), __isset.fieldA};
  }
  const std::list<int32_t>& get_fieldA() const&;
  std::list<int32_t> get_fieldA() &&;

  template <typename T_CppTypeStruct_fieldA_struct_setter = std::list<int32_t>>
  std::list<int32_t>& set_fieldA(T_CppTypeStruct_fieldA_struct_setter&& fieldA_) {
    fieldA = std::forward<T_CppTypeStruct_fieldA_struct_setter>(fieldA_);
    __isset.fieldA = true;
    return fieldA;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CppTypeStruct >;
};

void swap(CppTypeStruct& a, CppTypeStruct& b);

template <class Protocol_>
uint32_t CppTypeStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class VirtualStruct : private apache::thrift::detail::st::ComparisonOperators<VirtualStruct> {
 public:

  VirtualStruct() :
      MyIntField(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  VirtualStruct(apache::thrift::FragileConstructor, int64_t MyIntField__arg);

  VirtualStruct(VirtualStruct&&) = default;

  VirtualStruct(const VirtualStruct&) = default;

  VirtualStruct& operator=(VirtualStruct&&) = default;

  VirtualStruct& operator=(const VirtualStruct&) = default;
  void __clear();

  virtual ~VirtualStruct() {}

 public:
  int64_t MyIntField;

 public:
  struct __isset {
    bool MyIntField;
  } __isset = {};
  bool operator==(const VirtualStruct& rhs) const;
  bool operator<(const VirtualStruct& rhs) const;

  FOLLY_ERASE ::apache::thrift::field_ref<const int64_t&> MyIntField_ref() const& {
    return {MyIntField, __isset.MyIntField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const int64_t&&> MyIntField_ref() const&& {
    return {std::move(MyIntField), __isset.MyIntField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<int64_t&> MyIntField_ref() & {
    return {MyIntField, __isset.MyIntField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<int64_t&&> MyIntField_ref() && {
    return {std::move(MyIntField), __isset.MyIntField};
  }

  int64_t get_MyIntField() const {
    return MyIntField;
  }

  int64_t& set_MyIntField(int64_t MyIntField_) {
    MyIntField = MyIntField_;
    __isset.MyIntField = true;
    return MyIntField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< VirtualStruct >;
};

void swap(VirtualStruct& a, VirtualStruct& b);

template <class Protocol_>
uint32_t VirtualStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class MyStructWithForwardRefEnum final : private apache::thrift::detail::st::ComparisonOperators<MyStructWithForwardRefEnum> {
 public:

  MyStructWithForwardRefEnum() :
      a( ::apache::thrift::fixtures::types::MyForwardRefEnum::NONZERO),
      b( ::apache::thrift::fixtures::types::MyForwardRefEnum::NONZERO) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  MyStructWithForwardRefEnum(apache::thrift::FragileConstructor,  ::apache::thrift::fixtures::types::MyForwardRefEnum a__arg,  ::apache::thrift::fixtures::types::MyForwardRefEnum b__arg);

  MyStructWithForwardRefEnum(MyStructWithForwardRefEnum&&) = default;

  MyStructWithForwardRefEnum(const MyStructWithForwardRefEnum&) = default;

  MyStructWithForwardRefEnum& operator=(MyStructWithForwardRefEnum&&) = default;

  MyStructWithForwardRefEnum& operator=(const MyStructWithForwardRefEnum&) = default;
  void __clear();
 public:
   ::apache::thrift::fixtures::types::MyForwardRefEnum a;
 public:
   ::apache::thrift::fixtures::types::MyForwardRefEnum b;

 public:
  struct __isset {
    bool a;
    bool b;
  } __isset = {};
  bool operator==(const MyStructWithForwardRefEnum& rhs) const;
  bool operator<(const MyStructWithForwardRefEnum& rhs) const;

  FOLLY_ERASE ::apache::thrift::field_ref<const  ::apache::thrift::fixtures::types::MyForwardRefEnum&> a_ref() const& {
    return {a, __isset.a};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const  ::apache::thrift::fixtures::types::MyForwardRefEnum&&> a_ref() const&& {
    return {std::move(a), __isset.a};
  }

  FOLLY_ERASE ::apache::thrift::field_ref< ::apache::thrift::fixtures::types::MyForwardRefEnum&> a_ref() & {
    return {a, __isset.a};
  }

  FOLLY_ERASE ::apache::thrift::field_ref< ::apache::thrift::fixtures::types::MyForwardRefEnum&&> a_ref() && {
    return {std::move(a), __isset.a};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const  ::apache::thrift::fixtures::types::MyForwardRefEnum&> b_ref() const& {
    return {b, __isset.b};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const  ::apache::thrift::fixtures::types::MyForwardRefEnum&&> b_ref() const&& {
    return {std::move(b), __isset.b};
  }

  FOLLY_ERASE ::apache::thrift::field_ref< ::apache::thrift::fixtures::types::MyForwardRefEnum&> b_ref() & {
    return {b, __isset.b};
  }

  FOLLY_ERASE ::apache::thrift::field_ref< ::apache::thrift::fixtures::types::MyForwardRefEnum&&> b_ref() && {
    return {std::move(b), __isset.b};
  }

   ::apache::thrift::fixtures::types::MyForwardRefEnum get_a() const {
    return a;
  }

   ::apache::thrift::fixtures::types::MyForwardRefEnum& set_a( ::apache::thrift::fixtures::types::MyForwardRefEnum a_) {
    a = a_;
    __isset.a = true;
    return a;
  }

   ::apache::thrift::fixtures::types::MyForwardRefEnum get_b() const {
    return b;
  }

   ::apache::thrift::fixtures::types::MyForwardRefEnum& set_b( ::apache::thrift::fixtures::types::MyForwardRefEnum b_) {
    b = b_;
    __isset.b = true;
    return b;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< MyStructWithForwardRefEnum >;
};

void swap(MyStructWithForwardRefEnum& a, MyStructWithForwardRefEnum& b);

template <class Protocol_>
uint32_t MyStructWithForwardRefEnum::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class TrivialNumeric final : private apache::thrift::detail::st::ComparisonOperators<TrivialNumeric> {
 public:

  TrivialNumeric() :
      a(0),
      b(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  TrivialNumeric(apache::thrift::FragileConstructor, int32_t a__arg, bool b__arg);

  TrivialNumeric(TrivialNumeric&&) = default;

  TrivialNumeric(const TrivialNumeric&) = default;

  TrivialNumeric& operator=(TrivialNumeric&&) = default;

  TrivialNumeric& operator=(const TrivialNumeric&) = default;
  void __clear();
 public:
  int32_t a;
 public:
  bool b;

 public:
  struct __isset {
    bool a;
    bool b;
  } __isset = {};
  bool operator==(const TrivialNumeric& rhs) const;
  bool operator<(const TrivialNumeric& rhs) const;

  FOLLY_ERASE ::apache::thrift::field_ref<const int32_t&> a_ref() const& {
    return {a, __isset.a};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const int32_t&&> a_ref() const&& {
    return {std::move(a), __isset.a};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<int32_t&> a_ref() & {
    return {a, __isset.a};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<int32_t&&> a_ref() && {
    return {std::move(a), __isset.a};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const bool&> b_ref() const& {
    return {b, __isset.b};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const bool&&> b_ref() const&& {
    return {std::move(b), __isset.b};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<bool&> b_ref() & {
    return {b, __isset.b};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<bool&&> b_ref() && {
    return {std::move(b), __isset.b};
  }

  int32_t get_a() const {
    return a;
  }

  int32_t& set_a(int32_t a_) {
    a = a_;
    __isset.a = true;
    return a;
  }

  bool get_b() const {
    return b;
  }

  bool& set_b(bool b_) {
    b = b_;
    __isset.b = true;
    return b;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< TrivialNumeric >;
};

void swap(TrivialNumeric& a, TrivialNumeric& b);

template <class Protocol_>
uint32_t TrivialNumeric::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class TrivialNestedWithDefault final : private apache::thrift::detail::st::ComparisonOperators<TrivialNestedWithDefault> {
 public:

  TrivialNestedWithDefault() :
      z(4),
      n(::apache::thrift::detail::make_constant< ::apache::thrift::fixtures::types::TrivialNumeric>(::apache::thrift::type_class::structure{}, ::apache::thrift::detail::wrap_struct_argument<::apache::thrift::tag::a>(3), ::apache::thrift::detail::wrap_struct_argument<::apache::thrift::tag::b>(true))) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  TrivialNestedWithDefault(apache::thrift::FragileConstructor, int32_t z__arg,  ::apache::thrift::fixtures::types::TrivialNumeric n__arg);

  TrivialNestedWithDefault(TrivialNestedWithDefault&&) = default;

  TrivialNestedWithDefault(const TrivialNestedWithDefault&) = default;

  TrivialNestedWithDefault& operator=(TrivialNestedWithDefault&&) = default;

  TrivialNestedWithDefault& operator=(const TrivialNestedWithDefault&) = default;
  void __clear();
 public:
  int32_t z;
 public:
   ::apache::thrift::fixtures::types::TrivialNumeric n;

 public:
  struct __isset {
    bool z;
    bool n;
  } __isset = {};
  bool operator==(const TrivialNestedWithDefault& rhs) const;
  bool operator<(const TrivialNestedWithDefault& rhs) const;

  FOLLY_ERASE ::apache::thrift::field_ref<const int32_t&> z_ref() const& {
    return {z, __isset.z};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const int32_t&&> z_ref() const&& {
    return {std::move(z), __isset.z};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<int32_t&> z_ref() & {
    return {z, __isset.z};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<int32_t&&> z_ref() && {
    return {std::move(z), __isset.z};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const  ::apache::thrift::fixtures::types::TrivialNumeric&> n_ref() const& {
    return {n, __isset.n};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const  ::apache::thrift::fixtures::types::TrivialNumeric&&> n_ref() const&& {
    return {std::move(n), __isset.n};
  }

  FOLLY_ERASE ::apache::thrift::field_ref< ::apache::thrift::fixtures::types::TrivialNumeric&> n_ref() & {
    return {n, __isset.n};
  }

  FOLLY_ERASE ::apache::thrift::field_ref< ::apache::thrift::fixtures::types::TrivialNumeric&&> n_ref() && {
    return {std::move(n), __isset.n};
  }

  int32_t get_z() const {
    return z;
  }

  int32_t& set_z(int32_t z_) {
    z = z_;
    __isset.z = true;
    return z;
  }
  const  ::apache::thrift::fixtures::types::TrivialNumeric& get_n() const&;
   ::apache::thrift::fixtures::types::TrivialNumeric get_n() &&;

  template <typename T_TrivialNestedWithDefault_n_struct_setter =  ::apache::thrift::fixtures::types::TrivialNumeric>
   ::apache::thrift::fixtures::types::TrivialNumeric& set_n(T_TrivialNestedWithDefault_n_struct_setter&& n_) {
    n = std::forward<T_TrivialNestedWithDefault_n_struct_setter>(n_);
    __isset.n = true;
    return n;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< TrivialNestedWithDefault >;
};

void swap(TrivialNestedWithDefault& a, TrivialNestedWithDefault& b);

template <class Protocol_>
uint32_t TrivialNestedWithDefault::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class ComplexString final : private apache::thrift::detail::st::ComparisonOperators<ComplexString> {
 public:

  ComplexString() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ComplexString(apache::thrift::FragileConstructor, ::std::string a__arg, ::std::map<::std::string, int32_t> b__arg);

  ComplexString(ComplexString&&) = default;

  ComplexString(const ComplexString&) = default;

  ComplexString& operator=(ComplexString&&) = default;

  ComplexString& operator=(const ComplexString&) = default;
  void __clear();
 public:
  ::std::string a;
 public:
  ::std::map<::std::string, int32_t> b;

 public:
  struct __isset {
    bool a;
    bool b;
  } __isset = {};
  bool operator==(const ComplexString& rhs) const;
  bool operator<(const ComplexString& rhs) const;

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::string&> a_ref() const& {
    return {a, __isset.a};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::string&&> a_ref() const&& {
    return {std::move(a), __isset.a};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::string&> a_ref() & {
    return {a, __isset.a};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::string&&> a_ref() && {
    return {std::move(a), __isset.a};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::map<::std::string, int32_t>&> b_ref() const& {
    return {b, __isset.b};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::map<::std::string, int32_t>&&> b_ref() const&& {
    return {std::move(b), __isset.b};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::map<::std::string, int32_t>&> b_ref() & {
    return {b, __isset.b};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::map<::std::string, int32_t>&&> b_ref() && {
    return {std::move(b), __isset.b};
  }

  const ::std::string& get_a() const& {
    return a;
  }

  ::std::string get_a() && {
    return std::move(a);
  }

  template <typename T_ComplexString_a_struct_setter = ::std::string>
  ::std::string& set_a(T_ComplexString_a_struct_setter&& a_) {
    a = std::forward<T_ComplexString_a_struct_setter>(a_);
    __isset.a = true;
    return a;
  }
  const ::std::map<::std::string, int32_t>& get_b() const&;
  ::std::map<::std::string, int32_t> get_b() &&;

  template <typename T_ComplexString_b_struct_setter = ::std::map<::std::string, int32_t>>
  ::std::map<::std::string, int32_t>& set_b(T_ComplexString_b_struct_setter&& b_) {
    b = std::forward<T_ComplexString_b_struct_setter>(b_);
    __isset.b = true;
    return b;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ComplexString >;
};

void swap(ComplexString& a, ComplexString& b);

template <class Protocol_>
uint32_t ComplexString::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class ComplexNestedWithDefault final : private apache::thrift::detail::st::ComparisonOperators<ComplexNestedWithDefault> {
 public:

  ComplexNestedWithDefault() :
      z(apache::thrift::StringTraits< std::string>::fromStringLiteral("4")),
      n(::apache::thrift::detail::make_constant< ::apache::thrift::fixtures::types::ComplexString>(::apache::thrift::type_class::structure{}, ::apache::thrift::detail::wrap_struct_argument<::apache::thrift::tag::a>(apache::thrift::StringTraits< std::string>::fromStringLiteral("3")), ::apache::thrift::detail::wrap_struct_argument<::apache::thrift::tag::b>(std::initializer_list<std::pair<const ::std::string, int32_t>>{{apache::thrift::StringTraits< std::string>::fromStringLiteral("a"), 3}}))) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ComplexNestedWithDefault(apache::thrift::FragileConstructor, ::std::string z__arg,  ::apache::thrift::fixtures::types::ComplexString n__arg);

  ComplexNestedWithDefault(ComplexNestedWithDefault&&) = default;

  ComplexNestedWithDefault(const ComplexNestedWithDefault&) = default;

  ComplexNestedWithDefault& operator=(ComplexNestedWithDefault&&) = default;

  ComplexNestedWithDefault& operator=(const ComplexNestedWithDefault&) = default;
  void __clear();
 public:
  ::std::string z;
 public:
   ::apache::thrift::fixtures::types::ComplexString n;

 public:
  struct __isset {
    bool z;
    bool n;
  } __isset = {};
  bool operator==(const ComplexNestedWithDefault& rhs) const;
  bool operator<(const ComplexNestedWithDefault& rhs) const;

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::string&> z_ref() const& {
    return {z, __isset.z};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::string&&> z_ref() const&& {
    return {std::move(z), __isset.z};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::string&> z_ref() & {
    return {z, __isset.z};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::string&&> z_ref() && {
    return {std::move(z), __isset.z};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const  ::apache::thrift::fixtures::types::ComplexString&> n_ref() const& {
    return {n, __isset.n};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const  ::apache::thrift::fixtures::types::ComplexString&&> n_ref() const&& {
    return {std::move(n), __isset.n};
  }

  FOLLY_ERASE ::apache::thrift::field_ref< ::apache::thrift::fixtures::types::ComplexString&> n_ref() & {
    return {n, __isset.n};
  }

  FOLLY_ERASE ::apache::thrift::field_ref< ::apache::thrift::fixtures::types::ComplexString&&> n_ref() && {
    return {std::move(n), __isset.n};
  }

  const ::std::string& get_z() const& {
    return z;
  }

  ::std::string get_z() && {
    return std::move(z);
  }

  template <typename T_ComplexNestedWithDefault_z_struct_setter = ::std::string>
  ::std::string& set_z(T_ComplexNestedWithDefault_z_struct_setter&& z_) {
    z = std::forward<T_ComplexNestedWithDefault_z_struct_setter>(z_);
    __isset.z = true;
    return z;
  }
  const  ::apache::thrift::fixtures::types::ComplexString& get_n() const&;
   ::apache::thrift::fixtures::types::ComplexString get_n() &&;

  template <typename T_ComplexNestedWithDefault_n_struct_setter =  ::apache::thrift::fixtures::types::ComplexString>
   ::apache::thrift::fixtures::types::ComplexString& set_n(T_ComplexNestedWithDefault_n_struct_setter&& n_) {
    n = std::forward<T_ComplexNestedWithDefault_n_struct_setter>(n_);
    __isset.n = true;
    return n;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ComplexNestedWithDefault >;
};

void swap(ComplexNestedWithDefault& a, ComplexNestedWithDefault& b);

template <class Protocol_>
uint32_t ComplexNestedWithDefault::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class MinPadding final : private apache::thrift::detail::st::ComparisonOperators<MinPadding> {
 public:

  MinPadding() :
      big(0),
      biggish(0),
      medium(0),
      small(0),
      tiny(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  MinPadding(apache::thrift::FragileConstructor, int8_t small__arg, int64_t big__arg, int16_t medium__arg, int32_t biggish__arg, int8_t tiny__arg);

  MinPadding(MinPadding&&) = default;

  MinPadding(const MinPadding&) = default;

  MinPadding& operator=(MinPadding&&) = default;

  MinPadding& operator=(const MinPadding&) = default;
  void __clear();
 public:
  int64_t big;
 public:
  int32_t biggish;
 public:
  int16_t medium;
 public:
  int8_t small;
 public:
  int8_t tiny;

 public:
  bool operator==(const MinPadding& rhs) const;
  bool operator<(const MinPadding& rhs) const;

  int8_t get_small() const {
    return small;
  }

  int8_t& set_small(int8_t small_) {
    small = small_;
    return small;
  }

  int64_t get_big() const {
    return big;
  }

  int64_t& set_big(int64_t big_) {
    big = big_;
    return big;
  }

  int16_t get_medium() const {
    return medium;
  }

  int16_t& set_medium(int16_t medium_) {
    medium = medium_;
    return medium;
  }

  int32_t get_biggish() const {
    return biggish;
  }

  int32_t& set_biggish(int32_t biggish_) {
    biggish = biggish_;
    return biggish;
  }

  int8_t get_tiny() const {
    return tiny;
  }

  int8_t& set_tiny(int8_t tiny_) {
    tiny = tiny_;
    return tiny;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< MinPadding >;
};

void swap(MinPadding& a, MinPadding& b);

template <class Protocol_>
uint32_t MinPadding::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class MyDataItem final : private apache::thrift::detail::st::ComparisonOperators<MyDataItem> {
 public:

  MyDataItem() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  MyDataItem(apache::thrift::FragileConstructor);

  MyDataItem(MyDataItem&&) = default;

  MyDataItem(const MyDataItem&) = default;

  MyDataItem& operator=(MyDataItem&&) = default;

  MyDataItem& operator=(const MyDataItem&) = default;
  void __clear();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< MyDataItem >;
};

void swap(MyDataItem& a, MyDataItem& b);

template <class Protocol_>
uint32_t MyDataItem::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class MyStruct final : private apache::thrift::detail::st::ComparisonOperators<MyStruct> {
 public:

  MyStruct() :
      MyIntField(0),
      majorVer(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  MyStruct(apache::thrift::FragileConstructor, int64_t MyIntField__arg, ::std::string MyStringField__arg, int64_t majorVer__arg,  ::apache::thrift::fixtures::types::MyDataItem data__arg);

  MyStruct(MyStruct&&) = default;

  MyStruct(const MyStruct&) = default;

  MyStruct& operator=(MyStruct&&) = default;

  MyStruct& operator=(const MyStruct&) = default;
  void __clear();
 public:
  int64_t MyIntField;
 public:
  ::std::string MyStringField;
 public:
  int64_t majorVer;
 public:
   ::apache::thrift::fixtures::types::MyDataItem data;

 public:
  struct __isset {
    bool MyIntField;
    bool MyStringField;
    bool majorVer;
    bool data;
  } __isset = {};

  FOLLY_ERASE ::apache::thrift::field_ref<const int64_t&> MyIntField_ref() const& {
    return {MyIntField, __isset.MyIntField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const int64_t&&> MyIntField_ref() const&& {
    return {std::move(MyIntField), __isset.MyIntField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<int64_t&> MyIntField_ref() & {
    return {MyIntField, __isset.MyIntField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<int64_t&&> MyIntField_ref() && {
    return {std::move(MyIntField), __isset.MyIntField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::string&> MyStringField_ref() const& {
    return {MyStringField, __isset.MyStringField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::string&&> MyStringField_ref() const&& {
    return {std::move(MyStringField), __isset.MyStringField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::string&> MyStringField_ref() & {
    return {MyStringField, __isset.MyStringField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::string&&> MyStringField_ref() && {
    return {std::move(MyStringField), __isset.MyStringField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const int64_t&> majorVer_ref() const& {
    return {majorVer, __isset.majorVer};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const int64_t&&> majorVer_ref() const&& {
    return {std::move(majorVer), __isset.majorVer};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<int64_t&> majorVer_ref() & {
    return {majorVer, __isset.majorVer};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<int64_t&&> majorVer_ref() && {
    return {std::move(majorVer), __isset.majorVer};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const  ::apache::thrift::fixtures::types::MyDataItem&> data_ref() const& {
    return {data, __isset.data};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const  ::apache::thrift::fixtures::types::MyDataItem&&> data_ref() const&& {
    return {std::move(data), __isset.data};
  }

  FOLLY_ERASE ::apache::thrift::field_ref< ::apache::thrift::fixtures::types::MyDataItem&> data_ref() & {
    return {data, __isset.data};
  }

  FOLLY_ERASE ::apache::thrift::field_ref< ::apache::thrift::fixtures::types::MyDataItem&&> data_ref() && {
    return {std::move(data), __isset.data};
  }

  int64_t get_MyIntField() const {
    return MyIntField;
  }

  int64_t& set_MyIntField(int64_t MyIntField_) {
    MyIntField = MyIntField_;
    __isset.MyIntField = true;
    return MyIntField;
  }

  const ::std::string& get_MyStringField() const& {
    return MyStringField;
  }

  ::std::string get_MyStringField() && {
    return std::move(MyStringField);
  }

  template <typename T_MyStruct_MyStringField_struct_setter = ::std::string>
  ::std::string& set_MyStringField(T_MyStruct_MyStringField_struct_setter&& MyStringField_) {
    MyStringField = std::forward<T_MyStruct_MyStringField_struct_setter>(MyStringField_);
    __isset.MyStringField = true;
    return MyStringField;
  }

  int64_t get_majorVer() const {
    return majorVer;
  }

  int64_t& set_majorVer(int64_t majorVer_) {
    majorVer = majorVer_;
    __isset.majorVer = true;
    return majorVer;
  }
  const  ::apache::thrift::fixtures::types::MyDataItem& get_data() const&;
   ::apache::thrift::fixtures::types::MyDataItem get_data() &&;

  template <typename T_MyStruct_data_struct_setter =  ::apache::thrift::fixtures::types::MyDataItem>
   ::apache::thrift::fixtures::types::MyDataItem& set_data(T_MyStruct_data_struct_setter&& data_) {
    data = std::forward<T_MyStruct_data_struct_setter>(data_);
    __isset.data = true;
    return data;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< MyStruct >;
};

void swap(MyStruct& a, MyStruct& b);

template <class Protocol_>
uint32_t MyStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class Renaming final : private apache::thrift::detail::st::ComparisonOperators<Renaming> {
 public:

  Renaming() :
      bar(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Renaming(apache::thrift::FragileConstructor, int64_t bar__arg);

  Renaming(Renaming&&) = default;

  Renaming(const Renaming&) = default;

  Renaming& operator=(Renaming&&) = default;

  Renaming& operator=(const Renaming&) = default;
  void __clear();
 public:
  int64_t bar;

 public:
  struct __isset {
    bool bar;
  } __isset = {};
  bool operator==(const Renaming& rhs) const;
  bool operator<(const Renaming& rhs) const;

  FOLLY_ERASE ::apache::thrift::field_ref<const int64_t&> bar_ref() const& {
    return {bar, __isset.bar};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const int64_t&&> bar_ref() const&& {
    return {std::move(bar), __isset.bar};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<int64_t&> bar_ref() & {
    return {bar, __isset.bar};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<int64_t&&> bar_ref() && {
    return {std::move(bar), __isset.bar};
  }

  int64_t get_bar() const {
    return bar;
  }

  int64_t& set_bar(int64_t bar_) {
    bar = bar_;
    __isset.bar = true;
    return bar;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Renaming >;
};

void swap(Renaming& a, Renaming& b);

template <class Protocol_>
uint32_t Renaming::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class AnnotatedTypes final : private apache::thrift::detail::st::ComparisonOperators<AnnotatedTypes> {
 public:

  AnnotatedTypes() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AnnotatedTypes(apache::thrift::FragileConstructor,  ::apache::thrift::fixtures::types::TBinary binary_field__arg,  ::apache::thrift::fixtures::types::SomeListOfTypeMap list_field__arg);

  AnnotatedTypes(AnnotatedTypes&&) = default;

  AnnotatedTypes(const AnnotatedTypes&) = default;

  AnnotatedTypes& operator=(AnnotatedTypes&&) = default;

  AnnotatedTypes& operator=(const AnnotatedTypes&) = default;
  void __clear();
 public:
   ::apache::thrift::fixtures::types::TBinary binary_field;
 public:
   ::apache::thrift::fixtures::types::SomeListOfTypeMap list_field;

 public:
  struct __isset {
    bool binary_field;
    bool list_field;
  } __isset = {};
  bool operator==(const AnnotatedTypes& rhs) const;
  bool operator<(const AnnotatedTypes& rhs) const;

  FOLLY_ERASE ::apache::thrift::field_ref<const  ::apache::thrift::fixtures::types::TBinary&> binary_field_ref() const& {
    return {binary_field, __isset.binary_field};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const  ::apache::thrift::fixtures::types::TBinary&&> binary_field_ref() const&& {
    return {std::move(binary_field), __isset.binary_field};
  }

  FOLLY_ERASE ::apache::thrift::field_ref< ::apache::thrift::fixtures::types::TBinary&> binary_field_ref() & {
    return {binary_field, __isset.binary_field};
  }

  FOLLY_ERASE ::apache::thrift::field_ref< ::apache::thrift::fixtures::types::TBinary&&> binary_field_ref() && {
    return {std::move(binary_field), __isset.binary_field};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const  ::apache::thrift::fixtures::types::SomeListOfTypeMap&> list_field_ref() const& {
    return {list_field, __isset.list_field};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const  ::apache::thrift::fixtures::types::SomeListOfTypeMap&&> list_field_ref() const&& {
    return {std::move(list_field), __isset.list_field};
  }

  FOLLY_ERASE ::apache::thrift::field_ref< ::apache::thrift::fixtures::types::SomeListOfTypeMap&> list_field_ref() & {
    return {list_field, __isset.list_field};
  }

  FOLLY_ERASE ::apache::thrift::field_ref< ::apache::thrift::fixtures::types::SomeListOfTypeMap&&> list_field_ref() && {
    return {std::move(list_field), __isset.list_field};
  }

  const  ::apache::thrift::fixtures::types::TBinary& get_binary_field() const& {
    return binary_field;
  }

   ::apache::thrift::fixtures::types::TBinary get_binary_field() && {
    return std::move(binary_field);
  }

  template <typename T_AnnotatedTypes_binary_field_struct_setter =  ::apache::thrift::fixtures::types::TBinary>
   ::apache::thrift::fixtures::types::TBinary& set_binary_field(T_AnnotatedTypes_binary_field_struct_setter&& binary_field_) {
    binary_field = std::forward<T_AnnotatedTypes_binary_field_struct_setter>(binary_field_);
    __isset.binary_field = true;
    return binary_field;
  }
  const  ::apache::thrift::fixtures::types::SomeListOfTypeMap& get_list_field() const&;
   ::apache::thrift::fixtures::types::SomeListOfTypeMap get_list_field() &&;

  template <typename T_AnnotatedTypes_list_field_struct_setter =  ::apache::thrift::fixtures::types::SomeListOfTypeMap>
   ::apache::thrift::fixtures::types::SomeListOfTypeMap& set_list_field(T_AnnotatedTypes_list_field_struct_setter&& list_field_) {
    list_field = std::forward<T_AnnotatedTypes_list_field_struct_setter>(list_field_);
    __isset.list_field = true;
    return list_field;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AnnotatedTypes >;
};

void swap(AnnotatedTypes& a, AnnotatedTypes& b);

template <class Protocol_>
uint32_t AnnotatedTypes::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class ForwardUsageStruct final : private apache::thrift::detail::st::ComparisonOperators<ForwardUsageStruct> {
 public:

  ForwardUsageStruct() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ForwardUsageStruct(apache::thrift::FragileConstructor,  ::apache::thrift::fixtures::types::ForwardUsageRoot foo__arg);

  ForwardUsageStruct(ForwardUsageStruct&&) = default;

  ForwardUsageStruct(const ForwardUsageStruct&) = default;

  ForwardUsageStruct& operator=(ForwardUsageStruct&&) = default;

  ForwardUsageStruct& operator=(const ForwardUsageStruct&) = default;
  void __clear();
 private:
   ::apache::thrift::fixtures::types::ForwardUsageRoot foo;

 public:
  struct __isset {
    bool foo;
  } __isset = {};
  bool operator==(const ForwardUsageStruct& rhs) const;
  bool operator<(const ForwardUsageStruct& rhs) const;

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const  ::apache::thrift::fixtures::types::ForwardUsageRoot&> foo_ref() const& {
    return {foo, __isset.foo};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const  ::apache::thrift::fixtures::types::ForwardUsageRoot&&> foo_ref() const&& {
    return {std::move(foo), __isset.foo};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref< ::apache::thrift::fixtures::types::ForwardUsageRoot&> foo_ref() & {
    return {foo, __isset.foo};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref< ::apache::thrift::fixtures::types::ForwardUsageRoot&&> foo_ref() && {
    return {std::move(foo), __isset.foo};
  }
  const  ::apache::thrift::fixtures::types::ForwardUsageRoot* get_foo() const&;
   ::apache::thrift::fixtures::types::ForwardUsageRoot* get_foo() &;
   ::apache::thrift::fixtures::types::ForwardUsageRoot* get_foo() && = delete;

  template <typename T_ForwardUsageStruct_foo_struct_setter =  ::apache::thrift::fixtures::types::ForwardUsageRoot>
   ::apache::thrift::fixtures::types::ForwardUsageRoot& set_foo(T_ForwardUsageStruct_foo_struct_setter&& foo_) {
    foo = std::forward<T_ForwardUsageStruct_foo_struct_setter>(foo_);
    __isset.foo = true;
    return foo;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ForwardUsageStruct >;
};

void swap(ForwardUsageStruct& a, ForwardUsageStruct& b);

template <class Protocol_>
uint32_t ForwardUsageStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class ForwardUsageRoot final : private apache::thrift::detail::st::ComparisonOperators<ForwardUsageRoot> {
 public:

  ForwardUsageRoot() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ForwardUsageRoot(apache::thrift::FragileConstructor,  ::apache::thrift::fixtures::types::ForwardUsageStruct ForwardUsageStruct__arg, std::unique_ptr< ::apache::thrift::fixtures::types::ForwardUsageByRef> ForwardUsageByRef__arg);

  ForwardUsageRoot(ForwardUsageRoot&&) = default;
  ForwardUsageRoot(const ForwardUsageRoot& src);

  ForwardUsageRoot& operator=(ForwardUsageRoot&&) = default;
  ForwardUsageRoot& operator=(const ForwardUsageRoot& src);
  void __clear();
 private:
   ::apache::thrift::fixtures::types::ForwardUsageStruct ForwardUsageStruct;
 public:
  std::unique_ptr< ::apache::thrift::fixtures::types::ForwardUsageByRef> ForwardUsageByRef;

 public:
  struct __isset {
    bool ForwardUsageStruct;
  } __isset = {};
  bool operator==(const ForwardUsageRoot& rhs) const;
  bool operator<(const ForwardUsageRoot& rhs) const;

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const  ::apache::thrift::fixtures::types::ForwardUsageStruct&> ForwardUsageStruct_ref() const& {
    return {ForwardUsageStruct, __isset.ForwardUsageStruct};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const  ::apache::thrift::fixtures::types::ForwardUsageStruct&&> ForwardUsageStruct_ref() const&& {
    return {std::move(ForwardUsageStruct), __isset.ForwardUsageStruct};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref< ::apache::thrift::fixtures::types::ForwardUsageStruct&> ForwardUsageStruct_ref() & {
    return {ForwardUsageStruct, __isset.ForwardUsageStruct};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref< ::apache::thrift::fixtures::types::ForwardUsageStruct&&> ForwardUsageStruct_ref() && {
    return {std::move(ForwardUsageStruct), __isset.ForwardUsageStruct};
  }
  const  ::apache::thrift::fixtures::types::ForwardUsageStruct* get_ForwardUsageStruct() const&;
   ::apache::thrift::fixtures::types::ForwardUsageStruct* get_ForwardUsageStruct() &;
   ::apache::thrift::fixtures::types::ForwardUsageStruct* get_ForwardUsageStruct() && = delete;

  template <typename T_ForwardUsageRoot_ForwardUsageStruct_struct_setter =  ::apache::thrift::fixtures::types::ForwardUsageStruct>
   ::apache::thrift::fixtures::types::ForwardUsageStruct& set_ForwardUsageStruct(T_ForwardUsageRoot_ForwardUsageStruct_struct_setter&& ForwardUsageStruct_) {
    ForwardUsageStruct = std::forward<T_ForwardUsageRoot_ForwardUsageStruct_struct_setter>(ForwardUsageStruct_);
    __isset.ForwardUsageStruct = true;
    return ForwardUsageStruct;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ForwardUsageRoot >;
};

void swap(ForwardUsageRoot& a, ForwardUsageRoot& b);

template <class Protocol_>
uint32_t ForwardUsageRoot::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class ForwardUsageByRef final : private apache::thrift::detail::st::ComparisonOperators<ForwardUsageByRef> {
 public:

  ForwardUsageByRef() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ForwardUsageByRef(apache::thrift::FragileConstructor,  ::apache::thrift::fixtures::types::ForwardUsageRoot foo__arg);

  ForwardUsageByRef(ForwardUsageByRef&&) = default;

  ForwardUsageByRef(const ForwardUsageByRef&) = default;

  ForwardUsageByRef& operator=(ForwardUsageByRef&&) = default;

  ForwardUsageByRef& operator=(const ForwardUsageByRef&) = default;
  void __clear();
 private:
   ::apache::thrift::fixtures::types::ForwardUsageRoot foo;

 public:
  struct __isset {
    bool foo;
  } __isset = {};
  bool operator==(const ForwardUsageByRef& rhs) const;
  bool operator<(const ForwardUsageByRef& rhs) const;

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const  ::apache::thrift::fixtures::types::ForwardUsageRoot&> foo_ref() const& {
    return {foo, __isset.foo};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const  ::apache::thrift::fixtures::types::ForwardUsageRoot&&> foo_ref() const&& {
    return {std::move(foo), __isset.foo};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref< ::apache::thrift::fixtures::types::ForwardUsageRoot&> foo_ref() & {
    return {foo, __isset.foo};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref< ::apache::thrift::fixtures::types::ForwardUsageRoot&&> foo_ref() && {
    return {std::move(foo), __isset.foo};
  }
  const  ::apache::thrift::fixtures::types::ForwardUsageRoot* get_foo() const&;
   ::apache::thrift::fixtures::types::ForwardUsageRoot* get_foo() &;
   ::apache::thrift::fixtures::types::ForwardUsageRoot* get_foo() && = delete;

  template <typename T_ForwardUsageByRef_foo_struct_setter =  ::apache::thrift::fixtures::types::ForwardUsageRoot>
   ::apache::thrift::fixtures::types::ForwardUsageRoot& set_foo(T_ForwardUsageByRef_foo_struct_setter&& foo_) {
    foo = std::forward<T_ForwardUsageByRef_foo_struct_setter>(foo_);
    __isset.foo = true;
    return foo;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ForwardUsageByRef >;
};

void swap(ForwardUsageByRef& a, ForwardUsageByRef& b);

template <class Protocol_>
uint32_t ForwardUsageByRef::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class NoexceptMoveEmpty final : private apache::thrift::detail::st::ComparisonOperators<NoexceptMoveEmpty> {
 public:

  NoexceptMoveEmpty() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  NoexceptMoveEmpty(apache::thrift::FragileConstructor);
  NoexceptMoveEmpty(NoexceptMoveEmpty&& other) noexcept {}

  NoexceptMoveEmpty(const NoexceptMoveEmpty&) = default;

  NoexceptMoveEmpty& operator=(NoexceptMoveEmpty&&) noexcept = default;

  NoexceptMoveEmpty& operator=(const NoexceptMoveEmpty&) = default;
  void __clear();
  bool operator==(const NoexceptMoveEmpty& rhs) const;
  bool operator<(const NoexceptMoveEmpty& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< NoexceptMoveEmpty >;
};

void swap(NoexceptMoveEmpty& a, NoexceptMoveEmpty& b);

template <class Protocol_>
uint32_t NoexceptMoveEmpty::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class NoexceptMoveSimpleStruct final : private apache::thrift::detail::st::ComparisonOperators<NoexceptMoveSimpleStruct> {
 public:

  NoexceptMoveSimpleStruct() :
      boolField(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  NoexceptMoveSimpleStruct(apache::thrift::FragileConstructor, int64_t boolField__arg);
  NoexceptMoveSimpleStruct(NoexceptMoveSimpleStruct&& other) noexcept :
      boolField(std::move(other.boolField)),
      __isset(other.__isset) {}
  NoexceptMoveSimpleStruct(const NoexceptMoveSimpleStruct&) = default;

  NoexceptMoveSimpleStruct& operator=(NoexceptMoveSimpleStruct&&) noexcept = default;

  NoexceptMoveSimpleStruct& operator=(const NoexceptMoveSimpleStruct&) = default;
  void __clear();
 public:
  int64_t boolField;

 public:
  struct __isset {
    bool boolField;
  } __isset = {};
  bool operator==(const NoexceptMoveSimpleStruct& rhs) const;
  bool operator<(const NoexceptMoveSimpleStruct& rhs) const;

  FOLLY_ERASE ::apache::thrift::field_ref<const int64_t&> boolField_ref() const& {
    return {boolField, __isset.boolField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const int64_t&&> boolField_ref() const&& {
    return {std::move(boolField), __isset.boolField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<int64_t&> boolField_ref() & {
    return {boolField, __isset.boolField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<int64_t&&> boolField_ref() && {
    return {std::move(boolField), __isset.boolField};
  }

  int64_t get_boolField() const {
    return boolField;
  }

  int64_t& set_boolField(int64_t boolField_) {
    boolField = boolField_;
    __isset.boolField = true;
    return boolField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< NoexceptMoveSimpleStruct >;
};

void swap(NoexceptMoveSimpleStruct& a, NoexceptMoveSimpleStruct& b);

template <class Protocol_>
uint32_t NoexceptMoveSimpleStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class NoexceptMoveComplexStruct final : private apache::thrift::detail::st::ComparisonOperators<NoexceptMoveComplexStruct> {
 public:

  NoexceptMoveComplexStruct();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  NoexceptMoveComplexStruct(apache::thrift::FragileConstructor, bool MyBoolField__arg, int64_t MyIntField__arg, ::std::string MyStringField__arg, ::std::string MyStringField2__arg, ::std::string MyBinaryField__arg, ::std::string MyBinaryField2__arg, ::std::string MyBinaryField3__arg, ::std::vector<::std::string> MyBinaryListField4__arg, ::std::map< ::apache::thrift::fixtures::types::MyEnumA, ::std::string> MyMapEnumAndInt__arg);
  NoexceptMoveComplexStruct(NoexceptMoveComplexStruct&& other) noexcept;

  NoexceptMoveComplexStruct(const NoexceptMoveComplexStruct&) = default;

  NoexceptMoveComplexStruct& operator=(NoexceptMoveComplexStruct&&) noexcept = default;

  NoexceptMoveComplexStruct& operator=(const NoexceptMoveComplexStruct&) = default;
  void __clear();

  ~NoexceptMoveComplexStruct();

 public:
  bool MyBoolField;
 public:
  int64_t MyIntField;
 public:
  ::std::string MyStringField;
 public:
  ::std::string MyStringField2;
 public:
  ::std::string MyBinaryField;
 private:
  ::std::string MyBinaryField2;
 public:
  ::std::string MyBinaryField3;
 public:
  ::std::vector<::std::string> MyBinaryListField4;
 public:
  ::std::map< ::apache::thrift::fixtures::types::MyEnumA, ::std::string> MyMapEnumAndInt;

 public:
  struct __isset {
    bool MyBoolField;
    bool MyIntField;
    bool MyStringField;
    bool MyStringField2;
    bool MyBinaryField;
    bool MyBinaryField2;
    bool MyBinaryListField4;
    bool MyMapEnumAndInt;
  } __isset = {};
  bool operator==(const NoexceptMoveComplexStruct& rhs) const;
  bool operator<(const NoexceptMoveComplexStruct& rhs) const;

  FOLLY_ERASE ::apache::thrift::field_ref<const bool&> MyBoolField_ref() const& {
    return {MyBoolField, __isset.MyBoolField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const bool&&> MyBoolField_ref() const&& {
    return {std::move(MyBoolField), __isset.MyBoolField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<bool&> MyBoolField_ref() & {
    return {MyBoolField, __isset.MyBoolField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<bool&&> MyBoolField_ref() && {
    return {std::move(MyBoolField), __isset.MyBoolField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const int64_t&> MyIntField_ref() const& {
    return {MyIntField, __isset.MyIntField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const int64_t&&> MyIntField_ref() const&& {
    return {std::move(MyIntField), __isset.MyIntField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<int64_t&> MyIntField_ref() & {
    return {MyIntField, __isset.MyIntField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<int64_t&&> MyIntField_ref() && {
    return {std::move(MyIntField), __isset.MyIntField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::string&> MyStringField_ref() const& {
    return {MyStringField, __isset.MyStringField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::string&&> MyStringField_ref() const&& {
    return {std::move(MyStringField), __isset.MyStringField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::string&> MyStringField_ref() & {
    return {MyStringField, __isset.MyStringField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::string&&> MyStringField_ref() && {
    return {std::move(MyStringField), __isset.MyStringField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::string&> MyStringField2_ref() const& {
    return {MyStringField2, __isset.MyStringField2};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::string&&> MyStringField2_ref() const&& {
    return {std::move(MyStringField2), __isset.MyStringField2};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::string&> MyStringField2_ref() & {
    return {MyStringField2, __isset.MyStringField2};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::string&&> MyStringField2_ref() && {
    return {std::move(MyStringField2), __isset.MyStringField2};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::string&> MyBinaryField_ref() const& {
    return {MyBinaryField, __isset.MyBinaryField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::string&&> MyBinaryField_ref() const&& {
    return {std::move(MyBinaryField), __isset.MyBinaryField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::string&> MyBinaryField_ref() & {
    return {MyBinaryField, __isset.MyBinaryField};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::string&&> MyBinaryField_ref() && {
    return {std::move(MyBinaryField), __isset.MyBinaryField};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const ::std::string&> MyBinaryField2_ref() const& {
    return {MyBinaryField2, __isset.MyBinaryField2};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const ::std::string&&> MyBinaryField2_ref() const&& {
    return {std::move(MyBinaryField2), __isset.MyBinaryField2};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<::std::string&> MyBinaryField2_ref() & {
    return {MyBinaryField2, __isset.MyBinaryField2};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<::std::string&&> MyBinaryField2_ref() && {
    return {std::move(MyBinaryField2), __isset.MyBinaryField2};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::vector<::std::string>&> MyBinaryListField4_ref() const& {
    return {MyBinaryListField4, __isset.MyBinaryListField4};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::vector<::std::string>&&> MyBinaryListField4_ref() const&& {
    return {std::move(MyBinaryListField4), __isset.MyBinaryListField4};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::vector<::std::string>&> MyBinaryListField4_ref() & {
    return {MyBinaryListField4, __isset.MyBinaryListField4};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::vector<::std::string>&&> MyBinaryListField4_ref() && {
    return {std::move(MyBinaryListField4), __isset.MyBinaryListField4};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::map< ::apache::thrift::fixtures::types::MyEnumA, ::std::string>&> MyMapEnumAndInt_ref() const& {
    return {MyMapEnumAndInt, __isset.MyMapEnumAndInt};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<const ::std::map< ::apache::thrift::fixtures::types::MyEnumA, ::std::string>&&> MyMapEnumAndInt_ref() const&& {
    return {std::move(MyMapEnumAndInt), __isset.MyMapEnumAndInt};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::map< ::apache::thrift::fixtures::types::MyEnumA, ::std::string>&> MyMapEnumAndInt_ref() & {
    return {MyMapEnumAndInt, __isset.MyMapEnumAndInt};
  }

  FOLLY_ERASE ::apache::thrift::field_ref<::std::map< ::apache::thrift::fixtures::types::MyEnumA, ::std::string>&&> MyMapEnumAndInt_ref() && {
    return {std::move(MyMapEnumAndInt), __isset.MyMapEnumAndInt};
  }

  bool get_MyBoolField() const {
    return MyBoolField;
  }

  bool& set_MyBoolField(bool MyBoolField_) {
    MyBoolField = MyBoolField_;
    __isset.MyBoolField = true;
    return MyBoolField;
  }

  int64_t get_MyIntField() const {
    return MyIntField;
  }

  int64_t& set_MyIntField(int64_t MyIntField_) {
    MyIntField = MyIntField_;
    __isset.MyIntField = true;
    return MyIntField;
  }

  const ::std::string& get_MyStringField() const& {
    return MyStringField;
  }

  ::std::string get_MyStringField() && {
    return std::move(MyStringField);
  }

  template <typename T_NoexceptMoveComplexStruct_MyStringField_struct_setter = ::std::string>
  ::std::string& set_MyStringField(T_NoexceptMoveComplexStruct_MyStringField_struct_setter&& MyStringField_) {
    MyStringField = std::forward<T_NoexceptMoveComplexStruct_MyStringField_struct_setter>(MyStringField_);
    __isset.MyStringField = true;
    return MyStringField;
  }

  const ::std::string& get_MyStringField2() const& {
    return MyStringField2;
  }

  ::std::string get_MyStringField2() && {
    return std::move(MyStringField2);
  }

  template <typename T_NoexceptMoveComplexStruct_MyStringField2_struct_setter = ::std::string>
  ::std::string& set_MyStringField2(T_NoexceptMoveComplexStruct_MyStringField2_struct_setter&& MyStringField2_) {
    MyStringField2 = std::forward<T_NoexceptMoveComplexStruct_MyStringField2_struct_setter>(MyStringField2_);
    __isset.MyStringField2 = true;
    return MyStringField2;
  }

  const ::std::string& get_MyBinaryField() const& {
    return MyBinaryField;
  }

  ::std::string get_MyBinaryField() && {
    return std::move(MyBinaryField);
  }

  template <typename T_NoexceptMoveComplexStruct_MyBinaryField_struct_setter = ::std::string>
  ::std::string& set_MyBinaryField(T_NoexceptMoveComplexStruct_MyBinaryField_struct_setter&& MyBinaryField_) {
    MyBinaryField = std::forward<T_NoexceptMoveComplexStruct_MyBinaryField_struct_setter>(MyBinaryField_);
    __isset.MyBinaryField = true;
    return MyBinaryField;
  }

  const ::std::string* get_MyBinaryField2() const& {
    return __isset.MyBinaryField2 ? std::addressof(MyBinaryField2) : nullptr;
  }

  ::std::string* get_MyBinaryField2() & {
    return __isset.MyBinaryField2 ? std::addressof(MyBinaryField2) : nullptr;
  }
  ::std::string* get_MyBinaryField2() && = delete;

  template <typename T_NoexceptMoveComplexStruct_MyBinaryField2_struct_setter = ::std::string>
  ::std::string& set_MyBinaryField2(T_NoexceptMoveComplexStruct_MyBinaryField2_struct_setter&& MyBinaryField2_) {
    MyBinaryField2 = std::forward<T_NoexceptMoveComplexStruct_MyBinaryField2_struct_setter>(MyBinaryField2_);
    __isset.MyBinaryField2 = true;
    return MyBinaryField2;
  }

  const ::std::string& get_MyBinaryField3() const& {
    return MyBinaryField3;
  }

  ::std::string get_MyBinaryField3() && {
    return std::move(MyBinaryField3);
  }

  template <typename T_NoexceptMoveComplexStruct_MyBinaryField3_struct_setter = ::std::string>
  ::std::string& set_MyBinaryField3(T_NoexceptMoveComplexStruct_MyBinaryField3_struct_setter&& MyBinaryField3_) {
    MyBinaryField3 = std::forward<T_NoexceptMoveComplexStruct_MyBinaryField3_struct_setter>(MyBinaryField3_);
    return MyBinaryField3;
  }
  const ::std::vector<::std::string>& get_MyBinaryListField4() const&;
  ::std::vector<::std::string> get_MyBinaryListField4() &&;

  template <typename T_NoexceptMoveComplexStruct_MyBinaryListField4_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_MyBinaryListField4(T_NoexceptMoveComplexStruct_MyBinaryListField4_struct_setter&& MyBinaryListField4_) {
    MyBinaryListField4 = std::forward<T_NoexceptMoveComplexStruct_MyBinaryListField4_struct_setter>(MyBinaryListField4_);
    __isset.MyBinaryListField4 = true;
    return MyBinaryListField4;
  }
  const ::std::map< ::apache::thrift::fixtures::types::MyEnumA, ::std::string>& get_MyMapEnumAndInt() const&;
  ::std::map< ::apache::thrift::fixtures::types::MyEnumA, ::std::string> get_MyMapEnumAndInt() &&;

  template <typename T_NoexceptMoveComplexStruct_MyMapEnumAndInt_struct_setter = ::std::map< ::apache::thrift::fixtures::types::MyEnumA, ::std::string>>
  ::std::map< ::apache::thrift::fixtures::types::MyEnumA, ::std::string>& set_MyMapEnumAndInt(T_NoexceptMoveComplexStruct_MyMapEnumAndInt_struct_setter&& MyMapEnumAndInt_) {
    MyMapEnumAndInt = std::forward<T_NoexceptMoveComplexStruct_MyMapEnumAndInt_struct_setter>(MyMapEnumAndInt_);
    __isset.MyMapEnumAndInt = true;
    return MyMapEnumAndInt;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< NoexceptMoveComplexStruct >;
};

void swap(NoexceptMoveComplexStruct& a, NoexceptMoveComplexStruct& b);

template <class Protocol_>
uint32_t NoexceptMoveComplexStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift { namespace fixtures { namespace types {
class NoExceptMoveUnion final : private apache::thrift::detail::st::ComparisonOperators<NoExceptMoveUnion> {
 public:
  enum Type : int {
    __EMPTY__ = 0,
    string_field = 1,
    i32_field = 2,
  } ;

  NoExceptMoveUnion()
      : type_(Type::__EMPTY__) {}

  NoExceptMoveUnion(NoExceptMoveUnion&& rhs) noexcept
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::string_field:
      {
        set_string_field(std::move(rhs.value_.string_field));
        break;
      }
      case Type::i32_field:
      {
        set_i32_field(std::move(rhs.value_.i32_field));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  NoExceptMoveUnion(const NoExceptMoveUnion& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::string_field:
      {
        set_string_field(rhs.value_.string_field);
        break;
      }
      case Type::i32_field:
      {
        set_i32_field(rhs.value_.i32_field);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  NoExceptMoveUnion& operator=(NoExceptMoveUnion&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::string_field:
      {
        set_string_field(std::move(rhs.value_.string_field));
        break;
      }
      case Type::i32_field:
      {
        set_i32_field(std::move(rhs.value_.i32_field));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  NoExceptMoveUnion& operator=(const NoExceptMoveUnion& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::string_field:
      {
        set_string_field(rhs.value_.string_field);
        break;
      }
      case Type::i32_field:
      {
        set_i32_field(rhs.value_.i32_field);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~NoExceptMoveUnion() {
    __clear();
  }
  union storage_type {
    ::std::string string_field;
    int32_t i32_field;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const NoExceptMoveUnion& rhs) const;
  bool operator<(const NoExceptMoveUnion& rhs) const;

  ::std::string& set_string_field(::std::string const &t) {
    __clear();
    type_ = Type::string_field;
    ::new (std::addressof(value_.string_field)) ::std::string(t);
    return value_.string_field;
  }

  ::std::string& set_string_field(::std::string&& t) {
    __clear();
    type_ = Type::string_field;
    ::new (std::addressof(value_.string_field)) ::std::string(std::move(t));
    return value_.string_field;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_string_field(T&&... t) {
    __clear();
    type_ = Type::string_field;
    ::new (std::addressof(value_.string_field)) ::std::string(std::forward<T>(t)...);
    return value_.string_field;
  }

  int32_t& set_i32_field(int32_t t = int32_t()) {
    __clear();
    type_ = Type::i32_field;
    ::new (std::addressof(value_.i32_field)) int32_t(t);
    return value_.i32_field;
  }

  ::std::string const & get_string_field() const {
    assert(type_ == Type::string_field);
    return value_.string_field;
  }

  int32_t const & get_i32_field() const {
    assert(type_ == Type::i32_field);
    return value_.i32_field;
  }

  ::std::string & mutable_string_field() {
    assert(type_ == Type::string_field);
    return value_.string_field;
  }

  int32_t & mutable_i32_field() {
    assert(type_ == Type::i32_field);
    return value_.i32_field;
  }

  ::std::string move_string_field() {
    assert(type_ == Type::string_field);
    return std::move(value_.string_field);
  }

  int32_t move_i32_field() {
    assert(type_ == Type::i32_field);
    return std::move(value_.i32_field);
  }

  Type getType() const { return type_; }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  Type type_;
  storage_type value_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< NoExceptMoveUnion >;
};

void swap(NoExceptMoveUnion& a, NoExceptMoveUnion& b);

template <class Protocol_>
uint32_t NoExceptMoveUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
