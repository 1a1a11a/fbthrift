/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/GeneratedHeaderHelper.h>
#include <thrift/lib/cpp2/Thrift.h>
#include <thrift/lib/cpp2/gen/module_types_h.h>
#include <thrift/lib/cpp2/protocol/Protocol.h>

#include "thrift/compiler/test/fixtures/types/gen-cpp2/include_types.h"

// BEGIN declare_enums
namespace apache { namespace thrift { namespace fixtures { namespace types {

enum class has_bitwise_ops {
  none = 0,
  zero = 1,
  one = 2,
  two = 4,
  three = 8
};

using _has_bitwise_ops_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<has_bitwise_ops, has_bitwise_ops>;
extern const _has_bitwise_ops_EnumMapFactory::ValuesToNamesMapType _has_bitwise_ops_VALUES_TO_NAMES;
extern const _has_bitwise_ops_EnumMapFactory::NamesToValuesMapType _has_bitwise_ops_NAMES_TO_VALUES;

inline constexpr has_bitwise_ops operator&(has_bitwise_ops a, has_bitwise_ops b) {
  using E = has_bitwise_ops;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) & static_cast<U>(b));
}
inline constexpr has_bitwise_ops& operator&=(has_bitwise_ops& a, has_bitwise_ops b) {
  return a = a & b;
}

inline constexpr has_bitwise_ops operator|(has_bitwise_ops a, has_bitwise_ops b) {
  using E = has_bitwise_ops;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) | static_cast<U>(b));
}
inline constexpr has_bitwise_ops& operator|=(has_bitwise_ops& a, has_bitwise_ops b) {
  return a = a | b;
}

inline constexpr has_bitwise_ops operator^(has_bitwise_ops a, has_bitwise_ops b) {
  using E = has_bitwise_ops;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) ^ static_cast<U>(b));
}
inline constexpr has_bitwise_ops& operator^=(has_bitwise_ops& a, has_bitwise_ops b) {
  return a = a ^ b;
}

inline constexpr has_bitwise_ops operator~(has_bitwise_ops a) {
  using E = has_bitwise_ops;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(~static_cast<U>(a));
}

enum is_unscoped : int {
  hello = 0,
  world = 1
};

using _is_unscoped_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<is_unscoped, is_unscoped>;
extern const _is_unscoped_EnumMapFactory::ValuesToNamesMapType _is_unscoped_VALUES_TO_NAMES;
extern const _is_unscoped_EnumMapFactory::NamesToValuesMapType _is_unscoped_NAMES_TO_VALUES;



enum class MyForwardRefEnum {
  ZERO = 0,
  NONZERO = 12
};

using _MyForwardRefEnum_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<MyForwardRefEnum, MyForwardRefEnum>;
extern const _MyForwardRefEnum_EnumMapFactory::ValuesToNamesMapType _MyForwardRefEnum_VALUES_TO_NAMES;
extern const _MyForwardRefEnum_EnumMapFactory::NamesToValuesMapType _MyForwardRefEnum_NAMES_TO_VALUES;



}}}} // apache::thrift::fixtures::types
namespace std {


template<> struct hash<typename  ::apache::thrift::fixtures::types::has_bitwise_ops> : public apache::thrift::detail::enum_hash<typename  ::apache::thrift::fixtures::types::has_bitwise_ops> {};
template<> struct equal_to<typename  ::apache::thrift::fixtures::types::has_bitwise_ops> : public apache::thrift::detail::enum_equal_to<typename  ::apache::thrift::fixtures::types::has_bitwise_ops> {};


template<> struct hash<typename  ::apache::thrift::fixtures::types::is_unscoped> : public apache::thrift::detail::enum_hash<typename  ::apache::thrift::fixtures::types::is_unscoped> {};
template<> struct equal_to<typename  ::apache::thrift::fixtures::types::is_unscoped> : public apache::thrift::detail::enum_equal_to<typename  ::apache::thrift::fixtures::types::is_unscoped> {};


template<> struct hash<typename  ::apache::thrift::fixtures::types::MyForwardRefEnum> : public apache::thrift::detail::enum_hash<typename  ::apache::thrift::fixtures::types::MyForwardRefEnum> {};
template<> struct equal_to<typename  ::apache::thrift::fixtures::types::MyForwardRefEnum> : public apache::thrift::detail::enum_equal_to<typename  ::apache::thrift::fixtures::types::MyForwardRefEnum> {};


} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage< ::apache::thrift::fixtures::types::has_bitwise_ops>;
#ifndef _MSC_VER
template <> const std::size_t TEnumTraits< ::apache::thrift::fixtures::types::has_bitwise_ops>::size;
template <> const folly::Range<const  ::apache::thrift::fixtures::types::has_bitwise_ops*> TEnumTraits< ::apache::thrift::fixtures::types::has_bitwise_ops>::values;
template <> const folly::Range<const folly::StringPiece*> TEnumTraits< ::apache::thrift::fixtures::types::has_bitwise_ops>::names;
#endif
template <> const char* TEnumTraits< ::apache::thrift::fixtures::types::has_bitwise_ops>::findName( ::apache::thrift::fixtures::types::has_bitwise_ops value);
template <> bool TEnumTraits< ::apache::thrift::fixtures::types::has_bitwise_ops>::findValue(const char* name,  ::apache::thrift::fixtures::types::has_bitwise_ops* outValue);

template <> inline constexpr  ::apache::thrift::fixtures::types::has_bitwise_ops TEnumTraits< ::apache::thrift::fixtures::types::has_bitwise_ops>::min() {
  return  ::apache::thrift::fixtures::types::has_bitwise_ops::none;
}

template <> inline constexpr  ::apache::thrift::fixtures::types::has_bitwise_ops TEnumTraits< ::apache::thrift::fixtures::types::has_bitwise_ops>::max() {
  return  ::apache::thrift::fixtures::types::has_bitwise_ops::three;
}


template <> struct TEnumDataStorage< ::apache::thrift::fixtures::types::is_unscoped>;
#ifndef _MSC_VER
template <> const std::size_t TEnumTraits< ::apache::thrift::fixtures::types::is_unscoped>::size;
template <> const folly::Range<const  ::apache::thrift::fixtures::types::is_unscoped*> TEnumTraits< ::apache::thrift::fixtures::types::is_unscoped>::values;
template <> const folly::Range<const folly::StringPiece*> TEnumTraits< ::apache::thrift::fixtures::types::is_unscoped>::names;
#endif
template <> const char* TEnumTraits< ::apache::thrift::fixtures::types::is_unscoped>::findName( ::apache::thrift::fixtures::types::is_unscoped value);
template <> bool TEnumTraits< ::apache::thrift::fixtures::types::is_unscoped>::findValue(const char* name,  ::apache::thrift::fixtures::types::is_unscoped* outValue);

template <> inline constexpr  ::apache::thrift::fixtures::types::is_unscoped TEnumTraits< ::apache::thrift::fixtures::types::is_unscoped>::min() {
  return  ::apache::thrift::fixtures::types::is_unscoped::hello;
}

template <> inline constexpr  ::apache::thrift::fixtures::types::is_unscoped TEnumTraits< ::apache::thrift::fixtures::types::is_unscoped>::max() {
  return  ::apache::thrift::fixtures::types::is_unscoped::world;
}


template <> struct TEnumDataStorage< ::apache::thrift::fixtures::types::MyForwardRefEnum>;
#ifndef _MSC_VER
template <> const std::size_t TEnumTraits< ::apache::thrift::fixtures::types::MyForwardRefEnum>::size;
template <> const folly::Range<const  ::apache::thrift::fixtures::types::MyForwardRefEnum*> TEnumTraits< ::apache::thrift::fixtures::types::MyForwardRefEnum>::values;
template <> const folly::Range<const folly::StringPiece*> TEnumTraits< ::apache::thrift::fixtures::types::MyForwardRefEnum>::names;
#endif
template <> const char* TEnumTraits< ::apache::thrift::fixtures::types::MyForwardRefEnum>::findName( ::apache::thrift::fixtures::types::MyForwardRefEnum value);
template <> bool TEnumTraits< ::apache::thrift::fixtures::types::MyForwardRefEnum>::findValue(const char* name,  ::apache::thrift::fixtures::types::MyForwardRefEnum* outValue);

template <> inline constexpr  ::apache::thrift::fixtures::types::MyForwardRefEnum TEnumTraits< ::apache::thrift::fixtures::types::MyForwardRefEnum>::min() {
  return  ::apache::thrift::fixtures::types::MyForwardRefEnum::ZERO;
}

template <> inline constexpr  ::apache::thrift::fixtures::types::MyForwardRefEnum TEnumTraits< ::apache::thrift::fixtures::types::MyForwardRefEnum>::max() {
  return  ::apache::thrift::fixtures::types::MyForwardRefEnum::NONZERO;
}


}} // apache::thrift


// END declare_enums
// BEGIN struct_indirection

// END struct_indirection
// BEGIN forward_declare
namespace apache { namespace thrift { namespace fixtures { namespace types {
class decorated_struct;
class ContainerStruct;
class CppTypeStruct;
class VirtualStruct;
class MyStructWithForwardRefEnum;
class TrivialNumeric;
class TrivialNestedWithDefault;
class ComplexString;
class ComplexNestedWithDefault;
class MinPadding;
}}}} // apache::thrift::fixtures::types
// END forward_declare
// BEGIN typedefs
namespace apache { namespace thrift { namespace fixtures { namespace types {
typedef std::string TBinary;

}}}} // apache::thrift::fixtures::types
// END typedefs
// BEGIN hash_and_equal_to
namespace std {

template<> struct hash<typename  ::apache::thrift::fixtures::types::decorated_struct> {
  size_t operator()(const  ::apache::thrift::fixtures::types::decorated_struct&) const;
};
template<> struct equal_to<typename  ::apache::thrift::fixtures::types::decorated_struct> {
  bool operator()(const  ::apache::thrift::fixtures::types::decorated_struct&,const  ::apache::thrift::fixtures::types::decorated_struct&) const;
};
} // std
// END hash_and_equal_to
namespace apache { namespace thrift { namespace fixtures { namespace types {
class decorated_struct final : private apache::thrift::detail::st::ComparisonOperators<decorated_struct> {
 public:

  decorated_struct() {}
  // FragileConstructor for use in initialization lists only.
  decorated_struct(apache::thrift::FragileConstructor, std::string field__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    field = arg.extract();
    __isset.field = true;
  }

  decorated_struct(decorated_struct&&) = default;

  decorated_struct(const decorated_struct&) = default;

  decorated_struct& operator=(decorated_struct&&) = default;

  decorated_struct& operator=(const decorated_struct&) = default;
  void __clear();
  std::string field;

  struct __isset {
    bool field;
  } __isset = {};
  bool operator==(const decorated_struct& rhs) const;
  bool operator<(const decorated_struct& rhs) const;

  const std::string& get_field() const& {
    return field;
  }

  std::string get_field() && {
    return std::move(field);
  }

  template <typename T_decorated_struct_field_struct_setter = std::string>
  std::string& set_field(T_decorated_struct_field_struct_setter&& field_) {
    field = std::forward<T_decorated_struct_field_struct_setter>(field_);
    __isset.field = true;
    return field;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< decorated_struct >;
};

void swap(decorated_struct& a, decorated_struct& b);
extern template void decorated_struct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t decorated_struct::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t decorated_struct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t decorated_struct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void decorated_struct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t decorated_struct::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t decorated_struct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t decorated_struct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t decorated_struct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::apache::thrift::fixtures::types::decorated_struct>::clear( ::apache::thrift::fixtures::types::decorated_struct* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::apache::thrift::fixtures::types::decorated_struct>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::decorated_struct>::write(Protocol* proto,  ::apache::thrift::fixtures::types::decorated_struct const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::apache::thrift::fixtures::types::decorated_struct>::read(Protocol* proto,  ::apache::thrift::fixtures::types::decorated_struct* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::decorated_struct>::serializedSize(Protocol const* proto,  ::apache::thrift::fixtures::types::decorated_struct const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::decorated_struct>::serializedSizeZC(Protocol const* proto,  ::apache::thrift::fixtures::types::decorated_struct const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace apache { namespace thrift { namespace fixtures { namespace types {
class ContainerStruct final : private apache::thrift::detail::st::ComparisonOperators<ContainerStruct> {
 public:

  ContainerStruct();

  // FragileConstructor for use in initialization lists only.
  ContainerStruct(apache::thrift::FragileConstructor, std::vector<int32_t> fieldA__arg, std::list<int32_t> fieldB__arg, std::deque<int32_t> fieldC__arg, folly::fbvector<int32_t> fieldD__arg, folly::small_vector<int32_t> fieldE__arg, folly::sorted_vector_set<int32_t> fieldF__arg, folly::sorted_vector_map<int32_t, std::string> fieldG__arg,  ::apache::thrift::fixtures::types::SomeMap fieldH__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<12, _T> arg) {
    fieldA = arg.extract();
    __isset.fieldA = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    fieldB = arg.extract();
    __isset.fieldB = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<3, _T> arg) {
    fieldC = arg.extract();
    __isset.fieldC = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<4, _T> arg) {
    fieldD = arg.extract();
    __isset.fieldD = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<5, _T> arg) {
    fieldE = arg.extract();
    __isset.fieldE = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<6, _T> arg) {
    fieldF = arg.extract();
    __isset.fieldF = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<7, _T> arg) {
    fieldG = arg.extract();
    __isset.fieldG = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<8, _T> arg) {
    fieldH = arg.extract();
    __isset.fieldH = true;
  }

  ContainerStruct(ContainerStruct&&) = default;

  ContainerStruct(const ContainerStruct&) = default;

  ContainerStruct& operator=(ContainerStruct&&) = default;

  ContainerStruct& operator=(const ContainerStruct&) = default;
  void __clear();

  ~ContainerStruct();

  std::vector<int32_t> fieldA;
  std::list<int32_t> fieldB;
  std::deque<int32_t> fieldC;
  folly::fbvector<int32_t> fieldD;
  folly::small_vector<int32_t> fieldE;
  folly::sorted_vector_set<int32_t> fieldF;
  folly::sorted_vector_map<int32_t, std::string> fieldG;
   ::apache::thrift::fixtures::types::SomeMap fieldH;

  struct __isset {
    bool fieldA;
    bool fieldB;
    bool fieldC;
    bool fieldD;
    bool fieldE;
    bool fieldF;
    bool fieldG;
    bool fieldH;
  } __isset = {};
  bool operator==(const ContainerStruct& rhs) const;
  bool operator<(const ContainerStruct& rhs) const;
  const std::vector<int32_t>& get_fieldA() const&;
  std::vector<int32_t> get_fieldA() &&;

  template <typename T_ContainerStruct_fieldA_struct_setter = std::vector<int32_t>>
  std::vector<int32_t>& set_fieldA(T_ContainerStruct_fieldA_struct_setter&& fieldA_) {
    fieldA = std::forward<T_ContainerStruct_fieldA_struct_setter>(fieldA_);
    __isset.fieldA = true;
    return fieldA;
  }
  const std::list<int32_t>& get_fieldB() const&;
  std::list<int32_t> get_fieldB() &&;

  template <typename T_ContainerStruct_fieldB_struct_setter = std::list<int32_t>>
  std::list<int32_t>& set_fieldB(T_ContainerStruct_fieldB_struct_setter&& fieldB_) {
    fieldB = std::forward<T_ContainerStruct_fieldB_struct_setter>(fieldB_);
    __isset.fieldB = true;
    return fieldB;
  }
  const std::deque<int32_t>& get_fieldC() const&;
  std::deque<int32_t> get_fieldC() &&;

  template <typename T_ContainerStruct_fieldC_struct_setter = std::deque<int32_t>>
  std::deque<int32_t>& set_fieldC(T_ContainerStruct_fieldC_struct_setter&& fieldC_) {
    fieldC = std::forward<T_ContainerStruct_fieldC_struct_setter>(fieldC_);
    __isset.fieldC = true;
    return fieldC;
  }
  const folly::fbvector<int32_t>& get_fieldD() const&;
  folly::fbvector<int32_t> get_fieldD() &&;

  template <typename T_ContainerStruct_fieldD_struct_setter = folly::fbvector<int32_t>>
  folly::fbvector<int32_t>& set_fieldD(T_ContainerStruct_fieldD_struct_setter&& fieldD_) {
    fieldD = std::forward<T_ContainerStruct_fieldD_struct_setter>(fieldD_);
    __isset.fieldD = true;
    return fieldD;
  }
  const folly::small_vector<int32_t>& get_fieldE() const&;
  folly::small_vector<int32_t> get_fieldE() &&;

  template <typename T_ContainerStruct_fieldE_struct_setter = folly::small_vector<int32_t>>
  folly::small_vector<int32_t>& set_fieldE(T_ContainerStruct_fieldE_struct_setter&& fieldE_) {
    fieldE = std::forward<T_ContainerStruct_fieldE_struct_setter>(fieldE_);
    __isset.fieldE = true;
    return fieldE;
  }
  const folly::sorted_vector_set<int32_t>& get_fieldF() const&;
  folly::sorted_vector_set<int32_t> get_fieldF() &&;

  template <typename T_ContainerStruct_fieldF_struct_setter = folly::sorted_vector_set<int32_t>>
  folly::sorted_vector_set<int32_t>& set_fieldF(T_ContainerStruct_fieldF_struct_setter&& fieldF_) {
    fieldF = std::forward<T_ContainerStruct_fieldF_struct_setter>(fieldF_);
    __isset.fieldF = true;
    return fieldF;
  }
  const folly::sorted_vector_map<int32_t, std::string>& get_fieldG() const&;
  folly::sorted_vector_map<int32_t, std::string> get_fieldG() &&;

  template <typename T_ContainerStruct_fieldG_struct_setter = folly::sorted_vector_map<int32_t, std::string>>
  folly::sorted_vector_map<int32_t, std::string>& set_fieldG(T_ContainerStruct_fieldG_struct_setter&& fieldG_) {
    fieldG = std::forward<T_ContainerStruct_fieldG_struct_setter>(fieldG_);
    __isset.fieldG = true;
    return fieldG;
  }
  const  ::apache::thrift::fixtures::types::SomeMap& get_fieldH() const&;
   ::apache::thrift::fixtures::types::SomeMap get_fieldH() &&;

  template <typename T_ContainerStruct_fieldH_struct_setter =  ::apache::thrift::fixtures::types::SomeMap>
   ::apache::thrift::fixtures::types::SomeMap& set_fieldH(T_ContainerStruct_fieldH_struct_setter&& fieldH_) {
    fieldH = std::forward<T_ContainerStruct_fieldH_struct_setter>(fieldH_);
    __isset.fieldH = true;
    return fieldH;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ContainerStruct >;
};

void swap(ContainerStruct& a, ContainerStruct& b);
extern template void ContainerStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t ContainerStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t ContainerStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t ContainerStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void ContainerStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t ContainerStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t ContainerStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t ContainerStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t ContainerStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::apache::thrift::fixtures::types::ContainerStruct>::clear( ::apache::thrift::fixtures::types::ContainerStruct* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::apache::thrift::fixtures::types::ContainerStruct>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::ContainerStruct>::write(Protocol* proto,  ::apache::thrift::fixtures::types::ContainerStruct const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::apache::thrift::fixtures::types::ContainerStruct>::read(Protocol* proto,  ::apache::thrift::fixtures::types::ContainerStruct* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::ContainerStruct>::serializedSize(Protocol const* proto,  ::apache::thrift::fixtures::types::ContainerStruct const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::ContainerStruct>::serializedSizeZC(Protocol const* proto,  ::apache::thrift::fixtures::types::ContainerStruct const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace apache { namespace thrift { namespace fixtures { namespace types {
class CppTypeStruct final : private apache::thrift::detail::st::ComparisonOperators<CppTypeStruct> {
 public:

  CppTypeStruct() {}
  // FragileConstructor for use in initialization lists only.
  CppTypeStruct(apache::thrift::FragileConstructor, std::list<int32_t> fieldA__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    fieldA = arg.extract();
    __isset.fieldA = true;
  }

  CppTypeStruct(CppTypeStruct&&) = default;

  CppTypeStruct(const CppTypeStruct&) = default;

  CppTypeStruct& operator=(CppTypeStruct&&) = default;

  CppTypeStruct& operator=(const CppTypeStruct&) = default;
  void __clear();
  std::list<int32_t> fieldA;

  struct __isset {
    bool fieldA;
  } __isset = {};
  bool operator==(const CppTypeStruct& rhs) const;
  bool operator<(const CppTypeStruct& rhs) const;
  const std::list<int32_t>& get_fieldA() const&;
  std::list<int32_t> get_fieldA() &&;

  template <typename T_CppTypeStruct_fieldA_struct_setter = std::list<int32_t>>
  std::list<int32_t>& set_fieldA(T_CppTypeStruct_fieldA_struct_setter&& fieldA_) {
    fieldA = std::forward<T_CppTypeStruct_fieldA_struct_setter>(fieldA_);
    __isset.fieldA = true;
    return fieldA;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CppTypeStruct >;
};

void swap(CppTypeStruct& a, CppTypeStruct& b);
extern template void CppTypeStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t CppTypeStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t CppTypeStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t CppTypeStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void CppTypeStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t CppTypeStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t CppTypeStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t CppTypeStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t CppTypeStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::apache::thrift::fixtures::types::CppTypeStruct>::clear( ::apache::thrift::fixtures::types::CppTypeStruct* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::apache::thrift::fixtures::types::CppTypeStruct>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::CppTypeStruct>::write(Protocol* proto,  ::apache::thrift::fixtures::types::CppTypeStruct const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::apache::thrift::fixtures::types::CppTypeStruct>::read(Protocol* proto,  ::apache::thrift::fixtures::types::CppTypeStruct* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::CppTypeStruct>::serializedSize(Protocol const* proto,  ::apache::thrift::fixtures::types::CppTypeStruct const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::CppTypeStruct>::serializedSizeZC(Protocol const* proto,  ::apache::thrift::fixtures::types::CppTypeStruct const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace apache { namespace thrift { namespace fixtures { namespace types {
class VirtualStruct : private apache::thrift::detail::st::ComparisonOperators<VirtualStruct> {
 public:

  VirtualStruct() :
      MyIntField(0) {}
  // FragileConstructor for use in initialization lists only.
  VirtualStruct(apache::thrift::FragileConstructor, int64_t MyIntField__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    MyIntField = arg.extract();
    __isset.MyIntField = true;
  }

  VirtualStruct(VirtualStruct&&) = default;

  VirtualStruct(const VirtualStruct&) = default;

  VirtualStruct& operator=(VirtualStruct&&) = default;

  VirtualStruct& operator=(const VirtualStruct&) = default;
  void __clear();

  virtual ~VirtualStruct() {}

  int64_t MyIntField;

  struct __isset {
    bool MyIntField;
  } __isset = {};
  bool operator==(const VirtualStruct& rhs) const;
  bool operator<(const VirtualStruct& rhs) const;

  int64_t get_MyIntField() const {
    return MyIntField;
  }

  int64_t& set_MyIntField(int64_t MyIntField_) {
    MyIntField = MyIntField_;
    __isset.MyIntField = true;
    return MyIntField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< VirtualStruct >;
};

void swap(VirtualStruct& a, VirtualStruct& b);
extern template void VirtualStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t VirtualStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t VirtualStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t VirtualStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void VirtualStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t VirtualStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t VirtualStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t VirtualStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t VirtualStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::apache::thrift::fixtures::types::VirtualStruct>::clear( ::apache::thrift::fixtures::types::VirtualStruct* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::apache::thrift::fixtures::types::VirtualStruct>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::VirtualStruct>::write(Protocol* proto,  ::apache::thrift::fixtures::types::VirtualStruct const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::apache::thrift::fixtures::types::VirtualStruct>::read(Protocol* proto,  ::apache::thrift::fixtures::types::VirtualStruct* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::VirtualStruct>::serializedSize(Protocol const* proto,  ::apache::thrift::fixtures::types::VirtualStruct const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::VirtualStruct>::serializedSizeZC(Protocol const* proto,  ::apache::thrift::fixtures::types::VirtualStruct const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace apache { namespace thrift { namespace fixtures { namespace types {
class MyStructWithForwardRefEnum final : private apache::thrift::detail::st::ComparisonOperators<MyStructWithForwardRefEnum> {
 public:

  MyStructWithForwardRefEnum() :
      a( ::apache::thrift::fixtures::types::MyForwardRefEnum::NONZERO),
      b( ::apache::thrift::fixtures::types::MyForwardRefEnum::NONZERO) {}
  // FragileConstructor for use in initialization lists only.
  MyStructWithForwardRefEnum(apache::thrift::FragileConstructor,  ::apache::thrift::fixtures::types::MyForwardRefEnum a__arg,  ::apache::thrift::fixtures::types::MyForwardRefEnum b__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    a = arg.extract();
    __isset.a = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    b = arg.extract();
    __isset.b = true;
  }

  MyStructWithForwardRefEnum(MyStructWithForwardRefEnum&&) = default;

  MyStructWithForwardRefEnum(const MyStructWithForwardRefEnum&) = default;

  MyStructWithForwardRefEnum& operator=(MyStructWithForwardRefEnum&&) = default;

  MyStructWithForwardRefEnum& operator=(const MyStructWithForwardRefEnum&) = default;
  void __clear();
   ::apache::thrift::fixtures::types::MyForwardRefEnum a;
   ::apache::thrift::fixtures::types::MyForwardRefEnum b;

  struct __isset {
    bool a;
    bool b;
  } __isset = {};
  bool operator==(const MyStructWithForwardRefEnum& rhs) const;
  bool operator<(const MyStructWithForwardRefEnum& rhs) const;

   ::apache::thrift::fixtures::types::MyForwardRefEnum get_a() const {
    return a;
  }

   ::apache::thrift::fixtures::types::MyForwardRefEnum& set_a( ::apache::thrift::fixtures::types::MyForwardRefEnum a_) {
    a = a_;
    __isset.a = true;
    return a;
  }

   ::apache::thrift::fixtures::types::MyForwardRefEnum get_b() const {
    return b;
  }

   ::apache::thrift::fixtures::types::MyForwardRefEnum& set_b( ::apache::thrift::fixtures::types::MyForwardRefEnum b_) {
    b = b_;
    __isset.b = true;
    return b;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< MyStructWithForwardRefEnum >;
};

void swap(MyStructWithForwardRefEnum& a, MyStructWithForwardRefEnum& b);
extern template void MyStructWithForwardRefEnum::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t MyStructWithForwardRefEnum::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t MyStructWithForwardRefEnum::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t MyStructWithForwardRefEnum::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void MyStructWithForwardRefEnum::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t MyStructWithForwardRefEnum::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t MyStructWithForwardRefEnum::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t MyStructWithForwardRefEnum::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t MyStructWithForwardRefEnum::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::apache::thrift::fixtures::types::MyStructWithForwardRefEnum>::clear( ::apache::thrift::fixtures::types::MyStructWithForwardRefEnum* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::apache::thrift::fixtures::types::MyStructWithForwardRefEnum>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::MyStructWithForwardRefEnum>::write(Protocol* proto,  ::apache::thrift::fixtures::types::MyStructWithForwardRefEnum const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::apache::thrift::fixtures::types::MyStructWithForwardRefEnum>::read(Protocol* proto,  ::apache::thrift::fixtures::types::MyStructWithForwardRefEnum* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::MyStructWithForwardRefEnum>::serializedSize(Protocol const* proto,  ::apache::thrift::fixtures::types::MyStructWithForwardRefEnum const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::MyStructWithForwardRefEnum>::serializedSizeZC(Protocol const* proto,  ::apache::thrift::fixtures::types::MyStructWithForwardRefEnum const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace apache { namespace thrift { namespace fixtures { namespace types {
class TrivialNumeric final : private apache::thrift::detail::st::ComparisonOperators<TrivialNumeric> {
 public:

  TrivialNumeric() :
      a(0),
      b(0) {}
  // FragileConstructor for use in initialization lists only.
  TrivialNumeric(apache::thrift::FragileConstructor, int32_t a__arg, bool b__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    a = arg.extract();
    __isset.a = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    b = arg.extract();
    __isset.b = true;
  }

  TrivialNumeric(TrivialNumeric&&) = default;

  TrivialNumeric(const TrivialNumeric&) = default;

  TrivialNumeric& operator=(TrivialNumeric&&) = default;

  TrivialNumeric& operator=(const TrivialNumeric&) = default;
  void __clear();
  int32_t a;
  bool b;

  struct __isset {
    bool a;
    bool b;
  } __isset = {};
  bool operator==(const TrivialNumeric& rhs) const;
  bool operator<(const TrivialNumeric& rhs) const;

  int32_t get_a() const {
    return a;
  }

  int32_t& set_a(int32_t a_) {
    a = a_;
    __isset.a = true;
    return a;
  }

  bool get_b() const {
    return b;
  }

  bool& set_b(bool b_) {
    b = b_;
    __isset.b = true;
    return b;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< TrivialNumeric >;
};

void swap(TrivialNumeric& a, TrivialNumeric& b);
extern template void TrivialNumeric::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t TrivialNumeric::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t TrivialNumeric::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t TrivialNumeric::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void TrivialNumeric::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t TrivialNumeric::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t TrivialNumeric::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t TrivialNumeric::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t TrivialNumeric::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::apache::thrift::fixtures::types::TrivialNumeric>::clear( ::apache::thrift::fixtures::types::TrivialNumeric* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::apache::thrift::fixtures::types::TrivialNumeric>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::TrivialNumeric>::write(Protocol* proto,  ::apache::thrift::fixtures::types::TrivialNumeric const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::apache::thrift::fixtures::types::TrivialNumeric>::read(Protocol* proto,  ::apache::thrift::fixtures::types::TrivialNumeric* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::TrivialNumeric>::serializedSize(Protocol const* proto,  ::apache::thrift::fixtures::types::TrivialNumeric const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::TrivialNumeric>::serializedSizeZC(Protocol const* proto,  ::apache::thrift::fixtures::types::TrivialNumeric const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace apache { namespace thrift { namespace fixtures { namespace types {
class TrivialNestedWithDefault final : private apache::thrift::detail::st::ComparisonOperators<TrivialNestedWithDefault> {
 public:

  TrivialNestedWithDefault() :
      z(4),
      n(::apache::thrift::detail::make_constant< ::apache::thrift::fixtures::types::TrivialNumeric>(::apache::thrift::detail::wrap_argument<1>(3), ::apache::thrift::detail::wrap_argument<2>(true))) {}
  // FragileConstructor for use in initialization lists only.
  TrivialNestedWithDefault(apache::thrift::FragileConstructor, int32_t z__arg,  ::apache::thrift::fixtures::types::TrivialNumeric n__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    z = arg.extract();
    __isset.z = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    n = arg.extract();
    __isset.n = true;
  }

  TrivialNestedWithDefault(TrivialNestedWithDefault&&) = default;

  TrivialNestedWithDefault(const TrivialNestedWithDefault&) = default;

  TrivialNestedWithDefault& operator=(TrivialNestedWithDefault&&) = default;

  TrivialNestedWithDefault& operator=(const TrivialNestedWithDefault&) = default;
  void __clear();
  int32_t z;
   ::apache::thrift::fixtures::types::TrivialNumeric n;

  struct __isset {
    bool z;
    bool n;
  } __isset = {};
  bool operator==(const TrivialNestedWithDefault& rhs) const;
  bool operator<(const TrivialNestedWithDefault& rhs) const;

  int32_t get_z() const {
    return z;
  }

  int32_t& set_z(int32_t z_) {
    z = z_;
    __isset.z = true;
    return z;
  }
  const  ::apache::thrift::fixtures::types::TrivialNumeric& get_n() const&;
   ::apache::thrift::fixtures::types::TrivialNumeric get_n() &&;

  template <typename T_TrivialNestedWithDefault_n_struct_setter =  ::apache::thrift::fixtures::types::TrivialNumeric>
   ::apache::thrift::fixtures::types::TrivialNumeric& set_n(T_TrivialNestedWithDefault_n_struct_setter&& n_) {
    n = std::forward<T_TrivialNestedWithDefault_n_struct_setter>(n_);
    __isset.n = true;
    return n;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< TrivialNestedWithDefault >;
};

void swap(TrivialNestedWithDefault& a, TrivialNestedWithDefault& b);
extern template void TrivialNestedWithDefault::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t TrivialNestedWithDefault::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t TrivialNestedWithDefault::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t TrivialNestedWithDefault::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void TrivialNestedWithDefault::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t TrivialNestedWithDefault::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t TrivialNestedWithDefault::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t TrivialNestedWithDefault::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t TrivialNestedWithDefault::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::apache::thrift::fixtures::types::TrivialNestedWithDefault>::clear( ::apache::thrift::fixtures::types::TrivialNestedWithDefault* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::apache::thrift::fixtures::types::TrivialNestedWithDefault>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::TrivialNestedWithDefault>::write(Protocol* proto,  ::apache::thrift::fixtures::types::TrivialNestedWithDefault const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::apache::thrift::fixtures::types::TrivialNestedWithDefault>::read(Protocol* proto,  ::apache::thrift::fixtures::types::TrivialNestedWithDefault* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::TrivialNestedWithDefault>::serializedSize(Protocol const* proto,  ::apache::thrift::fixtures::types::TrivialNestedWithDefault const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::TrivialNestedWithDefault>::serializedSizeZC(Protocol const* proto,  ::apache::thrift::fixtures::types::TrivialNestedWithDefault const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace apache { namespace thrift { namespace fixtures { namespace types {
class ComplexString final : private apache::thrift::detail::st::ComparisonOperators<ComplexString> {
 public:

  ComplexString() {}
  // FragileConstructor for use in initialization lists only.
  ComplexString(apache::thrift::FragileConstructor, std::string a__arg, std::map<std::string, int32_t> b__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    a = arg.extract();
    __isset.a = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    b = arg.extract();
    __isset.b = true;
  }

  ComplexString(ComplexString&&) = default;

  ComplexString(const ComplexString&) = default;

  ComplexString& operator=(ComplexString&&) = default;

  ComplexString& operator=(const ComplexString&) = default;
  void __clear();
  std::string a;
  std::map<std::string, int32_t> b;

  struct __isset {
    bool a;
    bool b;
  } __isset = {};
  bool operator==(const ComplexString& rhs) const;
  bool operator<(const ComplexString& rhs) const;

  const std::string& get_a() const& {
    return a;
  }

  std::string get_a() && {
    return std::move(a);
  }

  template <typename T_ComplexString_a_struct_setter = std::string>
  std::string& set_a(T_ComplexString_a_struct_setter&& a_) {
    a = std::forward<T_ComplexString_a_struct_setter>(a_);
    __isset.a = true;
    return a;
  }
  const std::map<std::string, int32_t>& get_b() const&;
  std::map<std::string, int32_t> get_b() &&;

  template <typename T_ComplexString_b_struct_setter = std::map<std::string, int32_t>>
  std::map<std::string, int32_t>& set_b(T_ComplexString_b_struct_setter&& b_) {
    b = std::forward<T_ComplexString_b_struct_setter>(b_);
    __isset.b = true;
    return b;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ComplexString >;
};

void swap(ComplexString& a, ComplexString& b);
extern template void ComplexString::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t ComplexString::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t ComplexString::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t ComplexString::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void ComplexString::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t ComplexString::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t ComplexString::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t ComplexString::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t ComplexString::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::apache::thrift::fixtures::types::ComplexString>::clear( ::apache::thrift::fixtures::types::ComplexString* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::apache::thrift::fixtures::types::ComplexString>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::ComplexString>::write(Protocol* proto,  ::apache::thrift::fixtures::types::ComplexString const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::apache::thrift::fixtures::types::ComplexString>::read(Protocol* proto,  ::apache::thrift::fixtures::types::ComplexString* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::ComplexString>::serializedSize(Protocol const* proto,  ::apache::thrift::fixtures::types::ComplexString const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::ComplexString>::serializedSizeZC(Protocol const* proto,  ::apache::thrift::fixtures::types::ComplexString const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace apache { namespace thrift { namespace fixtures { namespace types {
class ComplexNestedWithDefault final : private apache::thrift::detail::st::ComparisonOperators<ComplexNestedWithDefault> {
 public:

  ComplexNestedWithDefault() :
      z(apache::thrift::StringTraits< std::string>::fromStringLiteral("4")),
      n(::apache::thrift::detail::make_constant< ::apache::thrift::fixtures::types::ComplexString>(::apache::thrift::detail::wrap_argument<1>(apache::thrift::StringTraits< std::string>::fromStringLiteral("3")), ::apache::thrift::detail::wrap_argument<2>(std::initializer_list<std::pair<const std::string, int32_t>>{{apache::thrift::StringTraits< std::string>::fromStringLiteral("a"), 3}}))) {}
  // FragileConstructor for use in initialization lists only.
  ComplexNestedWithDefault(apache::thrift::FragileConstructor, std::string z__arg,  ::apache::thrift::fixtures::types::ComplexString n__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    z = arg.extract();
    __isset.z = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    n = arg.extract();
    __isset.n = true;
  }

  ComplexNestedWithDefault(ComplexNestedWithDefault&&) = default;

  ComplexNestedWithDefault(const ComplexNestedWithDefault&) = default;

  ComplexNestedWithDefault& operator=(ComplexNestedWithDefault&&) = default;

  ComplexNestedWithDefault& operator=(const ComplexNestedWithDefault&) = default;
  void __clear();
  std::string z;
   ::apache::thrift::fixtures::types::ComplexString n;

  struct __isset {
    bool z;
    bool n;
  } __isset = {};
  bool operator==(const ComplexNestedWithDefault& rhs) const;
  bool operator<(const ComplexNestedWithDefault& rhs) const;

  const std::string& get_z() const& {
    return z;
  }

  std::string get_z() && {
    return std::move(z);
  }

  template <typename T_ComplexNestedWithDefault_z_struct_setter = std::string>
  std::string& set_z(T_ComplexNestedWithDefault_z_struct_setter&& z_) {
    z = std::forward<T_ComplexNestedWithDefault_z_struct_setter>(z_);
    __isset.z = true;
    return z;
  }
  const  ::apache::thrift::fixtures::types::ComplexString& get_n() const&;
   ::apache::thrift::fixtures::types::ComplexString get_n() &&;

  template <typename T_ComplexNestedWithDefault_n_struct_setter =  ::apache::thrift::fixtures::types::ComplexString>
   ::apache::thrift::fixtures::types::ComplexString& set_n(T_ComplexNestedWithDefault_n_struct_setter&& n_) {
    n = std::forward<T_ComplexNestedWithDefault_n_struct_setter>(n_);
    __isset.n = true;
    return n;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ComplexNestedWithDefault >;
};

void swap(ComplexNestedWithDefault& a, ComplexNestedWithDefault& b);
extern template void ComplexNestedWithDefault::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t ComplexNestedWithDefault::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t ComplexNestedWithDefault::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t ComplexNestedWithDefault::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void ComplexNestedWithDefault::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t ComplexNestedWithDefault::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t ComplexNestedWithDefault::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t ComplexNestedWithDefault::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t ComplexNestedWithDefault::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::apache::thrift::fixtures::types::ComplexNestedWithDefault>::clear( ::apache::thrift::fixtures::types::ComplexNestedWithDefault* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::apache::thrift::fixtures::types::ComplexNestedWithDefault>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::ComplexNestedWithDefault>::write(Protocol* proto,  ::apache::thrift::fixtures::types::ComplexNestedWithDefault const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::apache::thrift::fixtures::types::ComplexNestedWithDefault>::read(Protocol* proto,  ::apache::thrift::fixtures::types::ComplexNestedWithDefault* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::ComplexNestedWithDefault>::serializedSize(Protocol const* proto,  ::apache::thrift::fixtures::types::ComplexNestedWithDefault const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::ComplexNestedWithDefault>::serializedSizeZC(Protocol const* proto,  ::apache::thrift::fixtures::types::ComplexNestedWithDefault const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace apache { namespace thrift { namespace fixtures { namespace types {
class MinPadding final : private apache::thrift::detail::st::ComparisonOperators<MinPadding> {
 public:

  MinPadding() :
      big(0),
      biggish(0),
      medium(0),
      small(0),
      tiny(0) {}
  // FragileConstructor for use in initialization lists only.
  MinPadding(apache::thrift::FragileConstructor, int8_t small__arg, int64_t big__arg, int16_t medium__arg, int32_t biggish__arg, int8_t tiny__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    small = arg.extract();
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    big = arg.extract();
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<3, _T> arg) {
    medium = arg.extract();
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<4, _T> arg) {
    biggish = arg.extract();
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<5, _T> arg) {
    tiny = arg.extract();
  }

  MinPadding(MinPadding&&) = default;

  MinPadding(const MinPadding&) = default;

  MinPadding& operator=(MinPadding&&) = default;

  MinPadding& operator=(const MinPadding&) = default;
  void __clear();
  int64_t big;
  int32_t biggish;
  int16_t medium;
  int8_t small;
  int8_t tiny;
  bool operator==(const MinPadding& rhs) const;
  bool operator<(const MinPadding& rhs) const;

  int8_t get_small() const {
    return small;
  }

  int8_t& set_small(int8_t small_) {
    small = small_;
    return small;
  }

  int64_t get_big() const {
    return big;
  }

  int64_t& set_big(int64_t big_) {
    big = big_;
    return big;
  }

  int16_t get_medium() const {
    return medium;
  }

  int16_t& set_medium(int16_t medium_) {
    medium = medium_;
    return medium;
  }

  int32_t get_biggish() const {
    return biggish;
  }

  int32_t& set_biggish(int32_t biggish_) {
    biggish = biggish_;
    return biggish;
  }

  int8_t get_tiny() const {
    return tiny;
  }

  int8_t& set_tiny(int8_t tiny_) {
    tiny = tiny_;
    return tiny;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< MinPadding >;
};

void swap(MinPadding& a, MinPadding& b);
extern template void MinPadding::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
extern template uint32_t MinPadding::write<>(apache::thrift::BinaryProtocolWriter*) const;
extern template uint32_t MinPadding::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template uint32_t MinPadding::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
extern template void MinPadding::readNoXfer<>(apache::thrift::CompactProtocolReader*);
extern template uint32_t MinPadding::write<>(apache::thrift::CompactProtocolWriter*) const;
extern template uint32_t MinPadding::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
extern template uint32_t MinPadding::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

template <class Protocol_>
uint32_t MinPadding::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}}} // apache::thrift::fixtures::types
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::apache::thrift::fixtures::types::MinPadding>::clear( ::apache::thrift::fixtures::types::MinPadding* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::apache::thrift::fixtures::types::MinPadding>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::MinPadding>::write(Protocol* proto,  ::apache::thrift::fixtures::types::MinPadding const* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> void Cpp2Ops< ::apache::thrift::fixtures::types::MinPadding>::read(Protocol* proto,  ::apache::thrift::fixtures::types::MinPadding* obj) {
  return obj->readNoXfer(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::MinPadding>::serializedSize(Protocol const* proto,  ::apache::thrift::fixtures::types::MinPadding const* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> uint32_t Cpp2Ops< ::apache::thrift::fixtures::types::MinPadding>::serializedSizeZC(Protocol const* proto,  ::apache::thrift::fixtures::types::MinPadding const* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
