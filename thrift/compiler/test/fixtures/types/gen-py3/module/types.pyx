#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
cimport cython as __cython
from cpython.bytes cimport PyBytes_AsStringAndSize
from cpython.object cimport PyTypeObject, Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT, Py_GE
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET as __NOTSET
from thrift.py3.types cimport (
    translate_cpp_enum_to_python,
    SetMetaClass as __SetMetaClass,
    constant_shared_ptr,
)
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer import Protocol as __Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize
import folly.iobuf as __iobuf
from folly.optional cimport cOptional

import sys
import itertools
from collections import Sequence, Set, Mapping, Iterable
import warnings
import weakref as __weakref
import builtins as _builtins
cimport include.types as _include_types
import include.types as _include_types

cdef object __has_bitwise_opsEnumInstances = None  # Set[has_bitwise_ops]
cdef object __has_bitwise_opsEnumMembers = {}      # Dict[str, has_bitwise_ops]
cdef object __has_bitwise_opsEnumUniqueValues = dict()    # Dict[int, has_bitwise_ops]

@__cython.internal
@__cython.auto_pickle(False)
cdef class __has_bitwise_opsMeta(type):
    def __call__(cls, value):
        cdef int cvalue
        if isinstance(value, cls):
            return value
        if isinstance(value, int):
            cvalue = value
            if cvalue == 0:
                return has_bitwise_ops.none
            elif cvalue == 1:
                return has_bitwise_ops.zero
            elif cvalue == 2:
                return has_bitwise_ops.one
            elif cvalue == 4:
                return has_bitwise_ops.two
            elif cvalue == 8:
                return has_bitwise_ops.three

        raise ValueError(f'{value} is not a valid has_bitwise_ops')

    def __getitem__(cls, name):
        return __has_bitwise_opsEnumMembers[name]

    def __dir__(cls):
        return ['__class__', '__doc__', '__members__', '__module__',
        'none',
        'zero',
        'one',
        'two',
        'three',
        ]

    def __iter__(cls):
        return iter(__has_bitwise_opsEnumUniqueValues.values())

    def __reversed__(cls):
        return reversed(iter(cls))

    def __contains__(cls, item):
        if not isinstance(item, cls):
            return False
        return item in __has_bitwise_opsEnumInstances

    def __len__(cls):
        return len(__has_bitwise_opsEnumInstances)


cdef __has_bitwise_ops_unique_instance(int value, str name):
    inst = __has_bitwise_opsEnumUniqueValues.get(value)
    if inst is None:
        inst = __has_bitwise_opsEnumUniqueValues[value] = has_bitwise_ops.__new__(has_bitwise_ops, value, name)
    __has_bitwise_opsEnumMembers[name] = inst
    return inst


@__cython.final
cdef class has_bitwise_ops(thrift.py3.types.CompiledEnum):
    none = __has_bitwise_ops_unique_instance(0, "none")
    zero = __has_bitwise_ops_unique_instance(1, "zero")
    one = __has_bitwise_ops_unique_instance(2, "one")
    two = __has_bitwise_ops_unique_instance(4, "two")
    three = __has_bitwise_ops_unique_instance(8, "three")
    __members__ = thrift.py3.types.MappingProxyType(__has_bitwise_opsEnumMembers)

    def __cinit__(self, value, name):
        if __has_bitwise_opsEnumInstances is not None:
            raise TypeError('__new__ is disabled in the interest of type-safety')
        self.value = value
        self.name = name
        self.__hash = hash(name)
        self.__str = f"has_bitwise_ops.{name}"
        self.__repr = f"<{self.__str}: {value}>"

    def __repr__(self):
        return self.__repr

    def __str__(self):
        return self.__str

    def __int__(self):
        return self.value

    def __eq__(self, other):
        if not isinstance(other, has_bitwise_ops):
            warnings.warn(f"comparison not supported between instances of { has_bitwise_ops } and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self is other

    def __hash__(self):
        return self.__hash

    def __reduce__(self):
        return has_bitwise_ops, (self.value,)


__SetMetaClass(<PyTypeObject*> has_bitwise_ops, <PyTypeObject*> __has_bitwise_opsMeta)
__has_bitwise_opsEnumInstances = set(__has_bitwise_opsEnumUniqueValues.values())


cdef inline chas_bitwise_ops has_bitwise_ops_to_cpp(has_bitwise_ops value):
    cdef int cvalue = value.value
    if cvalue == 0:
        return has_bitwise_ops__none
    elif cvalue == 1:
        return has_bitwise_ops__zero
    elif cvalue == 2:
        return has_bitwise_ops__one
    elif cvalue == 4:
        return has_bitwise_ops__two
    elif cvalue == 8:
        return has_bitwise_ops__three
cdef object __is_unscopedEnumInstances = None  # Set[is_unscoped]
cdef object __is_unscopedEnumMembers = {}      # Dict[str, is_unscoped]
cdef object __is_unscopedEnumUniqueValues = dict()    # Dict[int, is_unscoped]

@__cython.internal
@__cython.auto_pickle(False)
cdef class __is_unscopedMeta(type):
    def __call__(cls, value):
        cdef int cvalue
        if isinstance(value, cls):
            return value
        if isinstance(value, int):
            cvalue = value
            if cvalue == 0:
                return is_unscoped.hello
            elif cvalue == 1:
                return is_unscoped.world

        raise ValueError(f'{value} is not a valid is_unscoped')

    def __getitem__(cls, name):
        return __is_unscopedEnumMembers[name]

    def __dir__(cls):
        return ['__class__', '__doc__', '__members__', '__module__',
        'hello',
        'world',
        ]

    def __iter__(cls):
        return iter(__is_unscopedEnumUniqueValues.values())

    def __reversed__(cls):
        return reversed(iter(cls))

    def __contains__(cls, item):
        if not isinstance(item, cls):
            return False
        return item in __is_unscopedEnumInstances

    def __len__(cls):
        return len(__is_unscopedEnumInstances)


cdef __is_unscoped_unique_instance(int value, str name):
    inst = __is_unscopedEnumUniqueValues.get(value)
    if inst is None:
        inst = __is_unscopedEnumUniqueValues[value] = is_unscoped.__new__(is_unscoped, value, name)
    __is_unscopedEnumMembers[name] = inst
    return inst


@__cython.final
cdef class is_unscoped(thrift.py3.types.CompiledEnum):
    hello = __is_unscoped_unique_instance(0, "hello")
    world = __is_unscoped_unique_instance(1, "world")
    __members__ = thrift.py3.types.MappingProxyType(__is_unscopedEnumMembers)

    def __cinit__(self, value, name):
        if __is_unscopedEnumInstances is not None:
            raise TypeError('__new__ is disabled in the interest of type-safety')
        self.value = value
        self.name = name
        self.__hash = hash(name)
        self.__str = f"is_unscoped.{name}"
        self.__repr = f"<{self.__str}: {value}>"

    def __repr__(self):
        return self.__repr

    def __str__(self):
        return self.__str

    def __int__(self):
        return self.value

    def __eq__(self, other):
        if not isinstance(other, is_unscoped):
            warnings.warn(f"comparison not supported between instances of { is_unscoped } and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self is other

    def __hash__(self):
        return self.__hash

    def __reduce__(self):
        return is_unscoped, (self.value,)


__SetMetaClass(<PyTypeObject*> is_unscoped, <PyTypeObject*> __is_unscopedMeta)
__is_unscopedEnumInstances = set(__is_unscopedEnumUniqueValues.values())


cdef inline cis_unscoped is_unscoped_to_cpp(is_unscoped value):
    cdef int cvalue = value.value
    if cvalue == 0:
        return is_unscoped__hello
    elif cvalue == 1:
        return is_unscoped__world
cdef object __MyForwardRefEnumEnumInstances = None  # Set[MyForwardRefEnum]
cdef object __MyForwardRefEnumEnumMembers = {}      # Dict[str, MyForwardRefEnum]
cdef object __MyForwardRefEnumEnumUniqueValues = dict()    # Dict[int, MyForwardRefEnum]

@__cython.internal
@__cython.auto_pickle(False)
cdef class __MyForwardRefEnumMeta(type):
    def __call__(cls, value):
        cdef int cvalue
        if isinstance(value, cls):
            return value
        if isinstance(value, int):
            cvalue = value
            if cvalue == 0:
                return MyForwardRefEnum.ZERO
            elif cvalue == 12:
                return MyForwardRefEnum.NONZERO

        raise ValueError(f'{value} is not a valid MyForwardRefEnum')

    def __getitem__(cls, name):
        return __MyForwardRefEnumEnumMembers[name]

    def __dir__(cls):
        return ['__class__', '__doc__', '__members__', '__module__',
        'ZERO',
        'NONZERO',
        ]

    def __iter__(cls):
        return iter(__MyForwardRefEnumEnumUniqueValues.values())

    def __reversed__(cls):
        return reversed(iter(cls))

    def __contains__(cls, item):
        if not isinstance(item, cls):
            return False
        return item in __MyForwardRefEnumEnumInstances

    def __len__(cls):
        return len(__MyForwardRefEnumEnumInstances)


cdef __MyForwardRefEnum_unique_instance(int value, str name):
    inst = __MyForwardRefEnumEnumUniqueValues.get(value)
    if inst is None:
        inst = __MyForwardRefEnumEnumUniqueValues[value] = MyForwardRefEnum.__new__(MyForwardRefEnum, value, name)
    __MyForwardRefEnumEnumMembers[name] = inst
    return inst


@__cython.final
cdef class MyForwardRefEnum(thrift.py3.types.CompiledEnum):
    ZERO = __MyForwardRefEnum_unique_instance(0, "ZERO")
    NONZERO = __MyForwardRefEnum_unique_instance(12, "NONZERO")
    __members__ = thrift.py3.types.MappingProxyType(__MyForwardRefEnumEnumMembers)

    def __cinit__(self, value, name):
        if __MyForwardRefEnumEnumInstances is not None:
            raise TypeError('__new__ is disabled in the interest of type-safety')
        self.value = value
        self.name = name
        self.__hash = hash(name)
        self.__str = f"MyForwardRefEnum.{name}"
        self.__repr = f"<{self.__str}: {value}>"

    def __repr__(self):
        return self.__repr

    def __str__(self):
        return self.__str

    def __int__(self):
        return self.value

    def __eq__(self, other):
        if not isinstance(other, MyForwardRefEnum):
            warnings.warn(f"comparison not supported between instances of { MyForwardRefEnum } and {type(other)}", RuntimeWarning, stacklevel=2)
            return False
        return self is other

    def __hash__(self):
        return self.__hash

    def __reduce__(self):
        return MyForwardRefEnum, (self.value,)


__SetMetaClass(<PyTypeObject*> MyForwardRefEnum, <PyTypeObject*> __MyForwardRefEnumMeta)
__MyForwardRefEnumEnumInstances = set(__MyForwardRefEnumEnumUniqueValues.values())


cdef inline cMyForwardRefEnum MyForwardRefEnum_to_cpp(MyForwardRefEnum value):
    cdef int cvalue = value.value
    if cvalue == 0:
        return MyForwardRefEnum__ZERO
    elif cvalue == 12:
        return MyForwardRefEnum__NONZERO

cdef cdecorated_struct _decorated_struct_defaults = cdecorated_struct()

cdef class decorated_struct(thrift.py3.types.Struct):

    def __init__(
        decorated_struct self, *,
        str field=None
    ):
        self._cpp_obj = move(decorated_struct._make_instance(
          NULL,
          NULL,
          field,
        ))

    def __call__(
        decorated_struct self,
        field=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[1] __isNOTSET  # so make_instance is typed

        changes = False
        if field is ___NOTSET:
            __isNOTSET[0] = True
            field = None
        else:
            __isNOTSET[0] = False
            changes = True


        if not changes:
            return self

        if field is not None:
            if not isinstance(field, str):
                raise TypeError(f'field is not a { str !r}.')

        inst = <decorated_struct>decorated_struct.__new__(decorated_struct)
        inst._cpp_obj = move(decorated_struct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          field,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cdecorated_struct] _make_instance(
        cdecorated_struct* base_instance,
        bint* __isNOTSET,
        str field 
    ) except *:
        cdef unique_ptr[cdecorated_struct] c_inst
        if base_instance:
            c_inst = make_unique[cdecorated_struct](deref(base_instance))
        else:
            c_inst = make_unique[cdecorated_struct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and field is None:
                deref(c_inst).field = _decorated_struct_defaults.field
                deref(c_inst).__isset.field = False
                pass

        if field is not None:
            deref(c_inst).field = thrift.py3.types.move(thrift.py3.types.bytes_to_string(field.encode('utf-8')))
            deref(c_inst).__isset.field = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'field', self.field

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cdecorated_struct] cpp_obj):
        inst = <decorated_struct>decorated_struct.__new__(decorated_struct)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def field(self):

        return (<bytes>deref(self._cpp_obj).field).decode('UTF-8')


    def __hash__(decorated_struct self):
        if not self.__hash:
            self.__hash = hash((
            self.field,
            ))
        return self.__hash

    def __repr__(decorated_struct self):
        return f'decorated_struct(field={repr(self.field)})'
    def __copy__(decorated_struct self):
        cdef shared_ptr[cdecorated_struct] cpp_obj = make_shared[cdecorated_struct](
            deref(self._cpp_obj)
        )
        return decorated_struct.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, decorated_struct) and
                isinstance(other, decorated_struct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cdecorated_struct* cself = (<decorated_struct>self)._cpp_obj.get()
        cdef cdecorated_struct* cother = (<decorated_struct>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return not (deref(cself) == deref(cother))
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(decorated_struct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cdecorated_struct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cdecorated_struct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cdecorated_struct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cdecorated_struct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cdecorated_struct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(decorated_struct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cdecorated_struct]()
        cdef cdecorated_struct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cdecorated_struct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cdecorated_struct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cdecorated_struct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cdecorated_struct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (decorated_struct, serialize(self)))


cdef cContainerStruct _ContainerStruct_defaults = cContainerStruct()

cdef class ContainerStruct(thrift.py3.types.Struct):

    def __init__(
        ContainerStruct self, *,
        fieldA=None,
        fieldB=None,
        fieldC=None,
        fieldD=None,
        fieldE=None,
        fieldF=None,
        fieldG=None,
        fieldH=None
    ):
        self._cpp_obj = move(ContainerStruct._make_instance(
          NULL,
          NULL,
          fieldA,
          fieldB,
          fieldC,
          fieldD,
          fieldE,
          fieldF,
          fieldG,
          fieldH,
        ))

    def __call__(
        ContainerStruct self,
        fieldA=__NOTSET,
        fieldB=__NOTSET,
        fieldC=__NOTSET,
        fieldD=__NOTSET,
        fieldE=__NOTSET,
        fieldF=__NOTSET,
        fieldG=__NOTSET,
        fieldH=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[8] __isNOTSET  # so make_instance is typed

        changes = False
        if fieldA is ___NOTSET:
            __isNOTSET[0] = True
            fieldA = None
        else:
            __isNOTSET[0] = False
            changes = True

        if fieldB is ___NOTSET:
            __isNOTSET[1] = True
            fieldB = None
        else:
            __isNOTSET[1] = False
            changes = True

        if fieldC is ___NOTSET:
            __isNOTSET[2] = True
            fieldC = None
        else:
            __isNOTSET[2] = False
            changes = True

        if fieldD is ___NOTSET:
            __isNOTSET[3] = True
            fieldD = None
        else:
            __isNOTSET[3] = False
            changes = True

        if fieldE is ___NOTSET:
            __isNOTSET[4] = True
            fieldE = None
        else:
            __isNOTSET[4] = False
            changes = True

        if fieldF is ___NOTSET:
            __isNOTSET[5] = True
            fieldF = None
        else:
            __isNOTSET[5] = False
            changes = True

        if fieldG is ___NOTSET:
            __isNOTSET[6] = True
            fieldG = None
        else:
            __isNOTSET[6] = False
            changes = True

        if fieldH is ___NOTSET:
            __isNOTSET[7] = True
            fieldH = None
        else:
            __isNOTSET[7] = False
            changes = True


        if not changes:
            return self

        inst = <ContainerStruct>ContainerStruct.__new__(ContainerStruct)
        inst._cpp_obj = move(ContainerStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          fieldA,
          fieldB,
          fieldC,
          fieldD,
          fieldE,
          fieldF,
          fieldG,
          fieldH,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cContainerStruct] _make_instance(
        cContainerStruct* base_instance,
        bint* __isNOTSET,
        object fieldA ,
        object fieldB ,
        object fieldC ,
        object fieldD ,
        object fieldE ,
        object fieldF ,
        object fieldG ,
        object fieldH 
    ) except *:
        cdef unique_ptr[cContainerStruct] c_inst
        if base_instance:
            c_inst = make_unique[cContainerStruct](deref(base_instance))
        else:
            c_inst = make_unique[cContainerStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and fieldA is None:
                deref(c_inst).fieldA = _ContainerStruct_defaults.fieldA
                deref(c_inst).__isset.fieldA = False
                pass

            if not __isNOTSET[1] and fieldB is None:
                deref(c_inst).fieldB = _ContainerStruct_defaults.fieldB
                deref(c_inst).__isset.fieldB = False
                pass

            if not __isNOTSET[2] and fieldC is None:
                deref(c_inst).fieldC = _ContainerStruct_defaults.fieldC
                deref(c_inst).__isset.fieldC = False
                pass

            if not __isNOTSET[3] and fieldD is None:
                deref(c_inst).fieldD = _ContainerStruct_defaults.fieldD
                deref(c_inst).__isset.fieldD = False
                pass

            if not __isNOTSET[4] and fieldE is None:
                deref(c_inst).fieldE = _ContainerStruct_defaults.fieldE
                deref(c_inst).__isset.fieldE = False
                pass

            if not __isNOTSET[5] and fieldF is None:
                deref(c_inst).fieldF = _ContainerStruct_defaults.fieldF
                deref(c_inst).__isset.fieldF = False
                pass

            if not __isNOTSET[6] and fieldG is None:
                deref(c_inst).fieldG = _ContainerStruct_defaults.fieldG
                deref(c_inst).__isset.fieldG = False
                pass

            if not __isNOTSET[7] and fieldH is None:
                deref(c_inst).fieldH = _ContainerStruct_defaults.fieldH
                deref(c_inst).__isset.fieldH = False
                pass

        if fieldA is not None:
            deref(c_inst).fieldA = deref(List__i32(fieldA)._cpp_obj)
            deref(c_inst).__isset.fieldA = True
        if fieldB is not None:
            deref(c_inst).fieldB = deref(std_list__List__i32(fieldB)._cpp_obj)
            deref(c_inst).__isset.fieldB = True
        if fieldC is not None:
            deref(c_inst).fieldC = deref(std_deque__List__i32(fieldC)._cpp_obj)
            deref(c_inst).__isset.fieldC = True
        if fieldD is not None:
            deref(c_inst).fieldD = deref(folly_fbvector__List__i32(fieldD)._cpp_obj)
            deref(c_inst).__isset.fieldD = True
        if fieldE is not None:
            deref(c_inst).fieldE = deref(folly_small_vector__List__i32(fieldE)._cpp_obj)
            deref(c_inst).__isset.fieldE = True
        if fieldF is not None:
            deref(c_inst).fieldF = deref(folly_sorted_vector_set__Set__i32(fieldF)._cpp_obj)
            deref(c_inst).__isset.fieldF = True
        if fieldG is not None:
            deref(c_inst).fieldG = deref(folly_sorted_vector_map__Map__i32_string(fieldG)._cpp_obj)
            deref(c_inst).__isset.fieldG = True
        if fieldH is not None:
            deref(c_inst).fieldH = deref(std_unordered_map__Map__i32_string(fieldH)._cpp_obj)
            deref(c_inst).__isset.fieldH = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'fieldA', self.fieldA
        yield 'fieldB', self.fieldB
        yield 'fieldC', self.fieldC
        yield 'fieldD', self.fieldD
        yield 'fieldE', self.fieldE
        yield 'fieldF', self.fieldF
        yield 'fieldG', self.fieldG
        yield 'fieldH', self.fieldH

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cContainerStruct] cpp_obj):
        inst = <ContainerStruct>ContainerStruct.__new__(ContainerStruct)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def fieldA(self):

        if self.__field_fieldA is None:
            self.__field_fieldA = List__i32.create(reference_shared_ptr_fieldA(self._cpp_obj, deref(self._cpp_obj).fieldA))
        return self.__field_fieldA

    @property
    def fieldB(self):

        if self.__field_fieldB is None:
            self.__field_fieldB = std_list__List__i32.create(reference_shared_ptr_fieldB(self._cpp_obj, deref(self._cpp_obj).fieldB))
        return self.__field_fieldB

    @property
    def fieldC(self):

        if self.__field_fieldC is None:
            self.__field_fieldC = std_deque__List__i32.create(reference_shared_ptr_fieldC(self._cpp_obj, deref(self._cpp_obj).fieldC))
        return self.__field_fieldC

    @property
    def fieldD(self):

        if self.__field_fieldD is None:
            self.__field_fieldD = folly_fbvector__List__i32.create(reference_shared_ptr_fieldD(self._cpp_obj, deref(self._cpp_obj).fieldD))
        return self.__field_fieldD

    @property
    def fieldE(self):

        if self.__field_fieldE is None:
            self.__field_fieldE = folly_small_vector__List__i32.create(reference_shared_ptr_fieldE(self._cpp_obj, deref(self._cpp_obj).fieldE))
        return self.__field_fieldE

    @property
    def fieldF(self):

        if self.__field_fieldF is None:
            self.__field_fieldF = folly_sorted_vector_set__Set__i32.create(reference_shared_ptr_fieldF(self._cpp_obj, deref(self._cpp_obj).fieldF))
        return self.__field_fieldF

    @property
    def fieldG(self):

        if self.__field_fieldG is None:
            self.__field_fieldG = folly_sorted_vector_map__Map__i32_string.create(reference_shared_ptr_fieldG(self._cpp_obj, deref(self._cpp_obj).fieldG))
        return self.__field_fieldG

    @property
    def fieldH(self):

        if self.__field_fieldH is None:
            self.__field_fieldH = std_unordered_map__Map__i32_string.create(reference_shared_ptr_fieldH(self._cpp_obj, deref(self._cpp_obj).fieldH))
        return self.__field_fieldH


    def __hash__(ContainerStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.fieldA,
            self.fieldB,
            self.fieldC,
            self.fieldD,
            self.fieldE,
            self.fieldF,
            self.fieldG,
            self.fieldH,
            ))
        return self.__hash

    def __repr__(ContainerStruct self):
        return f'ContainerStruct(fieldA={repr(self.fieldA)}, fieldB={repr(self.fieldB)}, fieldC={repr(self.fieldC)}, fieldD={repr(self.fieldD)}, fieldE={repr(self.fieldE)}, fieldF={repr(self.fieldF)}, fieldG={repr(self.fieldG)}, fieldH={repr(self.fieldH)})'
    def __copy__(ContainerStruct self):
        cdef shared_ptr[cContainerStruct] cpp_obj = make_shared[cContainerStruct](
            deref(self._cpp_obj)
        )
        return ContainerStruct.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, ContainerStruct) and
                isinstance(other, ContainerStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cContainerStruct* cself = (<ContainerStruct>self)._cpp_obj.get()
        cdef cContainerStruct* cother = (<ContainerStruct>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return not (deref(cself) == deref(cother))
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(ContainerStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cContainerStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cContainerStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cContainerStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cContainerStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cContainerStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(ContainerStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cContainerStruct]()
        cdef cContainerStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cContainerStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cContainerStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cContainerStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cContainerStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (ContainerStruct, serialize(self)))


cdef cCppTypeStruct _CppTypeStruct_defaults = cCppTypeStruct()

cdef class CppTypeStruct(thrift.py3.types.Struct):

    def __init__(
        CppTypeStruct self, *,
        fieldA=None
    ):
        self._cpp_obj = move(CppTypeStruct._make_instance(
          NULL,
          NULL,
          fieldA,
        ))

    def __call__(
        CppTypeStruct self,
        fieldA=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[1] __isNOTSET  # so make_instance is typed

        changes = False
        if fieldA is ___NOTSET:
            __isNOTSET[0] = True
            fieldA = None
        else:
            __isNOTSET[0] = False
            changes = True


        if not changes:
            return self

        inst = <CppTypeStruct>CppTypeStruct.__new__(CppTypeStruct)
        inst._cpp_obj = move(CppTypeStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          fieldA,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cCppTypeStruct] _make_instance(
        cCppTypeStruct* base_instance,
        bint* __isNOTSET,
        object fieldA 
    ) except *:
        cdef unique_ptr[cCppTypeStruct] c_inst
        if base_instance:
            c_inst = make_unique[cCppTypeStruct](deref(base_instance))
        else:
            c_inst = make_unique[cCppTypeStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and fieldA is None:
                deref(c_inst).fieldA = _CppTypeStruct_defaults.fieldA
                deref(c_inst).__isset.fieldA = False
                pass

        if fieldA is not None:
            deref(c_inst).fieldA = deref(std_list_int32_t__List__i32(fieldA)._cpp_obj)
            deref(c_inst).__isset.fieldA = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'fieldA', self.fieldA

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cCppTypeStruct] cpp_obj):
        inst = <CppTypeStruct>CppTypeStruct.__new__(CppTypeStruct)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def fieldA(self):

        if self.__field_fieldA is None:
            self.__field_fieldA = std_list_int32_t__List__i32.create(reference_shared_ptr_fieldA(self._cpp_obj, deref(self._cpp_obj).fieldA))
        return self.__field_fieldA


    def __hash__(CppTypeStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.fieldA,
            ))
        return self.__hash

    def __repr__(CppTypeStruct self):
        return f'CppTypeStruct(fieldA={repr(self.fieldA)})'
    def __copy__(CppTypeStruct self):
        cdef shared_ptr[cCppTypeStruct] cpp_obj = make_shared[cCppTypeStruct](
            deref(self._cpp_obj)
        )
        return CppTypeStruct.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, CppTypeStruct) and
                isinstance(other, CppTypeStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cCppTypeStruct* cself = (<CppTypeStruct>self)._cpp_obj.get()
        cdef cCppTypeStruct* cother = (<CppTypeStruct>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return not (deref(cself) == deref(cother))
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(CppTypeStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cCppTypeStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cCppTypeStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cCppTypeStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cCppTypeStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cCppTypeStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(CppTypeStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cCppTypeStruct]()
        cdef cCppTypeStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cCppTypeStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cCppTypeStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cCppTypeStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cCppTypeStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (CppTypeStruct, serialize(self)))


cdef cVirtualStruct _VirtualStruct_defaults = cVirtualStruct()

cdef class VirtualStruct(thrift.py3.types.Struct):

    def __init__(
        VirtualStruct self, *,
        MyIntField=None
    ):
        if MyIntField is not None:
            if not isinstance(MyIntField, int):
                raise TypeError(f'MyIntField is not a { int !r}.')
            MyIntField = <int64_t> MyIntField

        self._cpp_obj = move(VirtualStruct._make_instance(
          NULL,
          NULL,
          MyIntField,
        ))

    def __call__(
        VirtualStruct self,
        MyIntField=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[1] __isNOTSET  # so make_instance is typed

        changes = False
        if MyIntField is ___NOTSET:
            __isNOTSET[0] = True
            MyIntField = None
        else:
            __isNOTSET[0] = False
            changes = True


        if not changes:
            return self

        if MyIntField is not None:
            if not isinstance(MyIntField, int):
                raise TypeError(f'MyIntField is not a { int !r}.')
            MyIntField = <int64_t> MyIntField

        inst = <VirtualStruct>VirtualStruct.__new__(VirtualStruct)
        inst._cpp_obj = move(VirtualStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          MyIntField,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cVirtualStruct] _make_instance(
        cVirtualStruct* base_instance,
        bint* __isNOTSET,
        object MyIntField 
    ) except *:
        cdef unique_ptr[cVirtualStruct] c_inst
        if base_instance:
            c_inst = make_unique[cVirtualStruct](deref(base_instance))
        else:
            c_inst = make_unique[cVirtualStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and MyIntField is None:
                deref(c_inst).MyIntField = _VirtualStruct_defaults.MyIntField
                deref(c_inst).__isset.MyIntField = False
                pass

        if MyIntField is not None:
            deref(c_inst).MyIntField = MyIntField
            deref(c_inst).__isset.MyIntField = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'MyIntField', self.MyIntField

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cVirtualStruct] cpp_obj):
        inst = <VirtualStruct>VirtualStruct.__new__(VirtualStruct)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def MyIntField(self):

        return deref(self._cpp_obj).MyIntField


    def __hash__(VirtualStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.MyIntField,
            ))
        return self.__hash

    def __repr__(VirtualStruct self):
        return f'VirtualStruct(MyIntField={repr(self.MyIntField)})'
    def __copy__(VirtualStruct self):
        cdef shared_ptr[cVirtualStruct] cpp_obj = make_shared[cVirtualStruct](
            deref(self._cpp_obj)
        )
        return VirtualStruct.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, VirtualStruct) and
                isinstance(other, VirtualStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cVirtualStruct* cself = (<VirtualStruct>self)._cpp_obj.get()
        cdef cVirtualStruct* cother = (<VirtualStruct>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return not (deref(cself) == deref(cother))
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(VirtualStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cVirtualStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cVirtualStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cVirtualStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cVirtualStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cVirtualStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(VirtualStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cVirtualStruct]()
        cdef cVirtualStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cVirtualStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cVirtualStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cVirtualStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cVirtualStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (VirtualStruct, serialize(self)))


cdef cMyStructWithForwardRefEnum _MyStructWithForwardRefEnum_defaults = cMyStructWithForwardRefEnum()

cdef class MyStructWithForwardRefEnum(thrift.py3.types.Struct):

    def __init__(
        MyStructWithForwardRefEnum self, *,
        MyForwardRefEnum a=None,
        MyForwardRefEnum b=None
    ):
        self._cpp_obj = move(MyStructWithForwardRefEnum._make_instance(
          NULL,
          NULL,
          a,
          b,
        ))

    def __call__(
        MyStructWithForwardRefEnum self,
        a=__NOTSET,
        b=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[2] __isNOTSET  # so make_instance is typed

        changes = False
        if a is ___NOTSET:
            __isNOTSET[0] = True
            a = None
        else:
            __isNOTSET[0] = False
            changes = True

        if b is ___NOTSET:
            __isNOTSET[1] = True
            b = None
        else:
            __isNOTSET[1] = False
            changes = True


        if not changes:
            return self

        if a is not None:
            if not isinstance(a, MyForwardRefEnum):
                raise TypeError(f'field a value: { a !r} is not of the enum type { MyForwardRefEnum }.')

        if b is not None:
            if not isinstance(b, MyForwardRefEnum):
                raise TypeError(f'field b value: { b !r} is not of the enum type { MyForwardRefEnum }.')

        inst = <MyStructWithForwardRefEnum>MyStructWithForwardRefEnum.__new__(MyStructWithForwardRefEnum)
        inst._cpp_obj = move(MyStructWithForwardRefEnum._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          a,
          b,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cMyStructWithForwardRefEnum] _make_instance(
        cMyStructWithForwardRefEnum* base_instance,
        bint* __isNOTSET,
        MyForwardRefEnum a ,
        MyForwardRefEnum b 
    ) except *:
        cdef unique_ptr[cMyStructWithForwardRefEnum] c_inst
        if base_instance:
            c_inst = make_unique[cMyStructWithForwardRefEnum](deref(base_instance))
        else:
            c_inst = make_unique[cMyStructWithForwardRefEnum]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and a is None:
                deref(c_inst).a = _MyStructWithForwardRefEnum_defaults.a
                deref(c_inst).__isset.a = False
                pass

            if not __isNOTSET[1] and b is None:
                deref(c_inst).b = _MyStructWithForwardRefEnum_defaults.b
                deref(c_inst).__isset.b = False
                pass

        if a is not None:
            deref(c_inst).a = MyForwardRefEnum_to_cpp(a)
            deref(c_inst).__isset.a = True
        if b is not None:
            deref(c_inst).b = MyForwardRefEnum_to_cpp(b)
            deref(c_inst).__isset.b = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'a', self.a
        yield 'b', self.b

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cMyStructWithForwardRefEnum] cpp_obj):
        inst = <MyStructWithForwardRefEnum>MyStructWithForwardRefEnum.__new__(MyStructWithForwardRefEnum)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def a(self):

        return translate_cpp_enum_to_python(MyForwardRefEnum, <int>(deref(self._cpp_obj).a))

    @property
    def b(self):

        return translate_cpp_enum_to_python(MyForwardRefEnum, <int>(deref(self._cpp_obj).b))


    def __hash__(MyStructWithForwardRefEnum self):
        if not self.__hash:
            self.__hash = hash((
            self.a,
            self.b,
            ))
        return self.__hash

    def __repr__(MyStructWithForwardRefEnum self):
        return f'MyStructWithForwardRefEnum(a={repr(self.a)}, b={repr(self.b)})'
    def __copy__(MyStructWithForwardRefEnum self):
        cdef shared_ptr[cMyStructWithForwardRefEnum] cpp_obj = make_shared[cMyStructWithForwardRefEnum](
            deref(self._cpp_obj)
        )
        return MyStructWithForwardRefEnum.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, MyStructWithForwardRefEnum) and
                isinstance(other, MyStructWithForwardRefEnum)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cMyStructWithForwardRefEnum* cself = (<MyStructWithForwardRefEnum>self)._cpp_obj.get()
        cdef cMyStructWithForwardRefEnum* cother = (<MyStructWithForwardRefEnum>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return not (deref(cself) == deref(cother))
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(MyStructWithForwardRefEnum self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cMyStructWithForwardRefEnum* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cMyStructWithForwardRefEnum](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cMyStructWithForwardRefEnum](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cMyStructWithForwardRefEnum](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cMyStructWithForwardRefEnum](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(MyStructWithForwardRefEnum self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cMyStructWithForwardRefEnum]()
        cdef cMyStructWithForwardRefEnum* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cMyStructWithForwardRefEnum](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cMyStructWithForwardRefEnum](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cMyStructWithForwardRefEnum](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cMyStructWithForwardRefEnum](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (MyStructWithForwardRefEnum, serialize(self)))


cdef cTrivialNumeric _TrivialNumeric_defaults = cTrivialNumeric()

cdef class TrivialNumeric(thrift.py3.types.Struct):

    def __init__(
        TrivialNumeric self, *,
        a=None,
        pbool b=None
    ):
        if a is not None:
            if not isinstance(a, int):
                raise TypeError(f'a is not a { int !r}.')
            a = <int32_t> a

        self._cpp_obj = move(TrivialNumeric._make_instance(
          NULL,
          NULL,
          a,
          b,
        ))

    def __call__(
        TrivialNumeric self,
        a=__NOTSET,
        b=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[2] __isNOTSET  # so make_instance is typed

        changes = False
        if a is ___NOTSET:
            __isNOTSET[0] = True
            a = None
        else:
            __isNOTSET[0] = False
            changes = True

        if b is ___NOTSET:
            __isNOTSET[1] = True
            b = None
        else:
            __isNOTSET[1] = False
            changes = True


        if not changes:
            return self

        if a is not None:
            if not isinstance(a, int):
                raise TypeError(f'a is not a { int !r}.')
            a = <int32_t> a

        if b is not None:
            if not isinstance(b, bool):
                raise TypeError(f'b is not a { bool !r}.')

        inst = <TrivialNumeric>TrivialNumeric.__new__(TrivialNumeric)
        inst._cpp_obj = move(TrivialNumeric._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          a,
          b,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cTrivialNumeric] _make_instance(
        cTrivialNumeric* base_instance,
        bint* __isNOTSET,
        object a ,
        pbool b 
    ) except *:
        cdef unique_ptr[cTrivialNumeric] c_inst
        if base_instance:
            c_inst = make_unique[cTrivialNumeric](deref(base_instance))
        else:
            c_inst = make_unique[cTrivialNumeric]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and a is None:
                deref(c_inst).a = _TrivialNumeric_defaults.a
                deref(c_inst).__isset.a = False
                pass

            if not __isNOTSET[1] and b is None:
                deref(c_inst).b = _TrivialNumeric_defaults.b
                deref(c_inst).__isset.b = False
                pass

        if a is not None:
            deref(c_inst).a = a
            deref(c_inst).__isset.a = True
        if b is not None:
            deref(c_inst).b = b
            deref(c_inst).__isset.b = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'a', self.a
        yield 'b', self.b

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cTrivialNumeric] cpp_obj):
        inst = <TrivialNumeric>TrivialNumeric.__new__(TrivialNumeric)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def a(self):

        return deref(self._cpp_obj).a

    @property
    def b(self):

        return <pbool> deref(self._cpp_obj).b


    def __hash__(TrivialNumeric self):
        if not self.__hash:
            self.__hash = hash((
            self.a,
            self.b,
            ))
        return self.__hash

    def __repr__(TrivialNumeric self):
        return f'TrivialNumeric(a={repr(self.a)}, b={repr(self.b)})'
    def __copy__(TrivialNumeric self):
        cdef shared_ptr[cTrivialNumeric] cpp_obj = make_shared[cTrivialNumeric](
            deref(self._cpp_obj)
        )
        return TrivialNumeric.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, TrivialNumeric) and
                isinstance(other, TrivialNumeric)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cTrivialNumeric* cself = (<TrivialNumeric>self)._cpp_obj.get()
        cdef cTrivialNumeric* cother = (<TrivialNumeric>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return not (deref(cself) == deref(cother))
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(TrivialNumeric self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cTrivialNumeric* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cTrivialNumeric](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cTrivialNumeric](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cTrivialNumeric](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cTrivialNumeric](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(TrivialNumeric self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cTrivialNumeric]()
        cdef cTrivialNumeric* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cTrivialNumeric](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cTrivialNumeric](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cTrivialNumeric](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cTrivialNumeric](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (TrivialNumeric, serialize(self)))


cdef cTrivialNestedWithDefault _TrivialNestedWithDefault_defaults = cTrivialNestedWithDefault()

cdef class TrivialNestedWithDefault(thrift.py3.types.Struct):

    def __init__(
        TrivialNestedWithDefault self, *,
        z=None,
        TrivialNumeric n=None
    ):
        if z is not None:
            if not isinstance(z, int):
                raise TypeError(f'z is not a { int !r}.')
            z = <int32_t> z

        self._cpp_obj = move(TrivialNestedWithDefault._make_instance(
          NULL,
          NULL,
          z,
          n,
        ))

    def __call__(
        TrivialNestedWithDefault self,
        z=__NOTSET,
        n=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[2] __isNOTSET  # so make_instance is typed

        changes = False
        if z is ___NOTSET:
            __isNOTSET[0] = True
            z = None
        else:
            __isNOTSET[0] = False
            changes = True

        if n is ___NOTSET:
            __isNOTSET[1] = True
            n = None
        else:
            __isNOTSET[1] = False
            changes = True


        if not changes:
            return self

        if z is not None:
            if not isinstance(z, int):
                raise TypeError(f'z is not a { int !r}.')
            z = <int32_t> z

        if n is not None:
            if not isinstance(n, TrivialNumeric):
                raise TypeError(f'n is not a { TrivialNumeric !r}.')

        inst = <TrivialNestedWithDefault>TrivialNestedWithDefault.__new__(TrivialNestedWithDefault)
        inst._cpp_obj = move(TrivialNestedWithDefault._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          z,
          n,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cTrivialNestedWithDefault] _make_instance(
        cTrivialNestedWithDefault* base_instance,
        bint* __isNOTSET,
        object z ,
        TrivialNumeric n 
    ) except *:
        cdef unique_ptr[cTrivialNestedWithDefault] c_inst
        if base_instance:
            c_inst = make_unique[cTrivialNestedWithDefault](deref(base_instance))
        else:
            c_inst = make_unique[cTrivialNestedWithDefault]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and z is None:
                deref(c_inst).z = _TrivialNestedWithDefault_defaults.z
                deref(c_inst).__isset.z = False
                pass

            if not __isNOTSET[1] and n is None:
                deref(c_inst).n = _TrivialNestedWithDefault_defaults.n
                deref(c_inst).__isset.n = False
                pass

        if z is not None:
            deref(c_inst).z = z
            deref(c_inst).__isset.z = True
        if n is not None:
            deref(c_inst).n = deref((<TrivialNumeric?> n)._cpp_obj)
            deref(c_inst).__isset.n = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'z', self.z
        yield 'n', self.n

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cTrivialNestedWithDefault] cpp_obj):
        inst = <TrivialNestedWithDefault>TrivialNestedWithDefault.__new__(TrivialNestedWithDefault)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def z(self):

        return deref(self._cpp_obj).z

    @property
    def n(self):

        if self.__field_n is None:
            self.__field_n = TrivialNumeric.create(reference_shared_ptr_n(self._cpp_obj, deref(self._cpp_obj).n))
        return self.__field_n


    def __hash__(TrivialNestedWithDefault self):
        if not self.__hash:
            self.__hash = hash((
            self.z,
            self.n,
            ))
        return self.__hash

    def __repr__(TrivialNestedWithDefault self):
        return f'TrivialNestedWithDefault(z={repr(self.z)}, n={repr(self.n)})'
    def __copy__(TrivialNestedWithDefault self):
        cdef shared_ptr[cTrivialNestedWithDefault] cpp_obj = make_shared[cTrivialNestedWithDefault](
            deref(self._cpp_obj)
        )
        return TrivialNestedWithDefault.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, TrivialNestedWithDefault) and
                isinstance(other, TrivialNestedWithDefault)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cTrivialNestedWithDefault* cself = (<TrivialNestedWithDefault>self)._cpp_obj.get()
        cdef cTrivialNestedWithDefault* cother = (<TrivialNestedWithDefault>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return not (deref(cself) == deref(cother))
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(TrivialNestedWithDefault self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cTrivialNestedWithDefault* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cTrivialNestedWithDefault](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cTrivialNestedWithDefault](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cTrivialNestedWithDefault](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cTrivialNestedWithDefault](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(TrivialNestedWithDefault self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cTrivialNestedWithDefault]()
        cdef cTrivialNestedWithDefault* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cTrivialNestedWithDefault](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cTrivialNestedWithDefault](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cTrivialNestedWithDefault](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cTrivialNestedWithDefault](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (TrivialNestedWithDefault, serialize(self)))


cdef cComplexString _ComplexString_defaults = cComplexString()

cdef class ComplexString(thrift.py3.types.Struct):

    def __init__(
        ComplexString self, *,
        str a=None,
        b=None
    ):
        self._cpp_obj = move(ComplexString._make_instance(
          NULL,
          NULL,
          a,
          b,
        ))

    def __call__(
        ComplexString self,
        a=__NOTSET,
        b=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[2] __isNOTSET  # so make_instance is typed

        changes = False
        if a is ___NOTSET:
            __isNOTSET[0] = True
            a = None
        else:
            __isNOTSET[0] = False
            changes = True

        if b is ___NOTSET:
            __isNOTSET[1] = True
            b = None
        else:
            __isNOTSET[1] = False
            changes = True


        if not changes:
            return self

        if a is not None:
            if not isinstance(a, str):
                raise TypeError(f'a is not a { str !r}.')

        inst = <ComplexString>ComplexString.__new__(ComplexString)
        inst._cpp_obj = move(ComplexString._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          a,
          b,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cComplexString] _make_instance(
        cComplexString* base_instance,
        bint* __isNOTSET,
        str a ,
        object b 
    ) except *:
        cdef unique_ptr[cComplexString] c_inst
        if base_instance:
            c_inst = make_unique[cComplexString](deref(base_instance))
        else:
            c_inst = make_unique[cComplexString]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and a is None:
                deref(c_inst).a = _ComplexString_defaults.a
                deref(c_inst).__isset.a = False
                pass

            if not __isNOTSET[1] and b is None:
                deref(c_inst).b = _ComplexString_defaults.b
                deref(c_inst).__isset.b = False
                pass

        if a is not None:
            deref(c_inst).a = thrift.py3.types.move(thrift.py3.types.bytes_to_string(a.encode('utf-8')))
            deref(c_inst).__isset.a = True
        if b is not None:
            deref(c_inst).b = deref(Map__string_i32(b)._cpp_obj)
            deref(c_inst).__isset.b = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'a', self.a
        yield 'b', self.b

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cComplexString] cpp_obj):
        inst = <ComplexString>ComplexString.__new__(ComplexString)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def a(self):

        return (<bytes>deref(self._cpp_obj).a).decode('UTF-8')

    @property
    def b(self):

        if self.__field_b is None:
            self.__field_b = Map__string_i32.create(reference_shared_ptr_b(self._cpp_obj, deref(self._cpp_obj).b))
        return self.__field_b


    def __hash__(ComplexString self):
        if not self.__hash:
            self.__hash = hash((
            self.a,
            self.b,
            ))
        return self.__hash

    def __repr__(ComplexString self):
        return f'ComplexString(a={repr(self.a)}, b={repr(self.b)})'
    def __copy__(ComplexString self):
        cdef shared_ptr[cComplexString] cpp_obj = make_shared[cComplexString](
            deref(self._cpp_obj)
        )
        return ComplexString.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, ComplexString) and
                isinstance(other, ComplexString)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cComplexString* cself = (<ComplexString>self)._cpp_obj.get()
        cdef cComplexString* cother = (<ComplexString>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return not (deref(cself) == deref(cother))
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(ComplexString self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cComplexString* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cComplexString](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cComplexString](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cComplexString](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cComplexString](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(ComplexString self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cComplexString]()
        cdef cComplexString* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cComplexString](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cComplexString](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cComplexString](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cComplexString](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (ComplexString, serialize(self)))


cdef cComplexNestedWithDefault _ComplexNestedWithDefault_defaults = cComplexNestedWithDefault()

cdef class ComplexNestedWithDefault(thrift.py3.types.Struct):

    def __init__(
        ComplexNestedWithDefault self, *,
        str z=None,
        ComplexString n=None
    ):
        self._cpp_obj = move(ComplexNestedWithDefault._make_instance(
          NULL,
          NULL,
          z,
          n,
        ))

    def __call__(
        ComplexNestedWithDefault self,
        z=__NOTSET,
        n=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[2] __isNOTSET  # so make_instance is typed

        changes = False
        if z is ___NOTSET:
            __isNOTSET[0] = True
            z = None
        else:
            __isNOTSET[0] = False
            changes = True

        if n is ___NOTSET:
            __isNOTSET[1] = True
            n = None
        else:
            __isNOTSET[1] = False
            changes = True


        if not changes:
            return self

        if z is not None:
            if not isinstance(z, str):
                raise TypeError(f'z is not a { str !r}.')

        if n is not None:
            if not isinstance(n, ComplexString):
                raise TypeError(f'n is not a { ComplexString !r}.')

        inst = <ComplexNestedWithDefault>ComplexNestedWithDefault.__new__(ComplexNestedWithDefault)
        inst._cpp_obj = move(ComplexNestedWithDefault._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          z,
          n,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cComplexNestedWithDefault] _make_instance(
        cComplexNestedWithDefault* base_instance,
        bint* __isNOTSET,
        str z ,
        ComplexString n 
    ) except *:
        cdef unique_ptr[cComplexNestedWithDefault] c_inst
        if base_instance:
            c_inst = make_unique[cComplexNestedWithDefault](deref(base_instance))
        else:
            c_inst = make_unique[cComplexNestedWithDefault]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and z is None:
                deref(c_inst).z = _ComplexNestedWithDefault_defaults.z
                deref(c_inst).__isset.z = False
                pass

            if not __isNOTSET[1] and n is None:
                deref(c_inst).n = _ComplexNestedWithDefault_defaults.n
                deref(c_inst).__isset.n = False
                pass

        if z is not None:
            deref(c_inst).z = thrift.py3.types.move(thrift.py3.types.bytes_to_string(z.encode('utf-8')))
            deref(c_inst).__isset.z = True
        if n is not None:
            deref(c_inst).n = deref((<ComplexString?> n)._cpp_obj)
            deref(c_inst).__isset.n = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'z', self.z
        yield 'n', self.n

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cComplexNestedWithDefault] cpp_obj):
        inst = <ComplexNestedWithDefault>ComplexNestedWithDefault.__new__(ComplexNestedWithDefault)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def z(self):

        return (<bytes>deref(self._cpp_obj).z).decode('UTF-8')

    @property
    def n(self):

        if self.__field_n is None:
            self.__field_n = ComplexString.create(reference_shared_ptr_n(self._cpp_obj, deref(self._cpp_obj).n))
        return self.__field_n


    def __hash__(ComplexNestedWithDefault self):
        if not self.__hash:
            self.__hash = hash((
            self.z,
            self.n,
            ))
        return self.__hash

    def __repr__(ComplexNestedWithDefault self):
        return f'ComplexNestedWithDefault(z={repr(self.z)}, n={repr(self.n)})'
    def __copy__(ComplexNestedWithDefault self):
        cdef shared_ptr[cComplexNestedWithDefault] cpp_obj = make_shared[cComplexNestedWithDefault](
            deref(self._cpp_obj)
        )
        return ComplexNestedWithDefault.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, ComplexNestedWithDefault) and
                isinstance(other, ComplexNestedWithDefault)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cComplexNestedWithDefault* cself = (<ComplexNestedWithDefault>self)._cpp_obj.get()
        cdef cComplexNestedWithDefault* cother = (<ComplexNestedWithDefault>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return not (deref(cself) == deref(cother))
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(ComplexNestedWithDefault self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cComplexNestedWithDefault* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cComplexNestedWithDefault](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cComplexNestedWithDefault](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cComplexNestedWithDefault](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cComplexNestedWithDefault](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(ComplexNestedWithDefault self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cComplexNestedWithDefault]()
        cdef cComplexNestedWithDefault* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cComplexNestedWithDefault](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cComplexNestedWithDefault](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cComplexNestedWithDefault](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cComplexNestedWithDefault](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (ComplexNestedWithDefault, serialize(self)))


cdef cMinPadding _MinPadding_defaults = cMinPadding()

cdef class MinPadding(thrift.py3.types.Struct):

    def __init__(
        MinPadding self, *,
        small,
        big,
        medium,
        biggish,
        tiny
    ):
        if small is not None:
            if not isinstance(small, int):
                raise TypeError(f'small is not a { int !r}.')
            small = <int8_t> small

        if big is not None:
            if not isinstance(big, int):
                raise TypeError(f'big is not a { int !r}.')
            big = <int64_t> big

        if medium is not None:
            if not isinstance(medium, int):
                raise TypeError(f'medium is not a { int !r}.')
            medium = <int16_t> medium

        if biggish is not None:
            if not isinstance(biggish, int):
                raise TypeError(f'biggish is not a { int !r}.')
            biggish = <int32_t> biggish

        if tiny is not None:
            if not isinstance(tiny, int):
                raise TypeError(f'tiny is not a { int !r}.')
            tiny = <int8_t> tiny

        self._cpp_obj = move(MinPadding._make_instance(
          NULL,
          NULL,
          small,
          big,
          medium,
          biggish,
          tiny,
        ))

    def __call__(
        MinPadding self,
        small=__NOTSET,
        big=__NOTSET,
        medium=__NOTSET,
        biggish=__NOTSET,
        tiny=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[5] __isNOTSET  # so make_instance is typed

        changes = False
        if small is ___NOTSET:
            __isNOTSET[0] = True
            small = None
        else:
            __isNOTSET[0] = False
            changes = True

        if big is ___NOTSET:
            __isNOTSET[1] = True
            big = None
        else:
            __isNOTSET[1] = False
            changes = True

        if medium is ___NOTSET:
            __isNOTSET[2] = True
            medium = None
        else:
            __isNOTSET[2] = False
            changes = True

        if biggish is ___NOTSET:
            __isNOTSET[3] = True
            biggish = None
        else:
            __isNOTSET[3] = False
            changes = True

        if tiny is ___NOTSET:
            __isNOTSET[4] = True
            tiny = None
        else:
            __isNOTSET[4] = False
            changes = True


        if not changes:
            return self

        if not __isNOTSET[0] and small is None:
            raise TypeError('field small is required and has no default, it can not be unset')
        if small is not None:
            if not isinstance(small, int):
                raise TypeError(f'small is not a { int !r}.')
            small = <int8_t> small

        if not __isNOTSET[1] and big is None:
            raise TypeError('field big is required and has no default, it can not be unset')
        if big is not None:
            if not isinstance(big, int):
                raise TypeError(f'big is not a { int !r}.')
            big = <int64_t> big

        if not __isNOTSET[2] and medium is None:
            raise TypeError('field medium is required and has no default, it can not be unset')
        if medium is not None:
            if not isinstance(medium, int):
                raise TypeError(f'medium is not a { int !r}.')
            medium = <int16_t> medium

        if not __isNOTSET[3] and biggish is None:
            raise TypeError('field biggish is required and has no default, it can not be unset')
        if biggish is not None:
            if not isinstance(biggish, int):
                raise TypeError(f'biggish is not a { int !r}.')
            biggish = <int32_t> biggish

        if not __isNOTSET[4] and tiny is None:
            raise TypeError('field tiny is required and has no default, it can not be unset')
        if tiny is not None:
            if not isinstance(tiny, int):
                raise TypeError(f'tiny is not a { int !r}.')
            tiny = <int8_t> tiny

        inst = <MinPadding>MinPadding.__new__(MinPadding)
        inst._cpp_obj = move(MinPadding._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          small,
          big,
          medium,
          biggish,
          tiny,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cMinPadding] _make_instance(
        cMinPadding* base_instance,
        bint* __isNOTSET,
        object small ,
        object big ,
        object medium ,
        object biggish ,
        object tiny 
    ) except *:
        cdef unique_ptr[cMinPadding] c_inst
        if base_instance:
            c_inst = make_unique[cMinPadding](deref(base_instance))
        else:
            c_inst = make_unique[cMinPadding]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and small is None:
                pass

            if not __isNOTSET[1] and big is None:
                pass

            if not __isNOTSET[2] and medium is None:
                pass

            if not __isNOTSET[3] and biggish is None:
                pass

            if not __isNOTSET[4] and tiny is None:
                pass

        if small is not None:
            deref(c_inst).small = small
        if big is not None:
            deref(c_inst).big = big
        if medium is not None:
            deref(c_inst).medium = medium
        if biggish is not None:
            deref(c_inst).biggish = biggish
        if tiny is not None:
            deref(c_inst).tiny = tiny
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'small', self.small
        yield 'big', self.big
        yield 'medium', self.medium
        yield 'biggish', self.biggish
        yield 'tiny', self.tiny

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cMinPadding] cpp_obj):
        inst = <MinPadding>MinPadding.__new__(MinPadding)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def small(self):

        return deref(self._cpp_obj).small

    @property
    def big(self):

        return deref(self._cpp_obj).big

    @property
    def medium(self):

        return deref(self._cpp_obj).medium

    @property
    def biggish(self):

        return deref(self._cpp_obj).biggish

    @property
    def tiny(self):

        return deref(self._cpp_obj).tiny


    def __hash__(MinPadding self):
        if not self.__hash:
            self.__hash = hash((
            self.small,
            self.big,
            self.medium,
            self.biggish,
            self.tiny,
            ))
        return self.__hash

    def __repr__(MinPadding self):
        return f'MinPadding(small={repr(self.small)}, big={repr(self.big)}, medium={repr(self.medium)}, biggish={repr(self.biggish)}, tiny={repr(self.tiny)})'
    def __copy__(MinPadding self):
        cdef shared_ptr[cMinPadding] cpp_obj = make_shared[cMinPadding](
            deref(self._cpp_obj)
        )
        return MinPadding.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, MinPadding) and
                isinstance(other, MinPadding)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cMinPadding* cself = (<MinPadding>self)._cpp_obj.get()
        cdef cMinPadding* cother = (<MinPadding>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return not (deref(cself) == deref(cother))
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(MinPadding self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cMinPadding* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cMinPadding](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cMinPadding](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cMinPadding](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cMinPadding](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(MinPadding self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cMinPadding]()
        cdef cMinPadding* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cMinPadding](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cMinPadding](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cMinPadding](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cMinPadding](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (MinPadding, serialize(self)))


cdef cMyStruct _MyStruct_defaults = cMyStruct()

cdef class MyStruct(thrift.py3.types.Struct):

    def __init__(
        MyStruct self, *,
        MyIntField=None,
        str MyStringField=None,
        majorVer=None,
        MyDataItem data=None
    ):
        if MyIntField is not None:
            if not isinstance(MyIntField, int):
                raise TypeError(f'MyIntField is not a { int !r}.')
            MyIntField = <int64_t> MyIntField

        if majorVer is not None:
            if not isinstance(majorVer, int):
                raise TypeError(f'majorVer is not a { int !r}.')
            majorVer = <int64_t> majorVer

        self._cpp_obj = move(MyStruct._make_instance(
          NULL,
          NULL,
          MyIntField,
          MyStringField,
          majorVer,
          data,
        ))

    def __call__(
        MyStruct self,
        MyIntField=__NOTSET,
        MyStringField=__NOTSET,
        majorVer=__NOTSET,
        data=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[4] __isNOTSET  # so make_instance is typed

        changes = False
        if MyIntField is ___NOTSET:
            __isNOTSET[0] = True
            MyIntField = None
        else:
            __isNOTSET[0] = False
            changes = True

        if MyStringField is ___NOTSET:
            __isNOTSET[1] = True
            MyStringField = None
        else:
            __isNOTSET[1] = False
            changes = True

        if majorVer is ___NOTSET:
            __isNOTSET[2] = True
            majorVer = None
        else:
            __isNOTSET[2] = False
            changes = True

        if data is ___NOTSET:
            __isNOTSET[3] = True
            data = None
        else:
            __isNOTSET[3] = False
            changes = True


        if not changes:
            return self

        if MyIntField is not None:
            if not isinstance(MyIntField, int):
                raise TypeError(f'MyIntField is not a { int !r}.')
            MyIntField = <int64_t> MyIntField

        if MyStringField is not None:
            if not isinstance(MyStringField, str):
                raise TypeError(f'MyStringField is not a { str !r}.')

        if majorVer is not None:
            if not isinstance(majorVer, int):
                raise TypeError(f'majorVer is not a { int !r}.')
            majorVer = <int64_t> majorVer

        if data is not None:
            if not isinstance(data, MyDataItem):
                raise TypeError(f'data is not a { MyDataItem !r}.')

        inst = <MyStruct>MyStruct.__new__(MyStruct)
        inst._cpp_obj = move(MyStruct._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          MyIntField,
          MyStringField,
          majorVer,
          data,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cMyStruct] _make_instance(
        cMyStruct* base_instance,
        bint* __isNOTSET,
        object MyIntField ,
        str MyStringField ,
        object majorVer ,
        MyDataItem data 
    ) except *:
        cdef unique_ptr[cMyStruct] c_inst
        if base_instance:
            c_inst = make_unique[cMyStruct](deref(base_instance))
        else:
            c_inst = make_unique[cMyStruct]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and MyIntField is None:
                deref(c_inst).MyIntField = _MyStruct_defaults.MyIntField
                deref(c_inst).__isset.MyIntField = False
                pass

            if not __isNOTSET[1] and MyStringField is None:
                deref(c_inst).MyStringField = _MyStruct_defaults.MyStringField
                deref(c_inst).__isset.MyStringField = False
                pass

            if not __isNOTSET[2] and majorVer is None:
                deref(c_inst).majorVer = _MyStruct_defaults.majorVer
                deref(c_inst).__isset.majorVer = False
                pass

            if not __isNOTSET[3] and data is None:
                deref(c_inst).data = _MyStruct_defaults.data
                deref(c_inst).__isset.data = False
                pass

        if MyIntField is not None:
            deref(c_inst).MyIntField = MyIntField
            deref(c_inst).__isset.MyIntField = True
        if MyStringField is not None:
            deref(c_inst).MyStringField = thrift.py3.types.move(thrift.py3.types.bytes_to_string(MyStringField.encode('utf-8')))
            deref(c_inst).__isset.MyStringField = True
        if majorVer is not None:
            deref(c_inst).majorVer = majorVer
            deref(c_inst).__isset.majorVer = True
        if data is not None:
            deref(c_inst).data = deref((<MyDataItem?> data)._cpp_obj)
            deref(c_inst).__isset.data = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'MyIntField', self.MyIntField
        yield 'MyStringField', self.MyStringField
        yield 'majorVer', self.majorVer
        yield 'data', self.data

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cMyStruct] cpp_obj):
        inst = <MyStruct>MyStruct.__new__(MyStruct)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def MyIntField(self):

        return deref(self._cpp_obj).MyIntField

    @property
    def MyStringField(self):

        return (<bytes>deref(self._cpp_obj).MyStringField).decode('UTF-8')

    @property
    def majorVer(self):

        return deref(self._cpp_obj).majorVer

    @property
    def data(self):

        if self.__field_data is None:
            self.__field_data = MyDataItem.create(reference_shared_ptr_data(self._cpp_obj, deref(self._cpp_obj).data))
        return self.__field_data


    def __hash__(MyStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.MyIntField,
            self.MyStringField,
            self.majorVer,
            self.data,
            ))
        return self.__hash

    cdef __MyStruct_eq(MyStruct self, MyStruct other):
        if self.MyIntField != other.MyIntField:
            return False
        elif self.MyStringField != other.MyStringField:
            return False
        elif self.majorVer != other.majorVer:
            return False
        elif self.data != other.data:
            return False
        return True

    def __repr__(MyStruct self):
        return f'MyStruct(MyIntField={repr(self.MyIntField)}, MyStringField={repr(self.MyStringField)}, majorVer={repr(self.majorVer)}, data={repr(self.data)})'
    def __copy__(MyStruct self):
        cdef shared_ptr[cMyStruct] cpp_obj = make_shared[cMyStruct](
            deref(self._cpp_obj)
        )
        return MyStruct.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, MyStruct) and
                isinstance(other, MyStruct)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        if cop == Py_EQ:
            return self.__MyStruct_eq(other)
        elif cop == Py_NE:
            return not self.__MyStruct_eq(other)
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(MyStruct self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cMyStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cMyStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cMyStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cMyStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cMyStruct](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(MyStruct self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cMyStruct]()
        cdef cMyStruct* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cMyStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cMyStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cMyStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cMyStruct](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (MyStruct, serialize(self)))


cdef cMyDataItem _MyDataItem_defaults = cMyDataItem()

cdef class MyDataItem(thrift.py3.types.Struct):

    def __init__(
        MyDataItem self, *
    ):
        self._cpp_obj = move(MyDataItem._make_instance(
          NULL,
          NULL,
        ))

    def __call__(
        MyDataItem self
    ):
        return self

    @staticmethod
    cdef unique_ptr[cMyDataItem] _make_instance(
        cMyDataItem* base_instance,
        bint* __isNOTSET
    ) except *:
        cdef unique_ptr[cMyDataItem] c_inst
        if base_instance:
            c_inst = make_unique[cMyDataItem](deref(base_instance))
        else:
            c_inst = make_unique[cMyDataItem]()

        if base_instance:
            # Convert None's to default value. (or unset)
            pass
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        return iter(())

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cMyDataItem] cpp_obj):
        inst = <MyDataItem>MyDataItem.__new__(MyDataItem)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst


    def __hash__(MyDataItem self):
        if not self.__hash:
            self.__hash = hash((
            type(self)   # Hash the class there are no fields
            ))
        return self.__hash

    cdef __MyDataItem_eq(MyDataItem self, MyDataItem other):
        if id(self) != id(other):
            return False
        return True

    def __repr__(MyDataItem self):
        return f'MyDataItem()'
    def __copy__(MyDataItem self):
        cdef shared_ptr[cMyDataItem] cpp_obj = make_shared[cMyDataItem](
            deref(self._cpp_obj)
        )
        return MyDataItem.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, MyDataItem) and
                isinstance(other, MyDataItem)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        if cop == Py_EQ:
            return self.__MyDataItem_eq(other)
        elif cop == Py_NE:
            return not self.__MyDataItem_eq(other)
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(MyDataItem self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cMyDataItem* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cMyDataItem](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cMyDataItem](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cMyDataItem](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cMyDataItem](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(MyDataItem self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cMyDataItem]()
        cdef cMyDataItem* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cMyDataItem](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cMyDataItem](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cMyDataItem](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cMyDataItem](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (MyDataItem, serialize(self)))


cdef cRenaming _Renaming_defaults = cRenaming()

cdef class Renaming(thrift.py3.types.Struct):

    def __init__(
        Renaming self, *,
        foo=None
    ):
        if foo is not None:
            if not isinstance(foo, int):
                raise TypeError(f'foo is not a { int !r}.')
            foo = <int64_t> foo

        self._cpp_obj = move(Renaming._make_instance(
          NULL,
          NULL,
          foo,
        ))

    def __call__(
        Renaming self,
        foo=__NOTSET
    ):
        ___NOTSET = __NOTSET  # Cheaper for larger structs
        cdef bint[1] __isNOTSET  # so make_instance is typed

        changes = False
        if foo is ___NOTSET:
            __isNOTSET[0] = True
            foo = None
        else:
            __isNOTSET[0] = False
            changes = True


        if not changes:
            return self

        if foo is not None:
            if not isinstance(foo, int):
                raise TypeError(f'foo is not a { int !r}.')
            foo = <int64_t> foo

        inst = <Renaming>Renaming.__new__(Renaming)
        inst._cpp_obj = move(Renaming._make_instance(
          self._cpp_obj.get(),
          __isNOTSET,
          foo,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cRenaming] _make_instance(
        cRenaming* base_instance,
        bint* __isNOTSET,
        object foo 
    ) except *:
        cdef unique_ptr[cRenaming] c_inst
        if base_instance:
            c_inst = make_unique[cRenaming](deref(base_instance))
        else:
            c_inst = make_unique[cRenaming]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if not __isNOTSET[0] and foo is None:
                deref(c_inst).foo = _Renaming_defaults.foo
                deref(c_inst).__isset.foo = False
                pass

        if foo is not None:
            deref(c_inst).foo = foo
            deref(c_inst).__isset.foo = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'foo', self.foo

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cRenaming] cpp_obj):
        inst = <Renaming>Renaming.__new__(Renaming)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def foo(self):

        return deref(self._cpp_obj).foo


    def __hash__(Renaming self):
        if not self.__hash:
            self.__hash = hash((
            self.foo,
            ))
        return self.__hash

    def __repr__(Renaming self):
        return f'Renaming(foo={repr(self.foo)})'
    def __copy__(Renaming self):
        cdef shared_ptr[cRenaming] cpp_obj = make_shared[cRenaming](
            deref(self._cpp_obj)
        )
        return Renaming.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, Renaming) and
                isinstance(other, Renaming)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cRenaming* cself = (<Renaming>self)._cpp_obj.get()
        cdef cRenaming* cother = (<Renaming>other)._cpp_obj.get()
        if cop == Py_EQ:
            return deref(cself) == deref(cother)
        elif cop == Py_NE:
            return not (deref(cself) == deref(cother))
        elif cop == Py_LT:
            return deref(cself) < deref(cother)
        elif cop == Py_LE:
            return deref(cself) <= deref(cother)
        elif cop == Py_GT:
            return deref(cself) > deref(cother)
        elif cop == Py_GE:
            return deref(cself) >= deref(cother)
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(Renaming self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cRenaming* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cRenaming](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cRenaming](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cRenaming](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cRenaming](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(Renaming self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cRenaming]()
        cdef cRenaming* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cRenaming](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cRenaming](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cRenaming](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cRenaming](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (Renaming, serialize(self)))


cdef class std_unordered_map__Map__i32_string:
    def __init__(self, items=None):
        if isinstance(items, std_unordered_map__Map__i32_string):
            self._cpp_obj = (<std_unordered_map__Map__i32_string> items)._cpp_obj
        else:
            self._cpp_obj = std_unordered_map__Map__i32_string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[std_unordered_map[int32_t,string]] c_items):
        inst = <std_unordered_map__Map__i32_string>std_unordered_map__Map__i32_string.__new__(std_unordered_map__Map__i32_string)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(std_unordered_map__Map__i32_string self):
        cdef shared_ptr[std_unordered_map[int32_t,string]] cpp_obj = make_shared[std_unordered_map[int32_t,string]](
            deref(self._cpp_obj)
        )
        return std_unordered_map__Map__i32_string.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[std_unordered_map[int32_t,string]] _make_instance(object items) except *:
        cdef shared_ptr[std_unordered_map[int32_t,string]] c_inst = make_shared[std_unordered_map[int32_t,string]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int32_t> key
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst)[key] = item.encode('UTF-8')
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err from None
        cdef std_unordered_map[int32_t,string].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef std_unordered_map[int32_t,string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield citem
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef std_unordered_map[int32_t,string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef string citem
        cdef std_unordered_map[int32_t,string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey, bytes(citem).decode('UTF-8'))
            inc(loc)

    def __reduce__(self):
        return (std_unordered_map__Map__i32_string, (dict(self), ))


Mapping.register(std_unordered_map__Map__i32_string)

cdef class List__i64:
    def __init__(self, items=None):
        if isinstance(items, List__i64):
            self._cpp_obj = (<List__i64> items)._cpp_obj
        else:
            self._cpp_obj = List__i64._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[int64_t]] c_items):
        inst = <List__i64>List__i64.__new__(List__i64)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__i64 self):
        cdef shared_ptr[vector[int64_t]] cpp_obj = make_shared[vector[int64_t]](
            deref(self._cpp_obj)
        )
        return List__i64.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[int64_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[int64_t]] c_inst = make_shared[vector[int64_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int64_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[int64_t]] c_inst
        cdef int64_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[int64_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__i64.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[vector[int64_t].iterator, int64_t](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int64_t citem
        cdef vector[int64_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int64_t citem
        cdef vector[int64_t].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef vector[int64_t].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef vector[int64_t].iterator loc = std_libcpp.find[vector[int64_t].iterator, int64_t](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <int64_t> std_libcpp.count[vector[int64_t].iterator, int64_t](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    def __reduce__(self):
        return (List__i64, (list(self), ))


Sequence.register(List__i64)

cdef class Map__binary_i64:
    def __init__(self, items=None):
        if isinstance(items, Map__binary_i64):
            self._cpp_obj = (<Map__binary_i64> items)._cpp_obj
        else:
            self._cpp_obj = Map__binary_i64._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,int64_t]] c_items):
        inst = <Map__binary_i64>Map__binary_i64.__new__(Map__binary_i64)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__binary_i64 self):
        cdef shared_ptr[cmap[string,int64_t]] cpp_obj = make_shared[cmap[string,int64_t]](
            deref(self._cpp_obj)
        )
        return Map__binary_i64.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[string,int64_t]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,int64_t]] c_inst = make_shared[cmap[string,int64_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, bytes):
                    raise TypeError(f"{key!r} is not of type bytes")
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int64_t> item

                deref(c_inst)[key] = item
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, bytes):
            raise err from None
        cdef cmap[string,int64_t].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef int64_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef cmap[string,int64_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem)
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, bytes):
            return False
        cdef string ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, bytes):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int64_t citem
        cdef cmap[string,int64_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield citem
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef int64_t citem
        cdef cmap[string,int64_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey, citem)
            inc(loc)

    def __reduce__(self):
        return (Map__binary_i64, (dict(self), ))


Mapping.register(Map__binary_i64)

cdef class List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[int32_t]] c_items):
        inst = <List__i32>List__i32.__new__(List__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__i32 self):
        cdef shared_ptr[vector[int32_t]] cpp_obj = make_shared[vector[int32_t]](
            deref(self._cpp_obj)
        )
        return List__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[int32_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[int32_t]] c_inst = make_shared[vector[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__i32.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[vector[int32_t].iterator, int32_t](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef vector[int32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef vector[int32_t].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef vector[int32_t].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef vector[int32_t].iterator loc = std_libcpp.find[vector[int32_t].iterator, int32_t](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <int64_t> std_libcpp.count[vector[int32_t].iterator, int32_t](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    def __reduce__(self):
        return (List__i32, (list(self), ))


Sequence.register(List__i32)

cdef class std_list__List__i32:
    def __init__(self, items=None):
        if isinstance(items, std_list__List__i32):
            self._cpp_obj = (<std_list__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = std_list__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[std_list[int32_t]] c_items):
        inst = <std_list__List__i32>std_list__List__i32.__new__(std_list__List__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(std_list__List__i32 self):
        cdef shared_ptr[std_list[int32_t]] cpp_obj = make_shared[std_list[int32_t]](
            deref(self._cpp_obj)
        )
        return std_list__List__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[std_list[int32_t]] _make_instance(object items) except *:
        cdef shared_ptr[std_list[int32_t]] c_inst = make_shared[std_list[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[std_list[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[std_list[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return std_list__List__i32.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[std_list[int32_t].iterator, int32_t](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef std_list[int32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef std_list[int32_t].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef std_list[int32_t].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef std_list[int32_t].iterator loc = std_libcpp.find[std_list[int32_t].iterator, int32_t](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <int64_t> std_libcpp.count[std_list[int32_t].iterator, int32_t](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    def __reduce__(self):
        return (std_list__List__i32, (list(self), ))


Sequence.register(std_list__List__i32)

cdef class std_deque__List__i32:
    def __init__(self, items=None):
        if isinstance(items, std_deque__List__i32):
            self._cpp_obj = (<std_deque__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = std_deque__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[std_deque[int32_t]] c_items):
        inst = <std_deque__List__i32>std_deque__List__i32.__new__(std_deque__List__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(std_deque__List__i32 self):
        cdef shared_ptr[std_deque[int32_t]] cpp_obj = make_shared[std_deque[int32_t]](
            deref(self._cpp_obj)
        )
        return std_deque__List__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[std_deque[int32_t]] _make_instance(object items) except *:
        cdef shared_ptr[std_deque[int32_t]] c_inst = make_shared[std_deque[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[std_deque[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[std_deque[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return std_deque__List__i32.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[std_deque[int32_t].iterator, int32_t](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef std_deque[int32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef std_deque[int32_t].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef std_deque[int32_t].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef std_deque[int32_t].iterator loc = std_libcpp.find[std_deque[int32_t].iterator, int32_t](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <int64_t> std_libcpp.count[std_deque[int32_t].iterator, int32_t](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    def __reduce__(self):
        return (std_deque__List__i32, (list(self), ))


Sequence.register(std_deque__List__i32)

cdef class folly_fbvector__List__i32:
    def __init__(self, items=None):
        if isinstance(items, folly_fbvector__List__i32):
            self._cpp_obj = (<folly_fbvector__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = folly_fbvector__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[folly_fbvector[int32_t]] c_items):
        inst = <folly_fbvector__List__i32>folly_fbvector__List__i32.__new__(folly_fbvector__List__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(folly_fbvector__List__i32 self):
        cdef shared_ptr[folly_fbvector[int32_t]] cpp_obj = make_shared[folly_fbvector[int32_t]](
            deref(self._cpp_obj)
        )
        return folly_fbvector__List__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[folly_fbvector[int32_t]] _make_instance(object items) except *:
        cdef shared_ptr[folly_fbvector[int32_t]] c_inst = make_shared[folly_fbvector[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[folly_fbvector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[folly_fbvector[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return folly_fbvector__List__i32.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[folly_fbvector[int32_t].iterator, int32_t](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef folly_fbvector[int32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef folly_fbvector[int32_t].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef folly_fbvector[int32_t].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef folly_fbvector[int32_t].iterator loc = std_libcpp.find[folly_fbvector[int32_t].iterator, int32_t](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <int64_t> std_libcpp.count[folly_fbvector[int32_t].iterator, int32_t](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    def __reduce__(self):
        return (folly_fbvector__List__i32, (list(self), ))


Sequence.register(folly_fbvector__List__i32)

cdef class folly_small_vector__List__i32:
    def __init__(self, items=None):
        if isinstance(items, folly_small_vector__List__i32):
            self._cpp_obj = (<folly_small_vector__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = folly_small_vector__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[folly_small_vector[int32_t]] c_items):
        inst = <folly_small_vector__List__i32>folly_small_vector__List__i32.__new__(folly_small_vector__List__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(folly_small_vector__List__i32 self):
        cdef shared_ptr[folly_small_vector[int32_t]] cpp_obj = make_shared[folly_small_vector[int32_t]](
            deref(self._cpp_obj)
        )
        return folly_small_vector__List__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[folly_small_vector[int32_t]] _make_instance(object items) except *:
        cdef shared_ptr[folly_small_vector[int32_t]] c_inst = make_shared[folly_small_vector[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[folly_small_vector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[folly_small_vector[int32_t]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return folly_small_vector__List__i32.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[folly_small_vector[int32_t].iterator, int32_t](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef folly_small_vector[int32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef folly_small_vector[int32_t].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef folly_small_vector[int32_t].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef folly_small_vector[int32_t].iterator loc = std_libcpp.find[folly_small_vector[int32_t].iterator, int32_t](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <int64_t> std_libcpp.count[folly_small_vector[int32_t].iterator, int32_t](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    def __reduce__(self):
        return (folly_small_vector__List__i32, (list(self), ))


Sequence.register(folly_small_vector__List__i32)

cdef class folly_sorted_vector_set__Set__i32:
    def __init__(self, items=None):
        if isinstance(items, folly_sorted_vector_set__Set__i32):
            self._cpp_obj = (<folly_sorted_vector_set__Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = folly_sorted_vector_set__Set__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[folly_sorted_vector_set[int32_t]] c_items):
        inst = <folly_sorted_vector_set__Set__i32>folly_sorted_vector_set__Set__i32.__new__(folly_sorted_vector_set__Set__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(folly_sorted_vector_set__Set__i32 self):
        cdef shared_ptr[folly_sorted_vector_set[int32_t]] cpp_obj = make_shared[folly_sorted_vector_set[int32_t]](
            deref(self._cpp_obj)
        )
        return folly_sorted_vector_set__Set__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[folly_sorted_vector_set[int32_t]] _make_instance(object items) except *:
        cdef shared_ptr[folly_sorted_vector_set[int32_t]] c_inst = make_shared[folly_sorted_vector_set[int32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).insert(item)
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef folly_sorted_vector_set[int32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[folly_sorted_vector_set[int32_t]] cself, cother
        cdef folly_sorted_vector_set[int32_t].iterator loc
        if (isinstance(self, folly_sorted_vector_set__Set__i32) and
                isinstance(other, folly_sorted_vector_set__Set__i32)):
            cself = (<folly_sorted_vector_set__Set__i32> self)._cpp_obj
            cother = (<folly_sorted_vector_set__Set__i32> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, folly_sorted_vector_set__Set__i32):
            self = folly_sorted_vector_set__Set__i32(self)
        if not isinstance(other, folly_sorted_vector_set__Set__i32):
            other = folly_sorted_vector_set__Set__i32(other)

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] shretval = \
            make_shared[folly_sorted_vector_set[int32_t]]()

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] cself = (<folly_sorted_vector_set__Set__i32> self)._cpp_obj
        cdef shared_ptr[folly_sorted_vector_set[int32_t]] cother = (<folly_sorted_vector_set__Set__i32> other)._cpp_obj

        cdef folly_sorted_vector_set[int32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return folly_sorted_vector_set__Set__i32.create(move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, folly_sorted_vector_set__Set__i32):
            self = folly_sorted_vector_set__Set__i32(self)
        if not isinstance(other, folly_sorted_vector_set__Set__i32):
            other = folly_sorted_vector_set__Set__i32(other)

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] shretval = \
            make_shared[folly_sorted_vector_set[int32_t]]()

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] cself = (<folly_sorted_vector_set__Set__i32> self)._cpp_obj
        cdef shared_ptr[folly_sorted_vector_set[int32_t]] cother = (<folly_sorted_vector_set__Set__i32> other)._cpp_obj

        cdef folly_sorted_vector_set[int32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return folly_sorted_vector_set__Set__i32.create(move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, folly_sorted_vector_set__Set__i32):
            self = folly_sorted_vector_set__Set__i32(self)
        if not isinstance(other, folly_sorted_vector_set__Set__i32):
            other = folly_sorted_vector_set__Set__i32(other)

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] shretval = \
            make_shared[folly_sorted_vector_set[int32_t]]()

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] cself = (<folly_sorted_vector_set__Set__i32> self)._cpp_obj
        cdef shared_ptr[folly_sorted_vector_set[int32_t]] cother = (<folly_sorted_vector_set__Set__i32> other)._cpp_obj

        cdef folly_sorted_vector_set[int32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return folly_sorted_vector_set__Set__i32.create(move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, folly_sorted_vector_set__Set__i32):
            self = folly_sorted_vector_set__Set__i32(self)
        if not isinstance(other, folly_sorted_vector_set__Set__i32):
            other = folly_sorted_vector_set__Set__i32(other)

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] shretval = \
            make_shared[folly_sorted_vector_set[int32_t]]()

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] cself = (<folly_sorted_vector_set__Set__i32> self)._cpp_obj
        cdef shared_ptr[folly_sorted_vector_set[int32_t]] cother = (<folly_sorted_vector_set__Set__i32> other)._cpp_obj

        cdef folly_sorted_vector_set[int32_t].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return folly_sorted_vector_set__Set__i32.create(move_shared(shretval))

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other

    def __reduce__(self):
        return (folly_sorted_vector_set__Set__i32, (set(self), ))


Set.register(folly_sorted_vector_set__Set__i32)

cdef class folly_sorted_vector_map__Map__i32_string:
    def __init__(self, items=None):
        if isinstance(items, folly_sorted_vector_map__Map__i32_string):
            self._cpp_obj = (<folly_sorted_vector_map__Map__i32_string> items)._cpp_obj
        else:
            self._cpp_obj = folly_sorted_vector_map__Map__i32_string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[folly_sorted_vector_map[int32_t,string]] c_items):
        inst = <folly_sorted_vector_map__Map__i32_string>folly_sorted_vector_map__Map__i32_string.__new__(folly_sorted_vector_map__Map__i32_string)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(folly_sorted_vector_map__Map__i32_string self):
        cdef shared_ptr[folly_sorted_vector_map[int32_t,string]] cpp_obj = make_shared[folly_sorted_vector_map[int32_t,string]](
            deref(self._cpp_obj)
        )
        return folly_sorted_vector_map__Map__i32_string.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[folly_sorted_vector_map[int32_t,string]] _make_instance(object items) except *:
        cdef shared_ptr[folly_sorted_vector_map[int32_t,string]] c_inst = make_shared[folly_sorted_vector_map[int32_t,string]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int32_t> key
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst)[key] = item.encode('UTF-8')
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err from None
        cdef folly_sorted_vector_map[int32_t,string].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef folly_sorted_vector_map[int32_t,string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield citem
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef folly_sorted_vector_map[int32_t,string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef string citem
        cdef folly_sorted_vector_map[int32_t,string].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey, bytes(citem).decode('UTF-8'))
            inc(loc)

    def __reduce__(self):
        return (folly_sorted_vector_map__Map__i32_string, (dict(self), ))


Mapping.register(folly_sorted_vector_map__Map__i32_string)

cdef class std_list_int32_t__List__i32:
    def __init__(self, items=None):
        if isinstance(items, std_list_int32_t__List__i32):
            self._cpp_obj = (<std_list_int32_t__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = std_list_int32_t__List__i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[std_list_int32_t] c_items):
        inst = <std_list_int32_t__List__i32>std_list_int32_t__List__i32.__new__(std_list_int32_t__List__i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(std_list_int32_t__List__i32 self):
        cdef shared_ptr[std_list_int32_t] cpp_obj = make_shared[std_list_int32_t](
            deref(self._cpp_obj)
        )
        return std_list_int32_t__List__i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[std_list_int32_t] _make_instance(object items) except *:
        cdef shared_ptr[std_list_int32_t] c_inst = make_shared[std_list_int32_t]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item
                deref(c_inst).push_back(item)
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[std_list_int32_t] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[std_list_int32_t]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return std_list_int32_t__List__i32.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return std_libcpp.find[std_list_int32_t.iterator, int32_t](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef std_list_int32_t.iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef std_list_int32_t.reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, int):
            raise err
        cdef std_list_int32_t.iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef std_list_int32_t.iterator loc = std_libcpp.find[std_list_int32_t.iterator, int32_t](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, int):
            return 0
        return <int64_t> std_libcpp.count[std_list_int32_t.iterator, int32_t](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)

    def __reduce__(self):
        return (std_list_int32_t__List__i32, (list(self), ))


Sequence.register(std_list_int32_t__List__i32)

cdef class Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_i32):
            self._cpp_obj = (<Map__string_i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_i32._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,int32_t]] c_items):
        inst = <Map__string_i32>Map__string_i32.__new__(Map__string_i32)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__string_i32 self):
        cdef shared_ptr[cmap[string,int32_t]] cpp_obj = make_shared[cmap[string,int32_t]](
            deref(self._cpp_obj)
        )
        return Map__string_i32.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[string,int32_t]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,int32_t]] c_inst = make_shared[cmap[string,int32_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <int32_t> item

                deref(c_inst)[key.encode('UTF-8')] = item
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, str):
            raise err from None
        cdef cmap[string,int32_t].iterator iter = deref(
            self._cpp_obj).find(key.encode('UTF-8'))
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef int32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef cmap[string,int32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, str):
            return False
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, str):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef cmap[string,int32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield citem
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef int32_t citem
        cdef cmap[string,int32_t].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey.data().decode('UTF-8'), citem)
            inc(loc)

    def __reduce__(self):
        return (Map__string_i32, (dict(self), ))


Mapping.register(Map__string_i32)

TBinary = bytes
