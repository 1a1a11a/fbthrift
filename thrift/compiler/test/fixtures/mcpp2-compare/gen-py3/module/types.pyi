#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

import thrift.py3.types
import thrift.py3.exceptions
from thrift.py3.types import NOTSET
from thrift.py3.serializer import Protocol
import typing as _typing

import sys
import itertools
from enum import Enum
import includes.types as _includes_types


class MyEnumA(Enum):
    fieldA: ...
    fieldB: ...
    fieldC: ...
    value: int


class AnnotatedEnum(Enum):
    FIELDA: ...
    FIELDB: ...
    FIELDC: ...
    value: int


class AnnotatedEnum2(Enum):
    FIELDA: ...
    FIELDB: ...
    FIELDC: ...
    value: int


class MyEnumB(Enum):
    AField: ...
    value: int


# Forward Definitions for Structs
class Empty(thrift.py3.types.Struct): ...
class ASimpleStruct(thrift.py3.types.Struct): ...
class ASimpleStructNoexcept(thrift.py3.types.Struct): ...
class MyStruct(thrift.py3.types.Struct): ...
class SimpleUnion(thrift.py3.types.Union): ...
class ComplexUnion(thrift.py3.types.Union): ...
class AnException(thrift.py3.exceptions.Error): ...
class AnotherException(thrift.py3.exceptions.Error): ...
class containerStruct(thrift.py3.types.Struct): ...
class MyIncludedStruct(thrift.py3.types.Struct): ...
class AnnotatedStruct(thrift.py3.types.Struct): ...
class FloatStruct(thrift.py3.types.Struct): ...
class FloatUnion(thrift.py3.types.Union): ...
# Forward Definitions for Containers
class Map__string_i64(_typing.Mapping[str, int]): ...
class Map__Empty_MyStruct(_typing.Mapping[Empty, MyStruct]): ...
class List__Map__Empty_MyStruct(_typing.Sequence[_typing.Mapping[Empty, MyStruct]]): ...
class List__List__Map__Empty_MyStruct(_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]): ...
class List__List__List__Map__Empty_MyStruct(_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]): ...
class List__MyEnumA(_typing.Sequence[MyEnumA]): ...
class Set__MyStruct(_typing.AbstractSet[MyStruct]): ...
class List__ComplexUnion(_typing.Sequence[ComplexUnion]): ...
class List__string(_typing.Sequence[str]): ...
class Set__List__string(_typing.AbstractSet[_typing.Sequence[str]]): ...
class Set__List__List__Map__Empty_MyStruct(_typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]): ...
class Map__i32_List__string(_typing.Mapping[int, _typing.Sequence[str]]): ...
class List__bool(_typing.Sequence[bool]): ...
class List__i32(_typing.Sequence[int]): ...
class List__List__i32(_typing.Sequence[_typing.Sequence[int]]): ...
class List__List__List__i32(_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]): ...
class List__List__List__List__i32(_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]): ...
class Set__List__i32(_typing.AbstractSet[_typing.Sequence[int]]): ...
class Set__string(_typing.AbstractSet[str]): ...
class List__Set__string(_typing.Sequence[_typing.AbstractSet[str]]): ...
class Map__List__Set__string_string(_typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]): ...
class Map__Set__List__i32_Map__List__Set__string_string(_typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]): ...
class List__binary(_typing.Sequence[bytes]): ...
class Map__MyEnumA_string(_typing.Mapping[MyEnumA, str]): ...
class Set__i64(_typing.AbstractSet[int]): ...
class Map__string_i32(_typing.Mapping[str, int]): ...
class List__SimpleUnion(_typing.Sequence[SimpleUnion]): ...
class Set__SimpleUnion(_typing.AbstractSet[SimpleUnion]): ...
class List__Set__SimpleUnion(_typing.Sequence[_typing.AbstractSet[SimpleUnion]]): ...
class Map__string_bool(_typing.Mapping[str, bool]): ...
class Set__i32(_typing.AbstractSet[int]): ...
class Map__string_Map__string_i32(_typing.Mapping[str, _typing.Mapping[str, int]]): ...
class Map__string_Map__string_Map__string_i32(_typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]): ...
class List__Set__i32(_typing.Sequence[_typing.AbstractSet[int]]): ...
class Map__string_List__i32(_typing.Mapping[str, _typing.Sequence[int]]): ...
class Set__bool(_typing.AbstractSet[bool]): ...
class Set__Set__bool(_typing.AbstractSet[_typing.AbstractSet[bool]]): ...
class Set__Set__Set__bool(_typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]): ...
class Map__double_i32(_typing.Mapping[float, int]): ...
class List__i64(_typing.Sequence[int]): ...
class Map__i64_double(_typing.Mapping[int, float]): ...
class Map__string_containerStruct(_typing.Mapping[str, containerStruct]): ...
class std_list__List__i32(_typing.Sequence[int]): ...
class std_deque__List__string(_typing.Sequence[str]): ...
class folly_sorted_vector_set__Set__string(_typing.AbstractSet[str]): ...
class folly_sorted_vector_map__Map__i64_string(_typing.Mapping[int, str]): ...
class List__double(_typing.Sequence[float]): ...
class Map__i32_string(_typing.Mapping[int, str]): ...
class List__Map__string_i32(_typing.Sequence[_typing.Mapping[str, int]]): ...
class Map__i16_string(_typing.Mapping[int, str]): ...
class List__Map__i16_string(_typing.Sequence[_typing.Mapping[int, str]]): ...
class List__MyStruct(_typing.Sequence[MyStruct]): ...


class Empty(thrift.py3.types.Struct):
    def __init__(
        self, *
    ) -> None: ...

    def __call__(
        self, *
    ): ...

    def __reduce__(self) -> _typing.Tuple[Callable, _typing.Tuple[_typing.Type[Empty], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: Empty) -> bool: ...
    def __lt__(self, other: Empty) -> bool: ...



class ASimpleStruct(thrift.py3.types.Struct):
    def __init__(
        self, *,
        boolField: int=None
    ) -> None: ...

    def __call__(
        self, *,
        boolField: _typing.Union[int, NOTSET, None]=NOTSET
    ): ...

    def __reduce__(self) -> _typing.Tuple[Callable, _typing.Tuple[_typing.Type[ASimpleStruct], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: ASimpleStruct) -> bool: ...
    def __lt__(self, other: ASimpleStruct) -> bool: ...

    @property
    def boolField(self) -> int: ...


class ASimpleStructNoexcept(thrift.py3.types.Struct):
    def __init__(
        self, *,
        boolField: int=None
    ) -> None: ...

    def __call__(
        self, *,
        boolField: _typing.Union[int, NOTSET, None]=NOTSET
    ): ...

    def __reduce__(self) -> _typing.Tuple[Callable, _typing.Tuple[_typing.Type[ASimpleStructNoexcept], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: ASimpleStructNoexcept) -> bool: ...
    def __lt__(self, other: ASimpleStructNoexcept) -> bool: ...

    @property
    def boolField(self) -> int: ...


class MyStruct(thrift.py3.types.Struct):
    def __init__(
        self, *,
        MyBoolField: bool=None,
        MyIntField: int=None,
        MyStringField: str=None,
        MyStringField2: str=None,
        MyBinaryField: bytes=None,
        MyBinaryField2: bytes=None,
        MyBinaryField3: bytes,
        MyBinaryListField4: _typing.Sequence[bytes]=None,
        MyMapEnumAndInt: _typing.Mapping[MyEnumA, str]=None
    ) -> None: ...

    def __call__(
        self, *,
        MyBoolField: _typing.Union[bool, NOTSET, None]=NOTSET,
        MyIntField: _typing.Union[int, NOTSET, None]=NOTSET,
        MyStringField: _typing.Union[str, NOTSET, None]=NOTSET,
        MyStringField2: _typing.Union[str, NOTSET, None]=NOTSET,
        MyBinaryField: _typing.Union[bytes, NOTSET, None]=NOTSET,
        MyBinaryField2: _typing.Union[bytes, NOTSET, None]=NOTSET,
        MyBinaryField3: _typing.Union[bytes, NOTSET]=NOTSET,
        MyBinaryListField4: _typing.Union[_typing.Sequence[bytes], NOTSET, None]=NOTSET,
        MyMapEnumAndInt: _typing.Union[_typing.Mapping[MyEnumA, str], NOTSET, None]=NOTSET
    ): ...

    def __reduce__(self) -> _typing.Tuple[Callable, _typing.Tuple[_typing.Type[MyStruct], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: MyStruct) -> bool: ...
    def __lt__(self, other: MyStruct) -> bool: ...

    @property
    def MyBoolField(self) -> bool: ...
    @property
    def MyIntField(self) -> int: ...
    @property
    def MyStringField(self) -> str: ...
    @property
    def MyStringField2(self) -> str: ...
    @property
    def MyBinaryField(self) -> bytes: ...
    @property
    def MyBinaryField2(self) -> bytes: ...
    @property
    def MyBinaryField3(self) -> bytes: ...
    @property
    def MyBinaryListField4(self) -> List__binary: ...
    @property
    def MyMapEnumAndInt(self) -> Map__MyEnumA_string: ...


class SimpleUnionType(Enum):
    EMPTY: ...
    intValue: ...
    stringValue: ...
    value: int


class SimpleUnion(thrift.py3.types.Union):
    def __init__(
        self, *,
        intValue: int=None,
        stringValue: str=None
    ) -> None: ...

    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: SimpleUnion) -> bool: ...
    def __lt__(self, other: SimpleUnion) -> bool: ...

    @property
    def intValue(self) -> int: ...
    @property
    def stringValue(self) -> str: ...
    @property
    def value(self) -> _typing.Union[int, str]: ...
    @property
    def type(self) -> SimpleUnionType: ...
    def get_type(self) -> SimpleUnionType: ...


class ComplexUnionType(Enum):
    EMPTY: ...
    intValue: ...
    req_intValue: ...
    opt_intValue: ...
    stringValue: ...
    req_stringValue: ...
    opt_stringValue: ...
    intValue2: ...
    intValue3: ...
    doubelValue: ...
    boolValue: ...
    union_list: ...
    union_set: ...
    union_map: ...
    req_union_map: ...
    opt_union_map: ...
    enum_field: ...
    enum_container: ...
    a_struct: ...
    a_set_struct: ...
    a_union: ...
    req_a_union: ...
    opt_a_union: ...
    a_union_list: ...
    a_union_typedef: ...
    a_union_typedef_list: ...
    MyBinaryField: ...
    MyBinaryField2: ...
    MyBinaryField3: ...
    MyBinaryListField4: ...
    ref_field: ...
    ref_field2: ...
    excp_field: ...
    value: int


class ComplexUnion(thrift.py3.types.Union):
    def __init__(
        self, *,
        intValue: int=None,
        req_intValue: int,
        opt_intValue: int=None,
        stringValue: str=None,
        req_stringValue: str,
        opt_stringValue: str=None,
        intValue2: int=None,
        intValue3: int=None,
        doubelValue: float=None,
        boolValue: bool=None,
        union_list: _typing.Sequence[int]=None,
        union_set: _typing.AbstractSet[int]=None,
        union_map: _typing.Mapping[str, int]=None,
        req_union_map: _typing.Mapping[str, int],
        opt_union_map: _typing.Mapping[str, int]=None,
        enum_field: MyEnumA=None,
        enum_container: _typing.Sequence[MyEnumA]=None,
        a_struct: MyStruct=None,
        a_set_struct: _typing.AbstractSet[MyStruct]=None,
        a_union: SimpleUnion=None,
        req_a_union: SimpleUnion,
        opt_a_union: SimpleUnion=None,
        a_union_list: _typing.Sequence[SimpleUnion]=None,
        a_union_typedef: _typing.AbstractSet[SimpleUnion]=None,
        a_union_typedef_list: _typing.Sequence[_typing.AbstractSet[SimpleUnion]]=None,
        MyBinaryField: bytes=None,
        MyBinaryField2: bytes=None,
        MyBinaryField3: bytes,
        MyBinaryListField4: _typing.Sequence[bytes]=None,
        ref_field: MyStruct=None,
        ref_field2: MyStruct=None,
        excp_field: AnException=None
    ) -> None: ...

    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: ComplexUnion) -> bool: ...
    def __lt__(self, other: ComplexUnion) -> bool: ...

    @property
    def intValue(self) -> int: ...
    @property
    def req_intValue(self) -> int: ...
    @property
    def opt_intValue(self) -> int: ...
    @property
    def stringValue(self) -> str: ...
    @property
    def req_stringValue(self) -> str: ...
    @property
    def opt_stringValue(self) -> str: ...
    @property
    def intValue2(self) -> int: ...
    @property
    def intValue3(self) -> int: ...
    @property
    def doubelValue(self) -> float: ...
    @property
    def boolValue(self) -> bool: ...
    @property
    def union_list(self) -> List__i32: ...
    @property
    def union_set(self) -> Set__i64: ...
    @property
    def union_map(self) -> Map__string_i32: ...
    @property
    def req_union_map(self) -> Map__string_i32: ...
    @property
    def opt_union_map(self) -> Map__string_i32: ...
    @property
    def enum_field(self) -> MyEnumA: ...
    @property
    def enum_container(self) -> List__MyEnumA: ...
    @property
    def a_struct(self) -> MyStruct: ...
    @property
    def a_set_struct(self) -> Set__MyStruct: ...
    @property
    def a_union(self) -> SimpleUnion: ...
    @property
    def req_a_union(self) -> SimpleUnion: ...
    @property
    def opt_a_union(self) -> SimpleUnion: ...
    @property
    def a_union_list(self) -> List__SimpleUnion: ...
    @property
    def a_union_typedef(self) -> Set__SimpleUnion: ...
    @property
    def a_union_typedef_list(self) -> List__Set__SimpleUnion: ...
    @property
    def MyBinaryField(self) -> bytes: ...
    @property
    def MyBinaryField2(self) -> bytes: ...
    @property
    def MyBinaryField3(self) -> bytes: ...
    @property
    def MyBinaryListField4(self) -> List__binary: ...
    @property
    def ref_field(self) -> MyStruct: ...
    @property
    def ref_field2(self) -> MyStruct: ...
    @property
    def excp_field(self) -> AnException: ...
    @property
    def value(self) -> _typing.Union[int, int, int, str, str, str, int, int, float, bool, _typing.Sequence[int], _typing.AbstractSet[int], _typing.Mapping[str, int], _typing.Mapping[str, int], _typing.Mapping[str, int], MyEnumA, _typing.Sequence[MyEnumA], MyStruct, _typing.AbstractSet[MyStruct], SimpleUnion, SimpleUnion, SimpleUnion, _typing.Sequence[SimpleUnion], _typing.AbstractSet[SimpleUnion], _typing.Sequence[_typing.AbstractSet[SimpleUnion]], bytes, bytes, bytes, _typing.Sequence[bytes], MyStruct, MyStruct, AnException]: ...
    @property
    def type(self) -> ComplexUnionType: ...
    def get_type(self) -> ComplexUnionType: ...


class AnException(thrift.py3.exceptions.Error):
    def __init__(
        self, *,
        code: int=None,
        req_code: int,
        message2: str=None,
        req_message: str,
        exception_list: _typing.Sequence[int]=None,
        exception_set: _typing.AbstractSet[int]=None,
        exception_map: _typing.Mapping[str, int]=None,
        req_exception_map: _typing.Mapping[str, int],
        enum_field: MyEnumA=None,
        enum_container: _typing.Sequence[MyEnumA]=None,
        a_struct: MyStruct=None,
        a_set_struct: _typing.AbstractSet[MyStruct]=None,
        a_union_list: _typing.Sequence[SimpleUnion]=None,
        union_typedef: _typing.AbstractSet[SimpleUnion]=None,
        a_union_typedef_list: _typing.Sequence[_typing.AbstractSet[SimpleUnion]]=None
    ) -> None: ...

    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: AnException) -> bool: ...
    def __lt__(self, other: AnException) -> bool: ...

    @property
    def code(self) -> int: ...
    @property
    def req_code(self) -> int: ...
    @property
    def message2(self) -> str: ...
    @property
    def req_message(self) -> str: ...
    @property
    def exception_list(self) -> List__i32: ...
    @property
    def exception_set(self) -> Set__i64: ...
    @property
    def exception_map(self) -> Map__string_i32: ...
    @property
    def req_exception_map(self) -> Map__string_i32: ...
    @property
    def enum_field(self) -> MyEnumA: ...
    @property
    def enum_container(self) -> List__MyEnumA: ...
    @property
    def a_struct(self) -> MyStruct: ...
    @property
    def a_set_struct(self) -> Set__MyStruct: ...
    @property
    def a_union_list(self) -> List__SimpleUnion: ...
    @property
    def union_typedef(self) -> Set__SimpleUnion: ...
    @property
    def a_union_typedef_list(self) -> List__Set__SimpleUnion: ...


class AnotherException(thrift.py3.exceptions.Error):
    def __init__(
        self, *,
        code: int=None,
        req_code: int,
        message: str=None
    ) -> None: ...

    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: AnotherException) -> bool: ...
    def __lt__(self, other: AnotherException) -> bool: ...

    @property
    def code(self) -> int: ...
    @property
    def req_code(self) -> int: ...
    @property
    def message(self) -> str: ...


class containerStruct(thrift.py3.types.Struct):
    def __init__(
        self, *,
        fieldA: bool=None,
        req_fieldA: bool,
        opt_fieldA: bool=None,
        fieldB: _typing.Mapping[str, bool]=None,
        req_fieldB: _typing.Mapping[str, bool],
        opt_fieldB: _typing.Mapping[str, bool]=None,
        fieldC: _typing.AbstractSet[int]=None,
        req_fieldC: _typing.AbstractSet[int],
        opt_fieldC: _typing.AbstractSet[int]=None,
        fieldD: str=None,
        fieldE: str=None,
        req_fieldE: str,
        opt_fieldE: str=None,
        fieldF: _typing.Sequence[_typing.Sequence[int]]=None,
        fieldG: _typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]=None,
        fieldH: _typing.Sequence[_typing.AbstractSet[int]]=None,
        fieldI: bool=None,
        fieldJ: _typing.Mapping[str, _typing.Sequence[int]]=None,
        fieldK: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]=None,
        fieldL: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]=None,
        fieldM: _typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]=None,
        fieldN: int=None,
        fieldO: _typing.Sequence[_typing.Mapping[Empty, MyStruct]]=None,
        fieldP: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]=None,
        fieldQ: MyEnumA=None,
        fieldR: MyEnumA=None,
        req_fieldR: MyEnumA,
        opt_fieldR: MyEnumA=None,
        fieldS: MyEnumA=None,
        fieldT: _typing.Sequence[MyEnumA]=None,
        fieldU: _typing.Sequence[MyEnumA]=None,
        fieldV: MyStruct=None,
        req_fieldV: MyStruct,
        opt_fieldV: MyStruct=None,
        fieldW: _typing.AbstractSet[MyStruct]=None,
        fieldX: ComplexUnion=None,
        req_fieldX: ComplexUnion,
        opt_fieldX: ComplexUnion=None,
        fieldY: _typing.Sequence[ComplexUnion]=None,
        fieldZ: _typing.AbstractSet[SimpleUnion]=None,
        fieldAA: _typing.Sequence[_typing.AbstractSet[SimpleUnion]]=None,
        fieldAB: _typing.Mapping[float, int]=None,
        fieldAC: MyEnumB=None,
        fieldAD: _includes_types.AnEnum=None,
        fieldAE: _typing.Mapping[str, int]=None
    ) -> None: ...

    def __call__(
        self, *,
        fieldA: _typing.Union[bool, NOTSET, None]=NOTSET,
        req_fieldA: _typing.Union[bool, NOTSET]=NOTSET,
        opt_fieldA: _typing.Union[bool, NOTSET, None]=NOTSET,
        fieldB: _typing.Union[_typing.Mapping[str, bool], NOTSET, None]=NOTSET,
        req_fieldB: _typing.Union[_typing.Mapping[str, bool], NOTSET]=NOTSET,
        opt_fieldB: _typing.Union[_typing.Mapping[str, bool], NOTSET, None]=NOTSET,
        fieldC: _typing.Union[_typing.AbstractSet[int], NOTSET, None]=NOTSET,
        req_fieldC: _typing.Union[_typing.AbstractSet[int], NOTSET]=NOTSET,
        opt_fieldC: _typing.Union[_typing.AbstractSet[int], NOTSET, None]=NOTSET,
        fieldD: _typing.Union[str, NOTSET, None]=NOTSET,
        fieldE: _typing.Union[str, NOTSET, None]=NOTSET,
        req_fieldE: _typing.Union[str, NOTSET]=NOTSET,
        opt_fieldE: _typing.Union[str, NOTSET, None]=NOTSET,
        fieldF: _typing.Union[_typing.Sequence[_typing.Sequence[int]], NOTSET, None]=NOTSET,
        fieldG: _typing.Union[_typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]], NOTSET, None]=NOTSET,
        fieldH: _typing.Union[_typing.Sequence[_typing.AbstractSet[int]], NOTSET, None]=NOTSET,
        fieldI: _typing.Union[bool, NOTSET, None]=NOTSET,
        fieldJ: _typing.Union[_typing.Mapping[str, _typing.Sequence[int]], NOTSET, None]=NOTSET,
        fieldK: _typing.Union[_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]], NOTSET, None]=NOTSET,
        fieldL: _typing.Union[_typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]], NOTSET, None]=NOTSET,
        fieldM: _typing.Union[_typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]], NOTSET, None]=NOTSET,
        fieldN: _typing.Union[int, NOTSET, None]=NOTSET,
        fieldO: _typing.Union[_typing.Sequence[_typing.Mapping[Empty, MyStruct]], NOTSET, None]=NOTSET,
        fieldP: _typing.Union[_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]], NOTSET, None]=NOTSET,
        fieldQ: _typing.Union[MyEnumA, NOTSET, None]=NOTSET,
        fieldR: _typing.Union[MyEnumA, NOTSET, None]=NOTSET,
        req_fieldR: _typing.Union[MyEnumA, NOTSET]=NOTSET,
        opt_fieldR: _typing.Union[MyEnumA, NOTSET, None]=NOTSET,
        fieldS: _typing.Union[MyEnumA, NOTSET, None]=NOTSET,
        fieldT: _typing.Union[_typing.Sequence[MyEnumA], NOTSET, None]=NOTSET,
        fieldU: _typing.Union[_typing.Sequence[MyEnumA], NOTSET, None]=NOTSET,
        fieldV: _typing.Union[MyStruct, NOTSET, None]=NOTSET,
        req_fieldV: _typing.Union[MyStruct, NOTSET]=NOTSET,
        opt_fieldV: _typing.Union[MyStruct, NOTSET, None]=NOTSET,
        fieldW: _typing.Union[_typing.AbstractSet[MyStruct], NOTSET, None]=NOTSET,
        fieldX: _typing.Union[ComplexUnion, NOTSET, None]=NOTSET,
        req_fieldX: _typing.Union[ComplexUnion, NOTSET]=NOTSET,
        opt_fieldX: _typing.Union[ComplexUnion, NOTSET, None]=NOTSET,
        fieldY: _typing.Union[_typing.Sequence[ComplexUnion], NOTSET, None]=NOTSET,
        fieldZ: _typing.Union[_typing.AbstractSet[SimpleUnion], NOTSET, None]=NOTSET,
        fieldAA: _typing.Union[_typing.Sequence[_typing.AbstractSet[SimpleUnion]], NOTSET, None]=NOTSET,
        fieldAB: _typing.Union[_typing.Mapping[float, int], NOTSET, None]=NOTSET,
        fieldAC: _typing.Union[MyEnumB, NOTSET, None]=NOTSET,
        fieldAD: _typing.Union[_includes_types.AnEnum, NOTSET, None]=NOTSET,
        fieldAE: _typing.Union[_typing.Mapping[str, int], NOTSET, None]=NOTSET
    ): ...

    def __reduce__(self) -> _typing.Tuple[Callable, _typing.Tuple[_typing.Type[containerStruct], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: containerStruct) -> bool: ...
    def __lt__(self, other: containerStruct) -> bool: ...

    @property
    def fieldA(self) -> bool: ...
    @property
    def req_fieldA(self) -> bool: ...
    @property
    def opt_fieldA(self) -> bool: ...
    @property
    def fieldB(self) -> Map__string_bool: ...
    @property
    def req_fieldB(self) -> Map__string_bool: ...
    @property
    def opt_fieldB(self) -> Map__string_bool: ...
    @property
    def fieldC(self) -> Set__i32: ...
    @property
    def req_fieldC(self) -> Set__i32: ...
    @property
    def opt_fieldC(self) -> Set__i32: ...
    @property
    def fieldD(self) -> str: ...
    @property
    def fieldE(self) -> str: ...
    @property
    def req_fieldE(self) -> str: ...
    @property
    def opt_fieldE(self) -> str: ...
    @property
    def fieldF(self) -> List__List__i32: ...
    @property
    def fieldG(self) -> Map__string_Map__string_Map__string_i32: ...
    @property
    def fieldH(self) -> List__Set__i32: ...
    @property
    def fieldI(self) -> bool: ...
    @property
    def fieldJ(self) -> Map__string_List__i32: ...
    @property
    def fieldK(self) -> List__List__List__List__i32: ...
    @property
    def fieldL(self) -> Set__Set__Set__bool: ...
    @property
    def fieldM(self) -> Map__Set__List__i32_Map__List__Set__string_string: ...
    @property
    def fieldN(self) -> int: ...
    @property
    def fieldO(self) -> List__Map__Empty_MyStruct: ...
    @property
    def fieldP(self) -> List__List__List__Map__Empty_MyStruct: ...
    @property
    def fieldQ(self) -> MyEnumA: ...
    @property
    def fieldR(self) -> MyEnumA: ...
    @property
    def req_fieldR(self) -> MyEnumA: ...
    @property
    def opt_fieldR(self) -> MyEnumA: ...
    @property
    def fieldS(self) -> MyEnumA: ...
    @property
    def fieldT(self) -> List__MyEnumA: ...
    @property
    def fieldU(self) -> List__MyEnumA: ...
    @property
    def fieldV(self) -> MyStruct: ...
    @property
    def req_fieldV(self) -> MyStruct: ...
    @property
    def opt_fieldV(self) -> MyStruct: ...
    @property
    def fieldW(self) -> Set__MyStruct: ...
    @property
    def fieldX(self) -> ComplexUnion: ...
    @property
    def req_fieldX(self) -> ComplexUnion: ...
    @property
    def opt_fieldX(self) -> ComplexUnion: ...
    @property
    def fieldY(self) -> List__ComplexUnion: ...
    @property
    def fieldZ(self) -> Set__SimpleUnion: ...
    @property
    def fieldAA(self) -> List__Set__SimpleUnion: ...
    @property
    def fieldAB(self) -> Map__double_i32: ...
    @property
    def fieldAC(self) -> MyEnumB: ...
    @property
    def fieldAD(self) -> _includes_types.AnEnum: ...
    @property
    def fieldAE(self) -> Map__string_i32: ...


class MyIncludedStruct(thrift.py3.types.Struct):
    def __init__(
        self, *,
        MyIncludedInt: int=None,
        MyIncludedStruct: _includes_types.AStruct=None,
        ARefField: _includes_types.AStruct=None,
        ARequiredField: _includes_types.AStruct
    ) -> None: ...

    def __call__(
        self, *,
        MyIncludedInt: _typing.Union[int, NOTSET, None]=NOTSET,
        MyIncludedStruct: _typing.Union[_includes_types.AStruct, NOTSET, None]=NOTSET,
        ARefField: _typing.Union[_includes_types.AStruct, NOTSET, None]=NOTSET,
        ARequiredField: _typing.Union[_includes_types.AStruct, NOTSET]=NOTSET
    ): ...

    def __reduce__(self) -> _typing.Tuple[Callable, _typing.Tuple[_typing.Type[MyIncludedStruct], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: MyIncludedStruct) -> bool: ...
    def __lt__(self, other: MyIncludedStruct) -> bool: ...

    @property
    def MyIncludedInt(self) -> int: ...
    @property
    def MyIncludedStruct(self) -> _includes_types.AStruct: ...
    @property
    def ARefField(self) -> _includes_types.AStruct: ...
    @property
    def ARequiredField(self) -> _includes_types.AStruct: ...


class AnnotatedStruct(thrift.py3.types.Struct):
    def __init__(
        self, *,
        no_annotation: containerStruct=None,
        cpp_unique_ref: containerStruct=None,
        cpp2_unique_ref: containerStruct=None,
        container_with_ref: _typing.Mapping[int, _typing.Sequence[str]]=None,
        req_cpp_unique_ref: containerStruct,
        req_cpp2_unique_ref: containerStruct,
        req_container_with_ref: _typing.Sequence[str],
        opt_cpp_unique_ref: containerStruct=None,
        opt_cpp2_unique_ref: containerStruct=None,
        opt_container_with_ref: _typing.AbstractSet[int]=None,
        ref_type_unique: containerStruct=None,
        ref_type_shared: containerStruct=None,
        ref_type_const: _typing.Mapping[int, _typing.Sequence[str]]=None,
        req_ref_type_shared: containerStruct,
        req_ref_type_const: containerStruct,
        req_ref_type_unique: _typing.Sequence[str],
        opt_ref_type_const: containerStruct=None,
        opt_ref_type_unique: containerStruct=None,
        opt_ref_type_shared: _typing.AbstractSet[int]=None,
        base_type: int=None,
        list_type: _typing.Sequence[int]=None,
        set_type: _typing.AbstractSet[str]=None,
        map_type: _typing.Mapping[int, float]=None,
        map_struct_type: _typing.Mapping[str, containerStruct]=None,
        iobuf_type: bytes=None,
        iobuf_ptr: bytes=None,
        list_i32_template: _typing.Sequence[int]=None,
        list_string_template: _typing.Sequence[str]=None,
        set_template: _typing.AbstractSet[str]=None,
        map_template: _typing.Mapping[int, str]=None,
        typedef_list_template: _typing.Sequence[int]=None,
        typedef_deque_template: _typing.Sequence[str]=None,
        typedef_set_template: _typing.AbstractSet[str]=None,
        typedef_map_template: _typing.Mapping[int, str]=None,
        indirection_a: int=None,
        indirection_b: _typing.Sequence[float]=None,
        indirection_c: _typing.AbstractSet[int]=None,
        iobuf_type_val: bytes=None,
        iobuf_ptr_val: bytes=None,
        struct_struct: containerStruct=None
    ) -> None: ...

    def __call__(
        self, *,
        no_annotation: _typing.Union[containerStruct, NOTSET, None]=NOTSET,
        cpp_unique_ref: _typing.Union[containerStruct, NOTSET, None]=NOTSET,
        cpp2_unique_ref: _typing.Union[containerStruct, NOTSET, None]=NOTSET,
        container_with_ref: _typing.Union[_typing.Mapping[int, _typing.Sequence[str]], NOTSET, None]=NOTSET,
        req_cpp_unique_ref: _typing.Union[containerStruct, NOTSET]=NOTSET,
        req_cpp2_unique_ref: _typing.Union[containerStruct, NOTSET]=NOTSET,
        req_container_with_ref: _typing.Union[_typing.Sequence[str], NOTSET]=NOTSET,
        opt_cpp_unique_ref: _typing.Union[containerStruct, NOTSET, None]=NOTSET,
        opt_cpp2_unique_ref: _typing.Union[containerStruct, NOTSET, None]=NOTSET,
        opt_container_with_ref: _typing.Union[_typing.AbstractSet[int], NOTSET, None]=NOTSET,
        ref_type_unique: _typing.Union[containerStruct, NOTSET, None]=NOTSET,
        ref_type_shared: _typing.Union[containerStruct, NOTSET, None]=NOTSET,
        ref_type_const: _typing.Union[_typing.Mapping[int, _typing.Sequence[str]], NOTSET, None]=NOTSET,
        req_ref_type_shared: _typing.Union[containerStruct, NOTSET]=NOTSET,
        req_ref_type_const: _typing.Union[containerStruct, NOTSET]=NOTSET,
        req_ref_type_unique: _typing.Union[_typing.Sequence[str], NOTSET]=NOTSET,
        opt_ref_type_const: _typing.Union[containerStruct, NOTSET, None]=NOTSET,
        opt_ref_type_unique: _typing.Union[containerStruct, NOTSET, None]=NOTSET,
        opt_ref_type_shared: _typing.Union[_typing.AbstractSet[int], NOTSET, None]=NOTSET,
        base_type: _typing.Union[int, NOTSET, None]=NOTSET,
        list_type: _typing.Union[_typing.Sequence[int], NOTSET, None]=NOTSET,
        set_type: _typing.Union[_typing.AbstractSet[str], NOTSET, None]=NOTSET,
        map_type: _typing.Union[_typing.Mapping[int, float], NOTSET, None]=NOTSET,
        map_struct_type: _typing.Union[_typing.Mapping[str, containerStruct], NOTSET, None]=NOTSET,
        iobuf_type: _typing.Union[bytes, NOTSET, None]=NOTSET,
        iobuf_ptr: _typing.Union[bytes, NOTSET, None]=NOTSET,
        list_i32_template: _typing.Union[_typing.Sequence[int], NOTSET, None]=NOTSET,
        list_string_template: _typing.Union[_typing.Sequence[str], NOTSET, None]=NOTSET,
        set_template: _typing.Union[_typing.AbstractSet[str], NOTSET, None]=NOTSET,
        map_template: _typing.Union[_typing.Mapping[int, str], NOTSET, None]=NOTSET,
        typedef_list_template: _typing.Union[_typing.Sequence[int], NOTSET, None]=NOTSET,
        typedef_deque_template: _typing.Union[_typing.Sequence[str], NOTSET, None]=NOTSET,
        typedef_set_template: _typing.Union[_typing.AbstractSet[str], NOTSET, None]=NOTSET,
        typedef_map_template: _typing.Union[_typing.Mapping[int, str], NOTSET, None]=NOTSET,
        indirection_a: _typing.Union[int, NOTSET, None]=NOTSET,
        indirection_b: _typing.Union[_typing.Sequence[float], NOTSET, None]=NOTSET,
        indirection_c: _typing.Union[_typing.AbstractSet[int], NOTSET, None]=NOTSET,
        iobuf_type_val: _typing.Union[bytes, NOTSET, None]=NOTSET,
        iobuf_ptr_val: _typing.Union[bytes, NOTSET, None]=NOTSET,
        struct_struct: _typing.Union[containerStruct, NOTSET, None]=NOTSET
    ): ...

    def __reduce__(self) -> _typing.Tuple[Callable, _typing.Tuple[_typing.Type[AnnotatedStruct], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: AnnotatedStruct) -> bool: ...
    def __lt__(self, other: AnnotatedStruct) -> bool: ...

    @property
    def no_annotation(self) -> containerStruct: ...
    @property
    def cpp_unique_ref(self) -> containerStruct: ...
    @property
    def cpp2_unique_ref(self) -> containerStruct: ...
    @property
    def container_with_ref(self) -> Map__i32_List__string: ...
    @property
    def req_cpp_unique_ref(self) -> containerStruct: ...
    @property
    def req_cpp2_unique_ref(self) -> containerStruct: ...
    @property
    def req_container_with_ref(self) -> List__string: ...
    @property
    def opt_cpp_unique_ref(self) -> containerStruct: ...
    @property
    def opt_cpp2_unique_ref(self) -> containerStruct: ...
    @property
    def opt_container_with_ref(self) -> Set__i32: ...
    @property
    def ref_type_unique(self) -> containerStruct: ...
    @property
    def ref_type_shared(self) -> containerStruct: ...
    @property
    def ref_type_const(self) -> Map__i32_List__string: ...
    @property
    def req_ref_type_shared(self) -> containerStruct: ...
    @property
    def req_ref_type_const(self) -> containerStruct: ...
    @property
    def req_ref_type_unique(self) -> List__string: ...
    @property
    def opt_ref_type_const(self) -> containerStruct: ...
    @property
    def opt_ref_type_unique(self) -> containerStruct: ...
    @property
    def opt_ref_type_shared(self) -> Set__i32: ...
    @property
    def base_type(self) -> int: ...
    @property
    def list_type(self) -> List__i64: ...
    @property
    def set_type(self) -> Set__string: ...
    @property
    def map_type(self) -> Map__i64_double: ...
    @property
    def map_struct_type(self) -> Map__string_containerStruct: ...
    @property
    def iobuf_type(self) -> bytes: ...
    @property
    def iobuf_ptr(self) -> bytes: ...
    @property
    def list_i32_template(self) -> std_list__List__i32: ...
    @property
    def list_string_template(self) -> std_deque__List__string: ...
    @property
    def set_template(self) -> folly_sorted_vector_set__Set__string: ...
    @property
    def map_template(self) -> folly_sorted_vector_map__Map__i64_string: ...
    @property
    def typedef_list_template(self) -> std_list__List__i32: ...
    @property
    def typedef_deque_template(self) -> std_deque__List__string: ...
    @property
    def typedef_set_template(self) -> folly_sorted_vector_set__Set__string: ...
    @property
    def typedef_map_template(self) -> folly_sorted_vector_map__Map__i64_string: ...
    @property
    def indirection_a(self) -> int: ...
    @property
    def indirection_b(self) -> List__double: ...
    @property
    def indirection_c(self) -> Set__i32: ...
    @property
    def iobuf_type_val(self) -> bytes: ...
    @property
    def iobuf_ptr_val(self) -> bytes: ...
    @property
    def struct_struct(self) -> containerStruct: ...


class FloatStruct(thrift.py3.types.Struct):
    def __init__(
        self, *,
        floatField: float=None,
        doubleField: float=None
    ) -> None: ...

    def __call__(
        self, *,
        floatField: _typing.Union[float, NOTSET, None]=NOTSET,
        doubleField: _typing.Union[float, NOTSET, None]=NOTSET
    ): ...

    def __reduce__(self) -> _typing.Tuple[Callable, _typing.Tuple[_typing.Type[FloatStruct], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: FloatStruct) -> bool: ...
    def __lt__(self, other: FloatStruct) -> bool: ...

    @property
    def floatField(self) -> float: ...
    @property
    def doubleField(self) -> float: ...


class FloatUnionType(Enum):
    EMPTY: ...
    floatSide: ...
    doubleSide: ...
    value: int


class FloatUnion(thrift.py3.types.Union):
    def __init__(
        self, *,
        floatSide: float=None,
        doubleSide: float=None
    ) -> None: ...

    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: FloatUnion) -> bool: ...
    def __lt__(self, other: FloatUnion) -> bool: ...

    @property
    def floatSide(self) -> float: ...
    @property
    def doubleSide(self) -> float: ...
    @property
    def value(self) -> _typing.Union[float, float]: ...
    @property
    def type(self) -> FloatUnionType: ...
    def get_type(self) -> FloatUnionType: ...


class Map__string_i64(_typing.Mapping[str, int]):
    def __init__(self, items: _typing.Mapping[str, int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[str, int]) -> bool: ...
    def __getitem__(self, key: str) -> int: ...
    def __iter__(self) -> _typing.Iterator[str]: ...
    def __contains__(self, key: str) -> bool: ...
    def get(self, key: str, default: int=None) -> int: ...
    def keys(self) -> _typing.Iterator[str]: ...
    def values(self) -> _typing.Iterator[int]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[str, int]]: ...


class Map__Empty_MyStruct(_typing.Mapping[Empty, MyStruct]):
    def __init__(self, items: _typing.Mapping[Empty, MyStruct]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[Empty, MyStruct]) -> bool: ...
    def __getitem__(self, key: Empty) -> MyStruct: ...
    def __iter__(self) -> _typing.Iterator[Empty]: ...
    def __contains__(self, key: Empty) -> bool: ...
    def get(self, key: Empty, default: MyStruct=None) -> MyStruct: ...
    def keys(self) -> _typing.Iterator[Empty]: ...
    def values(self) -> _typing.Iterator[MyStruct]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[Empty, MyStruct]]: ...


_List__Map__Empty_MyStructT = _typing.TypeVar('_List__Map__Empty_MyStructT', bound=_typing.Sequence[_typing.Mapping[Empty, MyStruct]])


class List__Map__Empty_MyStruct(_typing.Sequence[_typing.Mapping[Empty, MyStruct]]):
    def __init__(self, items: _typing.Sequence[_typing.Mapping[Empty, MyStruct]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: _typing.Mapping[Empty, MyStruct]) -> int: ...
    def count(self, item: _typing.Mapping[Empty, MyStruct]) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Mapping[Empty, MyStruct]]) -> List__Map__Empty_MyStruct: ...
    def __radd__(self, other: _List__Map__Empty_MyStructT) -> _List__Map__Empty_MyStructT: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__Map__Empty_MyStruct: ...
    def __getitem__(self, index: int) -> _typing.Mapping[Empty, MyStruct]: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Mapping[Empty, MyStruct]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Mapping[Empty, MyStruct]]: ...
    def __contains__(self, item: _typing.Mapping[Empty, MyStruct]) -> bool: ...
    def __eq__(self, other: _typing.Sequence[_typing.Mapping[Empty, MyStruct]]) -> bool: ...


_List__List__Map__Empty_MyStructT = _typing.TypeVar('_List__List__Map__Empty_MyStructT', bound=_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]])


class List__List__Map__Empty_MyStruct(_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]):
    def __init__(self, items: _typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: _typing.Sequence[_typing.Mapping[Empty, MyStruct]]) -> int: ...
    def count(self, item: _typing.Sequence[_typing.Mapping[Empty, MyStruct]]) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]) -> List__List__Map__Empty_MyStruct: ...
    def __radd__(self, other: _List__List__Map__Empty_MyStructT) -> _List__List__Map__Empty_MyStructT: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__List__Map__Empty_MyStruct: ...
    def __getitem__(self, index: int) -> _typing.Sequence[_typing.Mapping[Empty, MyStruct]]: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]: ...
    def __contains__(self, item: _typing.Sequence[_typing.Mapping[Empty, MyStruct]]) -> bool: ...
    def __eq__(self, other: _typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]) -> bool: ...


_List__List__List__Map__Empty_MyStructT = _typing.TypeVar('_List__List__List__Map__Empty_MyStructT', bound=_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]])


class List__List__List__Map__Empty_MyStruct(_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]):
    def __init__(self, items: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: _typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]) -> int: ...
    def count(self, item: _typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> List__List__List__Map__Empty_MyStruct: ...
    def __radd__(self, other: _List__List__List__Map__Empty_MyStructT) -> _List__List__List__Map__Empty_MyStructT: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__List__List__Map__Empty_MyStruct: ...
    def __getitem__(self, index: int) -> _typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]: ...
    def __contains__(self, item: _typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]) -> bool: ...
    def __eq__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> bool: ...


_List__MyEnumAT = _typing.TypeVar('_List__MyEnumAT', bound=_typing.Sequence[MyEnumA])


class List__MyEnumA(_typing.Sequence[MyEnumA]):
    def __init__(self, items: _typing.Sequence[MyEnumA]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: MyEnumA) -> int: ...
    def count(self, item: MyEnumA) -> int: ...
    def __add__(self, other: _typing.Sequence[MyEnumA]) -> List__MyEnumA: ...
    def __radd__(self, other: _List__MyEnumAT) -> _List__MyEnumAT: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__MyEnumA: ...
    def __getitem__(self, index: int) -> MyEnumA: ...
    def __reversed__(self) -> _typing.Iterator[MyEnumA]: ...
    def __iter__(self) -> _typing.Iterator[MyEnumA]: ...
    def __contains__(self, item: MyEnumA) -> bool: ...
    def __eq__(self, other: _typing.Sequence[MyEnumA]) -> bool: ...


class Set__MyStruct(_typing.AbstractSet[MyStruct]):
    def __init__(self, items: _typing.AbstractSet[MyStruct]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[MyStruct]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[MyStruct]) -> bool: ...
    def __contains__(self, item: MyStruct) -> bool: ...
    def __iter__(self) -> MyStruct): ...
    def __add__(self, other: _typing.AbstractSet[MyStruct]) -> Set__MyStruct: ...
    def __or__(self, other: _typing.AbstractSet[MyStruct]) -> Set__MyStruct: ...
    def __xor__(self, other: _typing.AbstractSet[MyStruct]) -> Set__MyStruct: ...
    def isdisjoint(self, other: _typing.AbstractSet[MyStruct]) -> bool: ...
    def union(self, other: _typing.AbstractSet[MyStruct]) -> Set__MyStruct: ...
    def intersection(self, other: _typing.AbstractSet[MyStruct]) -> Set__MyStruct: ...
    def difference(self, other: _typing.AbstractSet[MyStruct]) -> Set__MyStruct: ...
    def symmetric_difference(self, other: _typing.AbstractSet[MyStruct]) -> Set__MyStruct: ...
    def issubset(self, other: _typing.AbstractSet[MyStruct]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[MyStruct]) -> bool: ...


_List__ComplexUnionT = _typing.TypeVar('_List__ComplexUnionT', bound=_typing.Sequence[ComplexUnion])


class List__ComplexUnion(_typing.Sequence[ComplexUnion]):
    def __init__(self, items: _typing.Sequence[ComplexUnion]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: ComplexUnion) -> int: ...
    def count(self, item: ComplexUnion) -> int: ...
    def __add__(self, other: _typing.Sequence[ComplexUnion]) -> List__ComplexUnion: ...
    def __radd__(self, other: _List__ComplexUnionT) -> _List__ComplexUnionT: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__ComplexUnion: ...
    def __getitem__(self, index: int) -> ComplexUnion: ...
    def __reversed__(self) -> _typing.Iterator[ComplexUnion]: ...
    def __iter__(self) -> _typing.Iterator[ComplexUnion]: ...
    def __contains__(self, item: ComplexUnion) -> bool: ...
    def __eq__(self, other: _typing.Sequence[ComplexUnion]) -> bool: ...


_List__stringT = _typing.TypeVar('_List__stringT', bound=_typing.Sequence[str])


class List__string(_typing.Sequence[str]):
    def __init__(self, items: _typing.Sequence[str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: str) -> int: ...
    def count(self, item: str) -> int: ...
    def __add__(self, other: _typing.Sequence[str]) -> List__string: ...
    def __radd__(self, other: _List__stringT) -> _List__stringT: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__string: ...
    def __getitem__(self, index: int) -> str: ...
    def __reversed__(self) -> _typing.Iterator[str]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...
    def __contains__(self, item: str) -> bool: ...
    def __eq__(self, other: _typing.Sequence[str]) -> bool: ...


class Set__List__string(_typing.AbstractSet[_typing.Sequence[str]]):
    def __init__(self, items: _typing.AbstractSet[_typing.Sequence[str]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> bool: ...
    def __contains__(self, item: _typing.Sequence[str]) -> bool: ...
    def __iter__(self) -> _typing.Sequence[str]): ...
    def __add__(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> Set__List__string: ...
    def __or__(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> Set__List__string: ...
    def __xor__(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> Set__List__string: ...
    def isdisjoint(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> Set__List__string: ...
    def intersection(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> Set__List__string: ...
    def difference(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> Set__List__string: ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> Set__List__string: ...
    def issubset(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> bool: ...


class Set__List__List__Map__Empty_MyStruct(_typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]):
    def __init__(self, items: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> bool: ...
    def __contains__(self, item: _typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]) -> bool: ...
    def __iter__(self) -> _typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]): ...
    def __add__(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> Set__List__List__Map__Empty_MyStruct: ...
    def __or__(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> Set__List__List__Map__Empty_MyStruct: ...
    def __xor__(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> Set__List__List__Map__Empty_MyStruct: ...
    def isdisjoint(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> Set__List__List__Map__Empty_MyStruct: ...
    def intersection(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> Set__List__List__Map__Empty_MyStruct: ...
    def difference(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> Set__List__List__Map__Empty_MyStruct: ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> Set__List__List__Map__Empty_MyStruct: ...
    def issubset(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> bool: ...


class Map__i32_List__string(_typing.Mapping[int, _typing.Sequence[str]]):
    def __init__(self, items: _typing.Mapping[int, _typing.Sequence[str]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[int, _typing.Sequence[str]]) -> bool: ...
    def __getitem__(self, key: int) -> _typing.Sequence[str]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...
    def __contains__(self, key: int) -> bool: ...
    def get(self, key: int, default: _typing.Sequence[str]=None) -> _typing.Sequence[str]: ...
    def keys(self) -> _typing.Iterator[int]: ...
    def values(self) -> _typing.Iterator[_typing.Sequence[str]]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[int, _typing.Sequence[str]]]: ...


_List__boolT = _typing.TypeVar('_List__boolT', bound=_typing.Sequence[bool])


class List__bool(_typing.Sequence[bool]):
    def __init__(self, items: _typing.Sequence[bool]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: bool) -> int: ...
    def count(self, item: bool) -> int: ...
    def __add__(self, other: _typing.Sequence[bool]) -> List__bool: ...
    def __radd__(self, other: _List__boolT) -> _List__boolT: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__bool: ...
    def __getitem__(self, index: int) -> bool: ...
    def __reversed__(self) -> _typing.Iterator[bool]: ...
    def __iter__(self) -> _typing.Iterator[bool]: ...
    def __contains__(self, item: bool) -> bool: ...
    def __eq__(self, other: _typing.Sequence[bool]) -> bool: ...


_List__i32T = _typing.TypeVar('_List__i32T', bound=_typing.Sequence[int])


class List__i32(_typing.Sequence[int]):
    def __init__(self, items: _typing.Sequence[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: int) -> int: ...
    def count(self, item: int) -> int: ...
    def __add__(self, other: _typing.Sequence[int]) -> List__i32: ...
    def __radd__(self, other: _List__i32T) -> _List__i32T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__i32: ...
    def __getitem__(self, index: int) -> int: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...
    def __contains__(self, item: int) -> bool: ...
    def __eq__(self, other: _typing.Sequence[int]) -> bool: ...


_List__List__i32T = _typing.TypeVar('_List__List__i32T', bound=_typing.Sequence[_typing.Sequence[int]])


class List__List__i32(_typing.Sequence[_typing.Sequence[int]]):
    def __init__(self, items: _typing.Sequence[_typing.Sequence[int]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: _typing.Sequence[int]) -> int: ...
    def count(self, item: _typing.Sequence[int]) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[int]]) -> List__List__i32: ...
    def __radd__(self, other: _List__List__i32T) -> _List__List__i32T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__List__i32: ...
    def __getitem__(self, index: int) -> _typing.Sequence[int]: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[int]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[int]]: ...
    def __contains__(self, item: _typing.Sequence[int]) -> bool: ...
    def __eq__(self, other: _typing.Sequence[_typing.Sequence[int]]) -> bool: ...


_List__List__List__i32T = _typing.TypeVar('_List__List__List__i32T', bound=_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]])


class List__List__List__i32(_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]):
    def __init__(self, items: _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: _typing.Sequence[_typing.Sequence[int]]) -> int: ...
    def count(self, item: _typing.Sequence[_typing.Sequence[int]]) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]) -> List__List__List__i32: ...
    def __radd__(self, other: _List__List__List__i32T) -> _List__List__List__i32T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__List__List__i32: ...
    def __getitem__(self, index: int) -> _typing.Sequence[_typing.Sequence[int]]: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[int]]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[int]]]: ...
    def __contains__(self, item: _typing.Sequence[_typing.Sequence[int]]) -> bool: ...
    def __eq__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]) -> bool: ...


_List__List__List__List__i32T = _typing.TypeVar('_List__List__List__List__i32T', bound=_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]])


class List__List__List__List__i32(_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]):
    def __init__(self, items: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]) -> int: ...
    def count(self, item: _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]) -> List__List__List__List__i32: ...
    def __radd__(self, other: _List__List__List__List__i32T) -> _List__List__List__List__i32T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__List__List__List__i32: ...
    def __getitem__(self, index: int) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]: ...
    def __contains__(self, item: _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]) -> bool: ...
    def __eq__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]) -> bool: ...


class Set__List__i32(_typing.AbstractSet[_typing.Sequence[int]]):
    def __init__(self, items: _typing.AbstractSet[_typing.Sequence[int]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> bool: ...
    def __contains__(self, item: _typing.Sequence[int]) -> bool: ...
    def __iter__(self) -> _typing.Sequence[int]): ...
    def __add__(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> Set__List__i32: ...
    def __or__(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> Set__List__i32: ...
    def __xor__(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> Set__List__i32: ...
    def isdisjoint(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> Set__List__i32: ...
    def intersection(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> Set__List__i32: ...
    def difference(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> Set__List__i32: ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> Set__List__i32: ...
    def issubset(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> bool: ...


class Set__string(_typing.AbstractSet[str]):
    def __init__(self, items: _typing.AbstractSet[str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[str]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[str]) -> bool: ...
    def __contains__(self, item: str) -> bool: ...
    def __iter__(self) -> str): ...
    def __add__(self, other: _typing.AbstractSet[str]) -> Set__string: ...
    def __or__(self, other: _typing.AbstractSet[str]) -> Set__string: ...
    def __xor__(self, other: _typing.AbstractSet[str]) -> Set__string: ...
    def isdisjoint(self, other: _typing.AbstractSet[str]) -> bool: ...
    def union(self, other: _typing.AbstractSet[str]) -> Set__string: ...
    def intersection(self, other: _typing.AbstractSet[str]) -> Set__string: ...
    def difference(self, other: _typing.AbstractSet[str]) -> Set__string: ...
    def symmetric_difference(self, other: _typing.AbstractSet[str]) -> Set__string: ...
    def issubset(self, other: _typing.AbstractSet[str]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[str]) -> bool: ...


_List__Set__stringT = _typing.TypeVar('_List__Set__stringT', bound=_typing.Sequence[_typing.AbstractSet[str]])


class List__Set__string(_typing.Sequence[_typing.AbstractSet[str]]):
    def __init__(self, items: _typing.Sequence[_typing.AbstractSet[str]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: _typing.AbstractSet[str]) -> int: ...
    def count(self, item: _typing.AbstractSet[str]) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.AbstractSet[str]]) -> List__Set__string: ...
    def __radd__(self, other: _List__Set__stringT) -> _List__Set__stringT: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__Set__string: ...
    def __getitem__(self, index: int) -> _typing.AbstractSet[str]: ...
    def __reversed__(self) -> _typing.Iterator[_typing.AbstractSet[str]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[str]]: ...
    def __contains__(self, item: _typing.AbstractSet[str]) -> bool: ...
    def __eq__(self, other: _typing.Sequence[_typing.AbstractSet[str]]) -> bool: ...


class Map__List__Set__string_string(_typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]):
    def __init__(self, items: _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]) -> bool: ...
    def __getitem__(self, key: _typing.Sequence[_typing.AbstractSet[str]]) -> str: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.AbstractSet[str]]]: ...
    def __contains__(self, key: _typing.Sequence[_typing.AbstractSet[str]]) -> bool: ...
    def get(self, key: _typing.Sequence[_typing.AbstractSet[str]], default: str=None) -> str: ...
    def keys(self) -> _typing.Iterator[_typing.Sequence[_typing.AbstractSet[str]]]: ...
    def values(self) -> _typing.Iterator[str]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[_typing.Sequence[_typing.AbstractSet[str]], str]]: ...


class Map__Set__List__i32_Map__List__Set__string_string(_typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]):
    def __init__(self, items: _typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]) -> bool: ...
    def __getitem__(self, key: _typing.AbstractSet[_typing.Sequence[int]]) -> _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]: ...
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[_typing.Sequence[int]]]: ...
    def __contains__(self, key: _typing.AbstractSet[_typing.Sequence[int]]) -> bool: ...
    def get(self, key: _typing.AbstractSet[_typing.Sequence[int]], default: _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]=None) -> _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]: ...
    def keys(self) -> _typing.Iterator[_typing.AbstractSet[_typing.Sequence[int]]]: ...
    def values(self) -> _typing.Iterator[_typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]]: ...


_List__binaryT = _typing.TypeVar('_List__binaryT', bound=_typing.Sequence[bytes])


class List__binary(_typing.Sequence[bytes]):
    def __init__(self, items: _typing.Sequence[bytes]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: bytes) -> int: ...
    def count(self, item: bytes) -> int: ...
    def __add__(self, other: _typing.Sequence[bytes]) -> List__binary: ...
    def __radd__(self, other: _List__binaryT) -> _List__binaryT: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__binary: ...
    def __getitem__(self, index: int) -> bytes: ...
    def __reversed__(self) -> _typing.Iterator[bytes]: ...
    def __iter__(self) -> _typing.Iterator[bytes]: ...
    def __contains__(self, item: bytes) -> bool: ...
    def __eq__(self, other: _typing.Sequence[bytes]) -> bool: ...


class Map__MyEnumA_string(_typing.Mapping[MyEnumA, str]):
    def __init__(self, items: _typing.Mapping[MyEnumA, str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[MyEnumA, str]) -> bool: ...
    def __getitem__(self, key: MyEnumA) -> str: ...
    def __iter__(self) -> _typing.Iterator[MyEnumA]: ...
    def __contains__(self, key: MyEnumA) -> bool: ...
    def get(self, key: MyEnumA, default: str=None) -> str: ...
    def keys(self) -> _typing.Iterator[MyEnumA]: ...
    def values(self) -> _typing.Iterator[str]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[MyEnumA, str]]: ...


class Set__i64(_typing.AbstractSet[int]):
    def __init__(self, items: _typing.AbstractSet[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[int]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[int]) -> bool: ...
    def __contains__(self, item: int) -> bool: ...
    def __iter__(self) -> int): ...
    def __add__(self, other: _typing.AbstractSet[int]) -> Set__i64: ...
    def __or__(self, other: _typing.AbstractSet[int]) -> Set__i64: ...
    def __xor__(self, other: _typing.AbstractSet[int]) -> Set__i64: ...
    def isdisjoint(self, other: _typing.AbstractSet[int]) -> bool: ...
    def union(self, other: _typing.AbstractSet[int]) -> Set__i64: ...
    def intersection(self, other: _typing.AbstractSet[int]) -> Set__i64: ...
    def difference(self, other: _typing.AbstractSet[int]) -> Set__i64: ...
    def symmetric_difference(self, other: _typing.AbstractSet[int]) -> Set__i64: ...
    def issubset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[int]) -> bool: ...


class Map__string_i32(_typing.Mapping[str, int]):
    def __init__(self, items: _typing.Mapping[str, int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[str, int]) -> bool: ...
    def __getitem__(self, key: str) -> int: ...
    def __iter__(self) -> _typing.Iterator[str]: ...
    def __contains__(self, key: str) -> bool: ...
    def get(self, key: str, default: int=None) -> int: ...
    def keys(self) -> _typing.Iterator[str]: ...
    def values(self) -> _typing.Iterator[int]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[str, int]]: ...


_List__SimpleUnionT = _typing.TypeVar('_List__SimpleUnionT', bound=_typing.Sequence[SimpleUnion])


class List__SimpleUnion(_typing.Sequence[SimpleUnion]):
    def __init__(self, items: _typing.Sequence[SimpleUnion]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: SimpleUnion) -> int: ...
    def count(self, item: SimpleUnion) -> int: ...
    def __add__(self, other: _typing.Sequence[SimpleUnion]) -> List__SimpleUnion: ...
    def __radd__(self, other: _List__SimpleUnionT) -> _List__SimpleUnionT: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__SimpleUnion: ...
    def __getitem__(self, index: int) -> SimpleUnion: ...
    def __reversed__(self) -> _typing.Iterator[SimpleUnion]: ...
    def __iter__(self) -> _typing.Iterator[SimpleUnion]: ...
    def __contains__(self, item: SimpleUnion) -> bool: ...
    def __eq__(self, other: _typing.Sequence[SimpleUnion]) -> bool: ...


class Set__SimpleUnion(_typing.AbstractSet[SimpleUnion]):
    def __init__(self, items: _typing.AbstractSet[SimpleUnion]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[SimpleUnion]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[SimpleUnion]) -> bool: ...
    def __contains__(self, item: SimpleUnion) -> bool: ...
    def __iter__(self) -> SimpleUnion): ...
    def __add__(self, other: _typing.AbstractSet[SimpleUnion]) -> Set__SimpleUnion: ...
    def __or__(self, other: _typing.AbstractSet[SimpleUnion]) -> Set__SimpleUnion: ...
    def __xor__(self, other: _typing.AbstractSet[SimpleUnion]) -> Set__SimpleUnion: ...
    def isdisjoint(self, other: _typing.AbstractSet[SimpleUnion]) -> bool: ...
    def union(self, other: _typing.AbstractSet[SimpleUnion]) -> Set__SimpleUnion: ...
    def intersection(self, other: _typing.AbstractSet[SimpleUnion]) -> Set__SimpleUnion: ...
    def difference(self, other: _typing.AbstractSet[SimpleUnion]) -> Set__SimpleUnion: ...
    def symmetric_difference(self, other: _typing.AbstractSet[SimpleUnion]) -> Set__SimpleUnion: ...
    def issubset(self, other: _typing.AbstractSet[SimpleUnion]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[SimpleUnion]) -> bool: ...


_List__Set__SimpleUnionT = _typing.TypeVar('_List__Set__SimpleUnionT', bound=_typing.Sequence[_typing.AbstractSet[SimpleUnion]])


class List__Set__SimpleUnion(_typing.Sequence[_typing.AbstractSet[SimpleUnion]]):
    def __init__(self, items: _typing.Sequence[_typing.AbstractSet[SimpleUnion]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: _typing.AbstractSet[SimpleUnion]) -> int: ...
    def count(self, item: _typing.AbstractSet[SimpleUnion]) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.AbstractSet[SimpleUnion]]) -> List__Set__SimpleUnion: ...
    def __radd__(self, other: _List__Set__SimpleUnionT) -> _List__Set__SimpleUnionT: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__Set__SimpleUnion: ...
    def __getitem__(self, index: int) -> _typing.AbstractSet[SimpleUnion]: ...
    def __reversed__(self) -> _typing.Iterator[_typing.AbstractSet[SimpleUnion]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[SimpleUnion]]: ...
    def __contains__(self, item: _typing.AbstractSet[SimpleUnion]) -> bool: ...
    def __eq__(self, other: _typing.Sequence[_typing.AbstractSet[SimpleUnion]]) -> bool: ...


class Map__string_bool(_typing.Mapping[str, bool]):
    def __init__(self, items: _typing.Mapping[str, bool]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[str, bool]) -> bool: ...
    def __getitem__(self, key: str) -> bool: ...
    def __iter__(self) -> _typing.Iterator[str]: ...
    def __contains__(self, key: str) -> bool: ...
    def get(self, key: str, default: bool=None) -> bool: ...
    def keys(self) -> _typing.Iterator[str]: ...
    def values(self) -> _typing.Iterator[bool]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[str, bool]]: ...


class Set__i32(_typing.AbstractSet[int]):
    def __init__(self, items: _typing.AbstractSet[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[int]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[int]) -> bool: ...
    def __contains__(self, item: int) -> bool: ...
    def __iter__(self) -> int): ...
    def __add__(self, other: _typing.AbstractSet[int]) -> Set__i32: ...
    def __or__(self, other: _typing.AbstractSet[int]) -> Set__i32: ...
    def __xor__(self, other: _typing.AbstractSet[int]) -> Set__i32: ...
    def isdisjoint(self, other: _typing.AbstractSet[int]) -> bool: ...
    def union(self, other: _typing.AbstractSet[int]) -> Set__i32: ...
    def intersection(self, other: _typing.AbstractSet[int]) -> Set__i32: ...
    def difference(self, other: _typing.AbstractSet[int]) -> Set__i32: ...
    def symmetric_difference(self, other: _typing.AbstractSet[int]) -> Set__i32: ...
    def issubset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[int]) -> bool: ...


class Map__string_Map__string_i32(_typing.Mapping[str, _typing.Mapping[str, int]]):
    def __init__(self, items: _typing.Mapping[str, _typing.Mapping[str, int]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[str, _typing.Mapping[str, int]]) -> bool: ...
    def __getitem__(self, key: str) -> _typing.Mapping[str, int]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...
    def __contains__(self, key: str) -> bool: ...
    def get(self, key: str, default: _typing.Mapping[str, int]=None) -> _typing.Mapping[str, int]: ...
    def keys(self) -> _typing.Iterator[str]: ...
    def values(self) -> _typing.Iterator[_typing.Mapping[str, int]]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Mapping[str, int]]]: ...


class Map__string_Map__string_Map__string_i32(_typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]):
    def __init__(self, items: _typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]) -> bool: ...
    def __getitem__(self, key: str) -> _typing.Mapping[str, _typing.Mapping[str, int]]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...
    def __contains__(self, key: str) -> bool: ...
    def get(self, key: str, default: _typing.Mapping[str, _typing.Mapping[str, int]]=None) -> _typing.Mapping[str, _typing.Mapping[str, int]]: ...
    def keys(self) -> _typing.Iterator[str]: ...
    def values(self) -> _typing.Iterator[_typing.Mapping[str, _typing.Mapping[str, int]]]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Mapping[str, _typing.Mapping[str, int]]]]: ...


_List__Set__i32T = _typing.TypeVar('_List__Set__i32T', bound=_typing.Sequence[_typing.AbstractSet[int]])


class List__Set__i32(_typing.Sequence[_typing.AbstractSet[int]]):
    def __init__(self, items: _typing.Sequence[_typing.AbstractSet[int]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: _typing.AbstractSet[int]) -> int: ...
    def count(self, item: _typing.AbstractSet[int]) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.AbstractSet[int]]) -> List__Set__i32: ...
    def __radd__(self, other: _List__Set__i32T) -> _List__Set__i32T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__Set__i32: ...
    def __getitem__(self, index: int) -> _typing.AbstractSet[int]: ...
    def __reversed__(self) -> _typing.Iterator[_typing.AbstractSet[int]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[int]]: ...
    def __contains__(self, item: _typing.AbstractSet[int]) -> bool: ...
    def __eq__(self, other: _typing.Sequence[_typing.AbstractSet[int]]) -> bool: ...


class Map__string_List__i32(_typing.Mapping[str, _typing.Sequence[int]]):
    def __init__(self, items: _typing.Mapping[str, _typing.Sequence[int]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[str, _typing.Sequence[int]]) -> bool: ...
    def __getitem__(self, key: str) -> _typing.Sequence[int]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...
    def __contains__(self, key: str) -> bool: ...
    def get(self, key: str, default: _typing.Sequence[int]=None) -> _typing.Sequence[int]: ...
    def keys(self) -> _typing.Iterator[str]: ...
    def values(self) -> _typing.Iterator[_typing.Sequence[int]]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Sequence[int]]]: ...


class Set__bool(_typing.AbstractSet[bool]):
    def __init__(self, items: _typing.AbstractSet[bool]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[bool]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[bool]) -> bool: ...
    def __contains__(self, item: bool) -> bool: ...
    def __iter__(self) -> bool): ...
    def __add__(self, other: _typing.AbstractSet[bool]) -> Set__bool: ...
    def __or__(self, other: _typing.AbstractSet[bool]) -> Set__bool: ...
    def __xor__(self, other: _typing.AbstractSet[bool]) -> Set__bool: ...
    def isdisjoint(self, other: _typing.AbstractSet[bool]) -> bool: ...
    def union(self, other: _typing.AbstractSet[bool]) -> Set__bool: ...
    def intersection(self, other: _typing.AbstractSet[bool]) -> Set__bool: ...
    def difference(self, other: _typing.AbstractSet[bool]) -> Set__bool: ...
    def symmetric_difference(self, other: _typing.AbstractSet[bool]) -> Set__bool: ...
    def issubset(self, other: _typing.AbstractSet[bool]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[bool]) -> bool: ...


class Set__Set__bool(_typing.AbstractSet[_typing.AbstractSet[bool]]):
    def __init__(self, items: _typing.AbstractSet[_typing.AbstractSet[bool]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> bool: ...
    def __contains__(self, item: _typing.AbstractSet[bool]) -> bool: ...
    def __iter__(self) -> _typing.AbstractSet[bool]): ...
    def __add__(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> Set__Set__bool: ...
    def __or__(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> Set__Set__bool: ...
    def __xor__(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> Set__Set__bool: ...
    def isdisjoint(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> Set__Set__bool: ...
    def intersection(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> Set__Set__bool: ...
    def difference(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> Set__Set__bool: ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> Set__Set__bool: ...
    def issubset(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> bool: ...


class Set__Set__Set__bool(_typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]):
    def __init__(self, items: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> bool: ...
    def __contains__(self, item: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> bool: ...
    def __iter__(self) -> _typing.AbstractSet[_typing.AbstractSet[bool]]): ...
    def __add__(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> Set__Set__Set__bool: ...
    def __or__(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> Set__Set__Set__bool: ...
    def __xor__(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> Set__Set__Set__bool: ...
    def isdisjoint(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> Set__Set__Set__bool: ...
    def intersection(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> Set__Set__Set__bool: ...
    def difference(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> Set__Set__Set__bool: ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> Set__Set__Set__bool: ...
    def issubset(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> bool: ...


class Map__double_i32(_typing.Mapping[float, int]):
    def __init__(self, items: _typing.Mapping[float, int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[float, int]) -> bool: ...
    def __getitem__(self, key: float) -> int: ...
    def __iter__(self) -> _typing.Iterator[float]: ...
    def __contains__(self, key: float) -> bool: ...
    def get(self, key: float, default: int=None) -> int: ...
    def keys(self) -> _typing.Iterator[float]: ...
    def values(self) -> _typing.Iterator[int]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[float, int]]: ...


_List__i64T = _typing.TypeVar('_List__i64T', bound=_typing.Sequence[int])


class List__i64(_typing.Sequence[int]):
    def __init__(self, items: _typing.Sequence[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: int) -> int: ...
    def count(self, item: int) -> int: ...
    def __add__(self, other: _typing.Sequence[int]) -> List__i64: ...
    def __radd__(self, other: _List__i64T) -> _List__i64T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__i64: ...
    def __getitem__(self, index: int) -> int: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...
    def __contains__(self, item: int) -> bool: ...
    def __eq__(self, other: _typing.Sequence[int]) -> bool: ...


class Map__i64_double(_typing.Mapping[int, float]):
    def __init__(self, items: _typing.Mapping[int, float]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[int, float]) -> bool: ...
    def __getitem__(self, key: int) -> float: ...
    def __iter__(self) -> _typing.Iterator[int]: ...
    def __contains__(self, key: int) -> bool: ...
    def get(self, key: int, default: float=None) -> float: ...
    def keys(self) -> _typing.Iterator[int]: ...
    def values(self) -> _typing.Iterator[float]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[int, float]]: ...


class Map__string_containerStruct(_typing.Mapping[str, containerStruct]):
    def __init__(self, items: _typing.Mapping[str, containerStruct]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[str, containerStruct]) -> bool: ...
    def __getitem__(self, key: str) -> containerStruct: ...
    def __iter__(self) -> _typing.Iterator[str]: ...
    def __contains__(self, key: str) -> bool: ...
    def get(self, key: str, default: containerStruct=None) -> containerStruct: ...
    def keys(self) -> _typing.Iterator[str]: ...
    def values(self) -> _typing.Iterator[containerStruct]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[str, containerStruct]]: ...


_std_list__List__i32T = _typing.TypeVar('_std_list__List__i32T', bound=_typing.Sequence[int])


class std_list__List__i32(_typing.Sequence[int]):
    def __init__(self, items: _typing.Sequence[int]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: int) -> int: ...
    def count(self, item: int) -> int: ...
    def __add__(self, other: _typing.Sequence[int]) -> std_list__List__i32: ...
    def __radd__(self, other: _std_list__List__i32T) -> _std_list__List__i32T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> std_list__List__i32: ...
    def __getitem__(self, index: int) -> int: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...
    def __contains__(self, item: int) -> bool: ...
    def __eq__(self, other: _typing.Sequence[int]) -> bool: ...


_std_deque__List__stringT = _typing.TypeVar('_std_deque__List__stringT', bound=_typing.Sequence[str])


class std_deque__List__string(_typing.Sequence[str]):
    def __init__(self, items: _typing.Sequence[str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: str) -> int: ...
    def count(self, item: str) -> int: ...
    def __add__(self, other: _typing.Sequence[str]) -> std_deque__List__string: ...
    def __radd__(self, other: _std_deque__List__stringT) -> _std_deque__List__stringT: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> std_deque__List__string: ...
    def __getitem__(self, index: int) -> str: ...
    def __reversed__(self) -> _typing.Iterator[str]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...
    def __contains__(self, item: str) -> bool: ...
    def __eq__(self, other: _typing.Sequence[str]) -> bool: ...


class folly_sorted_vector_set__Set__string(_typing.AbstractSet[str]):
    def __init__(self, items: _typing.AbstractSet[str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _typing.AbstractSet[str]) -> bool: ...
    def __eq__(self, other: _typing.AbstractSet[str]) -> bool: ...
    def __contains__(self, item: str) -> bool: ...
    def __iter__(self) -> str): ...
    def __add__(self, other: _typing.AbstractSet[str]) -> folly_sorted_vector_set__Set__string: ...
    def __or__(self, other: _typing.AbstractSet[str]) -> folly_sorted_vector_set__Set__string: ...
    def __xor__(self, other: _typing.AbstractSet[str]) -> folly_sorted_vector_set__Set__string: ...
    def isdisjoint(self, other: _typing.AbstractSet[str]) -> bool: ...
    def union(self, other: _typing.AbstractSet[str]) -> folly_sorted_vector_set__Set__string: ...
    def intersection(self, other: _typing.AbstractSet[str]) -> folly_sorted_vector_set__Set__string: ...
    def difference(self, other: _typing.AbstractSet[str]) -> folly_sorted_vector_set__Set__string: ...
    def symmetric_difference(self, other: _typing.AbstractSet[str]) -> folly_sorted_vector_set__Set__string: ...
    def issubset(self, other: _typing.AbstractSet[str]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[str]) -> bool: ...


class folly_sorted_vector_map__Map__i64_string(_typing.Mapping[int, str]):
    def __init__(self, items: _typing.Mapping[int, str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[int, str]) -> bool: ...
    def __getitem__(self, key: int) -> str: ...
    def __iter__(self) -> _typing.Iterator[int]: ...
    def __contains__(self, key: int) -> bool: ...
    def get(self, key: int, default: str=None) -> str: ...
    def keys(self) -> _typing.Iterator[int]: ...
    def values(self) -> _typing.Iterator[str]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[int, str]]: ...


_List__doubleT = _typing.TypeVar('_List__doubleT', bound=_typing.Sequence[float])


class List__double(_typing.Sequence[float]):
    def __init__(self, items: _typing.Sequence[float]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: float) -> int: ...
    def count(self, item: float) -> int: ...
    def __add__(self, other: _typing.Sequence[float]) -> List__double: ...
    def __radd__(self, other: _List__doubleT) -> _List__doubleT: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__double: ...
    def __getitem__(self, index: int) -> float: ...
    def __reversed__(self) -> _typing.Iterator[float]: ...
    def __iter__(self) -> _typing.Iterator[float]: ...
    def __contains__(self, item: float) -> bool: ...
    def __eq__(self, other: _typing.Sequence[float]) -> bool: ...


class Map__i32_string(_typing.Mapping[int, str]):
    def __init__(self, items: _typing.Mapping[int, str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[int, str]) -> bool: ...
    def __getitem__(self, key: int) -> str: ...
    def __iter__(self) -> _typing.Iterator[int]: ...
    def __contains__(self, key: int) -> bool: ...
    def get(self, key: int, default: str=None) -> str: ...
    def keys(self) -> _typing.Iterator[int]: ...
    def values(self) -> _typing.Iterator[str]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[int, str]]: ...


_List__Map__string_i32T = _typing.TypeVar('_List__Map__string_i32T', bound=_typing.Sequence[_typing.Mapping[str, int]])


class List__Map__string_i32(_typing.Sequence[_typing.Mapping[str, int]]):
    def __init__(self, items: _typing.Sequence[_typing.Mapping[str, int]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: _typing.Mapping[str, int]) -> int: ...
    def count(self, item: _typing.Mapping[str, int]) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Mapping[str, int]]) -> List__Map__string_i32: ...
    def __radd__(self, other: _List__Map__string_i32T) -> _List__Map__string_i32T: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__Map__string_i32: ...
    def __getitem__(self, index: int) -> _typing.Mapping[str, int]: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Mapping[str, int]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Mapping[str, int]]: ...
    def __contains__(self, item: _typing.Mapping[str, int]) -> bool: ...
    def __eq__(self, other: _typing.Sequence[_typing.Mapping[str, int]]) -> bool: ...


class Map__i16_string(_typing.Mapping[int, str]):
    def __init__(self, items: _typing.Mapping[int, str]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: _typing.Mapping[int, str]) -> bool: ...
    def __getitem__(self, key: int) -> str: ...
    def __iter__(self) -> _typing.Iterator[int]: ...
    def __contains__(self, key: int) -> bool: ...
    def get(self, key: int, default: str=None) -> str: ...
    def keys(self) -> _typing.Iterator[int]: ...
    def values(self) -> _typing.Iterator[str]: ...
    def items(self) -> _typing.Iterator[_typing.Tuple[int, str]]: ...


_List__Map__i16_stringT = _typing.TypeVar('_List__Map__i16_stringT', bound=_typing.Sequence[_typing.Mapping[int, str]])


class List__Map__i16_string(_typing.Sequence[_typing.Mapping[int, str]]):
    def __init__(self, items: _typing.Sequence[_typing.Mapping[int, str]]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: _typing.Mapping[int, str]) -> int: ...
    def count(self, item: _typing.Mapping[int, str]) -> int: ...
    def __add__(self, other: _typing.Sequence[_typing.Mapping[int, str]]) -> List__Map__i16_string: ...
    def __radd__(self, other: _List__Map__i16_stringT) -> _List__Map__i16_stringT: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__Map__i16_string: ...
    def __getitem__(self, index: int) -> _typing.Mapping[int, str]: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Mapping[int, str]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Mapping[int, str]]: ...
    def __contains__(self, item: _typing.Mapping[int, str]) -> bool: ...
    def __eq__(self, other: _typing.Sequence[_typing.Mapping[int, str]]) -> bool: ...


_List__MyStructT = _typing.TypeVar('_List__MyStructT', bound=_typing.Sequence[MyStruct])


class List__MyStruct(_typing.Sequence[MyStruct]):
    def __init__(self, items: _typing.Sequence[MyStruct]=None) -> None: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def index(self, item: MyStruct) -> int: ...
    def count(self, item: MyStruct) -> int: ...
    def __add__(self, other: _typing.Sequence[MyStruct]) -> List__MyStruct: ...
    def __radd__(self, other: _List__MyStructT) -> _List__MyStructT: ...
    @_typing.overload
    def __getitem__(self, index: slice) -> List__MyStruct: ...
    def __getitem__(self, index: int) -> MyStruct: ...
    def __reversed__(self) -> _typing.Iterator[MyStruct]: ...
    def __iter__(self) -> _typing.Iterator[MyStruct]: ...
    def __contains__(self, item: MyStruct) -> bool: ...
    def __eq__(self, other: _typing.Sequence[MyStruct]) -> bool: ...


