/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/GeneratedHeaderHelper.h>
#include <thrift/lib/cpp2/Thrift.h>
#include <thrift/lib/cpp2/gen/module_types_h.h>
#include <thrift/lib/cpp2/protocol/Protocol.h>

#include "thrift/compiler/test/fixtures/mcpp2-compare/gen-cpp2/includes_types.h"
#include <folly/small_vector.h>

// BEGIN declare_enums
namespace some { namespace valid { namespace ns {

enum class MyEnumA {
  fieldA = 1,
  fieldB = 2,
  fieldC = 4
};

using _MyEnumA_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<MyEnumA, MyEnumA>;
extern const _MyEnumA_EnumMapFactory::ValuesToNamesMapType _MyEnumA_VALUES_TO_NAMES;
extern const _MyEnumA_EnumMapFactory::NamesToValuesMapType _MyEnumA_NAMES_TO_VALUES;



enum class AnnotatedEnum : std::uint32_t {
  FIELDA = 2,
  FIELDB = 4,
  FIELDC = 9
};

using _AnnotatedEnum_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<AnnotatedEnum, AnnotatedEnum>;
extern const _AnnotatedEnum_EnumMapFactory::ValuesToNamesMapType _AnnotatedEnum_VALUES_TO_NAMES;
extern const _AnnotatedEnum_EnumMapFactory::NamesToValuesMapType _AnnotatedEnum_NAMES_TO_VALUES;

inline constexpr AnnotatedEnum operator&(AnnotatedEnum a, AnnotatedEnum b) {
  using E = AnnotatedEnum;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) & static_cast<U>(b));
}
inline constexpr AnnotatedEnum& operator&=(AnnotatedEnum& a, AnnotatedEnum b) {
  return a = a & b;
}

inline constexpr AnnotatedEnum operator|(AnnotatedEnum a, AnnotatedEnum b) {
  using E = AnnotatedEnum;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) | static_cast<U>(b));
}
inline constexpr AnnotatedEnum& operator|=(AnnotatedEnum& a, AnnotatedEnum b) {
  return a = a | b;
}

inline constexpr AnnotatedEnum operator^(AnnotatedEnum a, AnnotatedEnum b) {
  using E = AnnotatedEnum;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) ^ static_cast<U>(b));
}
inline constexpr AnnotatedEnum& operator^=(AnnotatedEnum& a, AnnotatedEnum b) {
  return a = a ^ b;
}

inline constexpr AnnotatedEnum operator~(AnnotatedEnum a) {
  using E = AnnotatedEnum;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(~static_cast<U>(a));
}

enum class AnnotatedEnum2 : short {
  FIELDA = 2,
  FIELDB = 4,
  FIELDC = 9
};

using _AnnotatedEnum2_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<AnnotatedEnum2, AnnotatedEnum2>;
extern const _AnnotatedEnum2_EnumMapFactory::ValuesToNamesMapType _AnnotatedEnum2_VALUES_TO_NAMES;
extern const _AnnotatedEnum2_EnumMapFactory::NamesToValuesMapType _AnnotatedEnum2_NAMES_TO_VALUES;

inline constexpr AnnotatedEnum2 operator&(AnnotatedEnum2 a, AnnotatedEnum2 b) {
  using E = AnnotatedEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) & static_cast<U>(b));
}
inline constexpr AnnotatedEnum2& operator&=(AnnotatedEnum2& a, AnnotatedEnum2 b) {
  return a = a & b;
}

inline constexpr AnnotatedEnum2 operator|(AnnotatedEnum2 a, AnnotatedEnum2 b) {
  using E = AnnotatedEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) | static_cast<U>(b));
}
inline constexpr AnnotatedEnum2& operator|=(AnnotatedEnum2& a, AnnotatedEnum2 b) {
  return a = a | b;
}

inline constexpr AnnotatedEnum2 operator^(AnnotatedEnum2 a, AnnotatedEnum2 b) {
  using E = AnnotatedEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) ^ static_cast<U>(b));
}
inline constexpr AnnotatedEnum2& operator^=(AnnotatedEnum2& a, AnnotatedEnum2 b) {
  return a = a ^ b;
}

inline constexpr AnnotatedEnum2 operator~(AnnotatedEnum2 a) {
  using E = AnnotatedEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(~static_cast<U>(a));
}

enum class MyEnumB {
  AField = 0
};

using _MyEnumB_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<MyEnumB, MyEnumB>;
extern const _MyEnumB_EnumMapFactory::ValuesToNamesMapType _MyEnumB_VALUES_TO_NAMES;
extern const _MyEnumB_EnumMapFactory::NamesToValuesMapType _MyEnumB_NAMES_TO_VALUES;



}}} // some::valid::ns
namespace std {


template<> struct hash<typename  ::some::valid::ns::MyEnumA> : public apache::thrift::detail::enum_hash<typename  ::some::valid::ns::MyEnumA> {};
template<> struct equal_to<typename  ::some::valid::ns::MyEnumA> : public apache::thrift::detail::enum_equal_to<typename  ::some::valid::ns::MyEnumA> {};


template<> struct hash<typename  ::some::valid::ns::AnnotatedEnum> : public apache::thrift::detail::enum_hash<typename  ::some::valid::ns::AnnotatedEnum> {};
template<> struct equal_to<typename  ::some::valid::ns::AnnotatedEnum> : public apache::thrift::detail::enum_equal_to<typename  ::some::valid::ns::AnnotatedEnum> {};


template<> struct hash<typename  ::some::valid::ns::AnnotatedEnum2> : public apache::thrift::detail::enum_hash<typename  ::some::valid::ns::AnnotatedEnum2> {};
template<> struct equal_to<typename  ::some::valid::ns::AnnotatedEnum2> : public apache::thrift::detail::enum_equal_to<typename  ::some::valid::ns::AnnotatedEnum2> {};


template<> struct hash<typename  ::some::valid::ns::MyEnumB> : public apache::thrift::detail::enum_hash<typename  ::some::valid::ns::MyEnumB> {};
template<> struct equal_to<typename  ::some::valid::ns::MyEnumB> : public apache::thrift::detail::enum_equal_to<typename  ::some::valid::ns::MyEnumB> {};


} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage< ::some::valid::ns::MyEnumA>;

template <> struct TEnumTraits< ::some::valid::ns::MyEnumA> {
  using type =  ::some::valid::ns::MyEnumA;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::fieldA; }
  static constexpr type max() { return type::fieldC; }
};


template <> struct TEnumDataStorage< ::some::valid::ns::AnnotatedEnum>;

template <> struct TEnumTraits< ::some::valid::ns::AnnotatedEnum> {
  using type =  ::some::valid::ns::AnnotatedEnum;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::FIELDA; }
  static constexpr type max() { return type::FIELDC; }
};


template <> struct TEnumDataStorage< ::some::valid::ns::AnnotatedEnum2>;

template <> struct TEnumTraits< ::some::valid::ns::AnnotatedEnum2> {
  using type =  ::some::valid::ns::AnnotatedEnum2;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::FIELDA; }
  static constexpr type max() { return type::FIELDC; }
};


template <> struct TEnumDataStorage< ::some::valid::ns::MyEnumB>;

template <> struct TEnumTraits< ::some::valid::ns::MyEnumB> {
  using type =  ::some::valid::ns::MyEnumB;

  static constexpr std::size_t const size = 1;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::AField; }
  static constexpr type max() { return type::AField; }
};


}} // apache::thrift


// END declare_enums
// BEGIN struct_indirection
namespace some { namespace valid { namespace ns {
struct apache_thrift_indirection_module_IndirectionA {
  template <typename T> static auto&& get(T&& x) {
    return std::forward<T>(x).value;
  }

  template <typename T> static auto&& get(T const&& x) {
    return std::forward<T>(x).value;
  }
};

struct apache_thrift_indirection_module_IndirectionC {
  template <typename T> static auto&& get(T&& x) {
    return std::forward<T>(x).__value();
  }

  template <typename T> static auto&& get(T const&& x) {
    return std::forward<T>(x).__value();
  }
};

struct apache_thrift_indirection_module_IndirectionB {
  template <typename T> static auto&& get(T&& x) {
    return std::forward<T>(x).value;
  }

  template <typename T> static auto&& get(T const&& x) {
    return std::forward<T>(x).value;
  }
};

struct apache_thrift_indirection_module_IndirectionD {
  template <typename T> static auto&& get(T&& x) {
    return std::forward<T>(x).value;
  }

  template <typename T> static auto&& get(T const&& x) {
    return std::forward<T>(x).value;
  }
};


}}} // some::valid::ns
// END struct_indirection
// BEGIN forward_declare
namespace some { namespace valid { namespace ns {
class Empty;
class ASimpleStruct;
class ASimpleStructNoexcept;
class MyStruct;
class SimpleUnion;
class ComplexUnion;
class AnException;
class AnotherException;
class containerStruct;
class MyIncludedStruct;
class AnnotatedStruct;
class ComplexContainerStruct;
class FloatStruct;
class FloatUnion;
class AllRequiredNoExceptMoveCtrStruct;
}}} // some::valid::ns
// END forward_declare
// BEGIN typedefs
namespace some { namespace valid { namespace ns {
typedef  ::a::different::ns::AStruct AStruct;
typedef int32_t simpleTypeDef;
typedef std::map<int16_t, std::string> containerTypeDef;
typedef std::vector<std::map<int16_t, std::string>> complexContainerTypeDef;
typedef std::set< ::some::valid::ns::SimpleUnion> unionTypeDef;
typedef std::vector< ::some::valid::ns::MyStruct> structTypeDef;
typedef std::vector<std::map< ::some::valid::ns::Empty,  ::some::valid::ns::MyStruct>> complexStructTypeDef;
typedef std::vector< ::some::valid::ns::complexStructTypeDef> mostComplexTypeDef;
typedef Foo IndirectionA;
typedef Baz IndirectionC;
typedef Bar IndirectionB;
typedef FooBar IndirectionD;
typedef std::map< ::some::valid::ns::MyEnumA, std::string> HashedTypedef;
typedef CppFakeI32 CppFakeI32;
typedef folly::small_vector<int64_t, 8 /* maxInline */> FollySmallVectorI64;
typedef folly::sorted_vector_set<std::string> SortedVectorSetString;
typedef FakeMap FakeMap;
typedef std::unordered_map<std::string, containerStruct> UnorderedMapStruct;
typedef std::list<int32_t> std_list;
typedef std::deque<std::string> std_deque;
typedef folly::sorted_vector_set<std::string> folly_set;
typedef folly::sorted_vector_map<int64_t, std::string> folly_map;
typedef folly::IOBuf IOBuf;
typedef std::unique_ptr<folly::IOBuf> IOBufPtr;

}}} // some::valid::ns
// END typedefs
// BEGIN hash_and_equal_to
namespace std {

template<> struct hash<typename  ::some::valid::ns::MyIncludedStruct> {
  size_t operator()(const  ::some::valid::ns::MyIncludedStruct&) const;
};
template<> struct equal_to<typename  ::some::valid::ns::MyIncludedStruct> {
  bool operator()(const  ::some::valid::ns::MyIncludedStruct&,const  ::some::valid::ns::MyIncludedStruct&) const;
};

template<> struct hash<typename  ::some::valid::ns::AnnotatedStruct> {
  size_t operator()(const  ::some::valid::ns::AnnotatedStruct&) const;
};
template<> struct equal_to<typename  ::some::valid::ns::AnnotatedStruct> {
  bool operator()(const  ::some::valid::ns::AnnotatedStruct&,const  ::some::valid::ns::AnnotatedStruct&) const;
};

template<> struct hash<typename  ::some::valid::ns::HashedTypedef> {
  size_t operator()(const  ::some::valid::ns::HashedTypedef&) const;
};
template<> struct equal_to<typename  ::some::valid::ns::HashedTypedef> {
  bool operator()(const  ::some::valid::ns::HashedTypedef&,const  ::some::valid::ns::HashedTypedef&) const;
};
} // std
// END hash_and_equal_to
namespace some { namespace valid { namespace ns {
class Empty final : private apache::thrift::detail::st::ComparisonOperators<Empty> {
 public:

  Empty() {}
  // FragileConstructor for use in initialization lists only.
  Empty(apache::thrift::FragileConstructor);
  Empty(Empty&& other) noexcept {}

  Empty(const Empty&) = default;

  Empty& operator=(Empty&&) = default;

  Empty& operator=(const Empty&) = default;
  void __clear();
  bool operator==(const Empty& rhs) const;
  bool operator<(const Empty& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< Empty >;
};

void swap(Empty& a, Empty& b);

template <class Protocol_>
uint32_t Empty::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class ASimpleStruct final : private apache::thrift::detail::st::ComparisonOperators<ASimpleStruct> {
 public:

  ASimpleStruct() :
      boolField(0) {}
  // FragileConstructor for use in initialization lists only.
  ASimpleStruct(apache::thrift::FragileConstructor, int64_t boolField__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    boolField = arg.extract();
    __isset.boolField = true;
  }

  ASimpleStruct(ASimpleStruct&&) = default;

  ASimpleStruct(const ASimpleStruct&) = default;

  ASimpleStruct& operator=(ASimpleStruct&&) = default;

  ASimpleStruct& operator=(const ASimpleStruct&) = default;
  void __clear();
  int64_t boolField;

  struct __isset {
    bool boolField;
  } __isset = {};
  bool operator==(const ASimpleStruct& rhs) const;
  bool operator<(const ASimpleStruct& rhs) const;

  int64_t get_boolField() const {
    return boolField;
  }

  int64_t& set_boolField(int64_t boolField_) {
    boolField = boolField_;
    __isset.boolField = true;
    return boolField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ASimpleStruct >;
};

void swap(ASimpleStruct& a, ASimpleStruct& b);

template <class Protocol_>
uint32_t ASimpleStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class ASimpleStructNoexcept final : private apache::thrift::detail::st::ComparisonOperators<ASimpleStructNoexcept> {
 public:

  ASimpleStructNoexcept() :
      boolField(0) {}
  // FragileConstructor for use in initialization lists only.
  ASimpleStructNoexcept(apache::thrift::FragileConstructor, int64_t boolField__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    boolField = arg.extract();
    __isset.boolField = true;
  }
  ASimpleStructNoexcept(ASimpleStructNoexcept&& other) noexcept :
      boolField(std::move(other.boolField)),
      __isset(other.__isset) {}
  ASimpleStructNoexcept(const ASimpleStructNoexcept&) = default;

  ASimpleStructNoexcept& operator=(ASimpleStructNoexcept&&) = default;

  ASimpleStructNoexcept& operator=(const ASimpleStructNoexcept&) = default;
  void __clear();
  int64_t boolField;

  struct __isset {
    bool boolField;
  } __isset = {};
  bool operator==(const ASimpleStructNoexcept& rhs) const;
  bool operator<(const ASimpleStructNoexcept& rhs) const;

  int64_t get_boolField() const {
    return boolField;
  }

  int64_t& set_boolField(int64_t boolField_) {
    boolField = boolField_;
    __isset.boolField = true;
    return boolField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ASimpleStructNoexcept >;
};

void swap(ASimpleStructNoexcept& a, ASimpleStructNoexcept& b);

template <class Protocol_>
uint32_t ASimpleStructNoexcept::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class MyStruct final : private apache::thrift::detail::st::ComparisonOperators<MyStruct> {
 public:

  MyStruct();

  // FragileConstructor for use in initialization lists only.
  MyStruct(apache::thrift::FragileConstructor, bool MyBoolField__arg, int64_t MyIntField__arg, std::string MyStringField__arg, std::string MyStringField2__arg, std::string MyBinaryField__arg, std::string MyBinaryField2__arg, std::string MyBinaryField3__arg, std::vector<std::string> MyBinaryListField4__arg, std::map< ::some::valid::ns::MyEnumA, std::string> MyMapEnumAndInt__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    MyBoolField = arg.extract();
    __isset.MyBoolField = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    MyIntField = arg.extract();
    __isset.MyIntField = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<3, _T> arg) {
    MyStringField = arg.extract();
    __isset.MyStringField = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<4, _T> arg) {
    MyStringField2 = arg.extract();
    __isset.MyStringField2 = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<5, _T> arg) {
    MyBinaryField = arg.extract();
    __isset.MyBinaryField = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<6, _T> arg) {
    MyBinaryField2 = arg.extract();
    __isset.MyBinaryField2 = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<7, _T> arg) {
    MyBinaryField3 = arg.extract();
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<8, _T> arg) {
    MyBinaryListField4 = arg.extract();
    __isset.MyBinaryListField4 = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<9, _T> arg) {
    MyMapEnumAndInt = arg.extract();
    __isset.MyMapEnumAndInt = true;
  }
  MyStruct(MyStruct&& other) noexcept;

  MyStruct(const MyStruct&) = default;

  MyStruct& operator=(MyStruct&&) = default;

  MyStruct& operator=(const MyStruct&) = default;
  void __clear();

  ~MyStruct();

  bool MyBoolField;
  int64_t MyIntField;
  std::string MyStringField;
  std::string MyStringField2;
  std::string MyBinaryField;
  std::string MyBinaryField2;
  std::string MyBinaryField3;
  std::vector<std::string> MyBinaryListField4;
  std::map< ::some::valid::ns::MyEnumA, std::string> MyMapEnumAndInt;

  struct __isset {
    bool MyBoolField;
    bool MyIntField;
    bool MyStringField;
    bool MyStringField2;
    bool MyBinaryField;
    bool MyBinaryField2;
    bool MyBinaryListField4;
    bool MyMapEnumAndInt;
  } __isset = {};
  bool operator==(const MyStruct& rhs) const;
  bool operator<(const MyStruct& rhs) const;

  bool get_MyBoolField() const {
    return MyBoolField;
  }

  bool& set_MyBoolField(bool MyBoolField_) {
    MyBoolField = MyBoolField_;
    __isset.MyBoolField = true;
    return MyBoolField;
  }

  int64_t get_MyIntField() const {
    return MyIntField;
  }

  int64_t& set_MyIntField(int64_t MyIntField_) {
    MyIntField = MyIntField_;
    __isset.MyIntField = true;
    return MyIntField;
  }

  const std::string& get_MyStringField() const& {
    return MyStringField;
  }

  std::string get_MyStringField() && {
    return std::move(MyStringField);
  }

  template <typename T_MyStruct_MyStringField_struct_setter = std::string>
  std::string& set_MyStringField(T_MyStruct_MyStringField_struct_setter&& MyStringField_) {
    MyStringField = std::forward<T_MyStruct_MyStringField_struct_setter>(MyStringField_);
    __isset.MyStringField = true;
    return MyStringField;
  }

  const std::string& get_MyStringField2() const& {
    return MyStringField2;
  }

  std::string get_MyStringField2() && {
    return std::move(MyStringField2);
  }

  template <typename T_MyStruct_MyStringField2_struct_setter = std::string>
  std::string& set_MyStringField2(T_MyStruct_MyStringField2_struct_setter&& MyStringField2_) {
    MyStringField2 = std::forward<T_MyStruct_MyStringField2_struct_setter>(MyStringField2_);
    __isset.MyStringField2 = true;
    return MyStringField2;
  }

  const std::string& get_MyBinaryField() const& {
    return MyBinaryField;
  }

  std::string get_MyBinaryField() && {
    return std::move(MyBinaryField);
  }

  template <typename T_MyStruct_MyBinaryField_struct_setter = std::string>
  std::string& set_MyBinaryField(T_MyStruct_MyBinaryField_struct_setter&& MyBinaryField_) {
    MyBinaryField = std::forward<T_MyStruct_MyBinaryField_struct_setter>(MyBinaryField_);
    __isset.MyBinaryField = true;
    return MyBinaryField;
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<const std::string&> MyBinaryField2_ref() const& {
    return {MyBinaryField2, __isset.MyBinaryField2};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<const std::string&&> MyBinaryField2_ref() const&& {
    return {std::move(MyBinaryField2), __isset.MyBinaryField2};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<std::string&> MyBinaryField2_ref() & {
    return {MyBinaryField2, __isset.MyBinaryField2};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<std::string&&> MyBinaryField2_ref() && {
    return {std::move(MyBinaryField2), __isset.MyBinaryField2};
  }

  const std::string* get_MyBinaryField2() const& {
    return __isset.MyBinaryField2 ? std::addressof(MyBinaryField2) : nullptr;
  }

  std::string* get_MyBinaryField2() & {
    return __isset.MyBinaryField2 ? std::addressof(MyBinaryField2) : nullptr;
  }
  std::string* get_MyBinaryField2() && = delete;

  template <typename T_MyStruct_MyBinaryField2_struct_setter = std::string>
  std::string& set_MyBinaryField2(T_MyStruct_MyBinaryField2_struct_setter&& MyBinaryField2_) {
    MyBinaryField2 = std::forward<T_MyStruct_MyBinaryField2_struct_setter>(MyBinaryField2_);
    __isset.MyBinaryField2 = true;
    return MyBinaryField2;
  }

  const std::string& get_MyBinaryField3() const& {
    return MyBinaryField3;
  }

  std::string get_MyBinaryField3() && {
    return std::move(MyBinaryField3);
  }

  template <typename T_MyStruct_MyBinaryField3_struct_setter = std::string>
  std::string& set_MyBinaryField3(T_MyStruct_MyBinaryField3_struct_setter&& MyBinaryField3_) {
    MyBinaryField3 = std::forward<T_MyStruct_MyBinaryField3_struct_setter>(MyBinaryField3_);
    return MyBinaryField3;
  }
  const std::vector<std::string>& get_MyBinaryListField4() const&;
  std::vector<std::string> get_MyBinaryListField4() &&;

  template <typename T_MyStruct_MyBinaryListField4_struct_setter = std::vector<std::string>>
  std::vector<std::string>& set_MyBinaryListField4(T_MyStruct_MyBinaryListField4_struct_setter&& MyBinaryListField4_) {
    MyBinaryListField4 = std::forward<T_MyStruct_MyBinaryListField4_struct_setter>(MyBinaryListField4_);
    __isset.MyBinaryListField4 = true;
    return MyBinaryListField4;
  }
  const std::map< ::some::valid::ns::MyEnumA, std::string>& get_MyMapEnumAndInt() const&;
  std::map< ::some::valid::ns::MyEnumA, std::string> get_MyMapEnumAndInt() &&;

  template <typename T_MyStruct_MyMapEnumAndInt_struct_setter = std::map< ::some::valid::ns::MyEnumA, std::string>>
  std::map< ::some::valid::ns::MyEnumA, std::string>& set_MyMapEnumAndInt(T_MyStruct_MyMapEnumAndInt_struct_setter&& MyMapEnumAndInt_) {
    MyMapEnumAndInt = std::forward<T_MyStruct_MyMapEnumAndInt_struct_setter>(MyMapEnumAndInt_);
    __isset.MyMapEnumAndInt = true;
    return MyMapEnumAndInt;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< MyStruct >;
};

void swap(MyStruct& a, MyStruct& b);

template <class Protocol_>
uint32_t MyStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class SimpleUnion : private apache::thrift::detail::st::ComparisonOperators<SimpleUnion> {
 public:
  enum Type {
    __EMPTY__ = 0,
    intValue = 7,
    stringValue = 2,
  } ;

  SimpleUnion()
      : type_(Type::__EMPTY__) {}

  SimpleUnion(SimpleUnion&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  SimpleUnion(const SimpleUnion& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(rhs.value_.intValue);
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(rhs.value_.stringValue);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  SimpleUnion& operator=(SimpleUnion&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  SimpleUnion& operator=(const SimpleUnion& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(rhs.value_.intValue);
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(rhs.value_.stringValue);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<7, _T> arg) {
    set_intValue(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    set_stringValue(arg.extract());
  }
  void __clear();

  virtual ~SimpleUnion() {
    __clear();
  }

  union storage_type {
    int64_t intValue;
    std::string stringValue;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const SimpleUnion& rhs) const;
  bool operator<(const SimpleUnion& rhs) const;

  int64_t& set_intValue(int64_t t = int64_t()) {
    __clear();
    type_ = Type::intValue;
    ::new (std::addressof(value_.intValue)) int64_t(t);
    return value_.intValue;
  }

  std::string& set_stringValue(std::string const &t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) std::string(t);
    return value_.stringValue;
  }

  std::string& set_stringValue(std::string&& t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) std::string(std::move(t));
    return value_.stringValue;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::string, T...>> std::string& set_stringValue(T&&... t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) std::string(std::forward<T>(t)...);
    return value_.stringValue;
  }

  int64_t const & get_intValue() const {
    assert(type_ == Type::intValue);
    return value_.intValue;
  }

  std::string const & get_stringValue() const {
    assert(type_ == Type::stringValue);
    return value_.stringValue;
  }

  int64_t & mutable_intValue() {
    assert(type_ == Type::intValue);
    return value_.intValue;
  }

  std::string & mutable_stringValue() {
    assert(type_ == Type::stringValue);
    return value_.stringValue;
  }

  int64_t move_intValue() {
    assert(type_ == Type::intValue);
    return std::move(value_.intValue);
  }

  std::string move_stringValue() {
    assert(type_ == Type::stringValue);
    return std::move(value_.stringValue);
  }

  Type getType() const { return type_; }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  Type type_;
  storage_type value_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< SimpleUnion >;
};

void swap(SimpleUnion& a, SimpleUnion& b);

template <class Protocol_>
uint32_t SimpleUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class ComplexUnion final : private apache::thrift::detail::st::ComparisonOperators<ComplexUnion> {
 public:
  enum Type {
    __EMPTY__ = 0,
    intValue = 1,
    opt_intValue = 201,
    stringValue = 3,
    opt_stringValue = 203,
    intValue2 = 4,
    intValue3 = 6,
    doubelValue = 7,
    boolValue = 8,
    union_list = 9,
    union_set = 10,
    union_map = 11,
    opt_union_map = 211,
    enum_field = 12,
    enum_container = 13,
    a_struct = 14,
    a_set_struct = 15,
    a_union = 16,
    opt_a_union = 216,
    a_union_list = 17,
    a_union_typedef = 18,
    a_union_typedef_list = 19,
    MyBinaryField = 20,
    MyBinaryField2 = 21,
    MyBinaryListField4 = 23,
    ref_field = 24,
    ref_field2 = 25,
    excp_field = 26,
  } ;

  ComplexUnion()
      : type_(Type::__EMPTY__) {}

  ComplexUnion(ComplexUnion&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::opt_intValue:
      {
        set_opt_intValue(std::move(rhs.value_.opt_intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      case Type::opt_stringValue:
      {
        set_opt_stringValue(std::move(rhs.value_.opt_stringValue));
        break;
      }
      case Type::intValue2:
      {
        set_intValue2(std::move(rhs.value_.intValue2));
        break;
      }
      case Type::intValue3:
      {
        set_intValue3(std::move(rhs.value_.intValue3));
        break;
      }
      case Type::doubelValue:
      {
        set_doubelValue(std::move(rhs.value_.doubelValue));
        break;
      }
      case Type::boolValue:
      {
        set_boolValue(std::move(rhs.value_.boolValue));
        break;
      }
      case Type::union_list:
      {
        set_union_list(std::move(rhs.value_.union_list));
        break;
      }
      case Type::union_set:
      {
        set_union_set(std::move(rhs.value_.union_set));
        break;
      }
      case Type::union_map:
      {
        set_union_map(std::move(rhs.value_.union_map));
        break;
      }
      case Type::opt_union_map:
      {
        set_opt_union_map(std::move(rhs.value_.opt_union_map));
        break;
      }
      case Type::enum_field:
      {
        set_enum_field(std::move(rhs.value_.enum_field));
        break;
      }
      case Type::enum_container:
      {
        set_enum_container(std::move(rhs.value_.enum_container));
        break;
      }
      case Type::a_struct:
      {
        set_a_struct(std::move(rhs.value_.a_struct));
        break;
      }
      case Type::a_set_struct:
      {
        set_a_set_struct(std::move(rhs.value_.a_set_struct));
        break;
      }
      case Type::a_union:
      {
        set_a_union(std::move(rhs.value_.a_union));
        break;
      }
      case Type::opt_a_union:
      {
        set_opt_a_union(std::move(rhs.value_.opt_a_union));
        break;
      }
      case Type::a_union_list:
      {
        set_a_union_list(std::move(rhs.value_.a_union_list));
        break;
      }
      case Type::a_union_typedef:
      {
        set_a_union_typedef(std::move(rhs.value_.a_union_typedef));
        break;
      }
      case Type::a_union_typedef_list:
      {
        set_a_union_typedef_list(std::move(rhs.value_.a_union_typedef_list));
        break;
      }
      case Type::MyBinaryField:
      {
        set_MyBinaryField(std::move(rhs.value_.MyBinaryField));
        break;
      }
      case Type::MyBinaryField2:
      {
        set_MyBinaryField2(std::move(rhs.value_.MyBinaryField2));
        break;
      }
      case Type::MyBinaryListField4:
      {
        set_MyBinaryListField4(std::move(rhs.value_.MyBinaryListField4));
        break;
      }
      case Type::ref_field:
      {
        set_ref_field(std::move(*rhs.value_.ref_field));
        break;
      }
      case Type::ref_field2:
      {
        set_ref_field2(std::move(*rhs.value_.ref_field2));
        break;
      }
      case Type::excp_field:
      {
        set_excp_field(std::move(rhs.value_.excp_field));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  ComplexUnion(const ComplexUnion& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(rhs.value_.intValue);
        break;
      }
      case Type::opt_intValue:
      {
        set_opt_intValue(rhs.value_.opt_intValue);
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(rhs.value_.stringValue);
        break;
      }
      case Type::opt_stringValue:
      {
        set_opt_stringValue(rhs.value_.opt_stringValue);
        break;
      }
      case Type::intValue2:
      {
        set_intValue2(rhs.value_.intValue2);
        break;
      }
      case Type::intValue3:
      {
        set_intValue3(rhs.value_.intValue3);
        break;
      }
      case Type::doubelValue:
      {
        set_doubelValue(rhs.value_.doubelValue);
        break;
      }
      case Type::boolValue:
      {
        set_boolValue(rhs.value_.boolValue);
        break;
      }
      case Type::union_list:
      {
        set_union_list(rhs.value_.union_list);
        break;
      }
      case Type::union_set:
      {
        set_union_set(rhs.value_.union_set);
        break;
      }
      case Type::union_map:
      {
        set_union_map(rhs.value_.union_map);
        break;
      }
      case Type::opt_union_map:
      {
        set_opt_union_map(rhs.value_.opt_union_map);
        break;
      }
      case Type::enum_field:
      {
        set_enum_field(rhs.value_.enum_field);
        break;
      }
      case Type::enum_container:
      {
        set_enum_container(rhs.value_.enum_container);
        break;
      }
      case Type::a_struct:
      {
        set_a_struct(rhs.value_.a_struct);
        break;
      }
      case Type::a_set_struct:
      {
        set_a_set_struct(rhs.value_.a_set_struct);
        break;
      }
      case Type::a_union:
      {
        set_a_union(rhs.value_.a_union);
        break;
      }
      case Type::opt_a_union:
      {
        set_opt_a_union(rhs.value_.opt_a_union);
        break;
      }
      case Type::a_union_list:
      {
        set_a_union_list(rhs.value_.a_union_list);
        break;
      }
      case Type::a_union_typedef:
      {
        set_a_union_typedef(rhs.value_.a_union_typedef);
        break;
      }
      case Type::a_union_typedef_list:
      {
        set_a_union_typedef_list(rhs.value_.a_union_typedef_list);
        break;
      }
      case Type::MyBinaryField:
      {
        set_MyBinaryField(rhs.value_.MyBinaryField);
        break;
      }
      case Type::MyBinaryField2:
      {
        set_MyBinaryField2(rhs.value_.MyBinaryField2);
        break;
      }
      case Type::MyBinaryListField4:
      {
        set_MyBinaryListField4(rhs.value_.MyBinaryListField4);
        break;
      }
      case Type::ref_field:
      {
        set_ref_field(*rhs.value_.ref_field);
        break;
      }
      case Type::ref_field2:
      {
        set_ref_field2(*rhs.value_.ref_field2);
        break;
      }
      case Type::excp_field:
      {
        set_excp_field(rhs.value_.excp_field);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  ComplexUnion& operator=(ComplexUnion&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::opt_intValue:
      {
        set_opt_intValue(std::move(rhs.value_.opt_intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      case Type::opt_stringValue:
      {
        set_opt_stringValue(std::move(rhs.value_.opt_stringValue));
        break;
      }
      case Type::intValue2:
      {
        set_intValue2(std::move(rhs.value_.intValue2));
        break;
      }
      case Type::intValue3:
      {
        set_intValue3(std::move(rhs.value_.intValue3));
        break;
      }
      case Type::doubelValue:
      {
        set_doubelValue(std::move(rhs.value_.doubelValue));
        break;
      }
      case Type::boolValue:
      {
        set_boolValue(std::move(rhs.value_.boolValue));
        break;
      }
      case Type::union_list:
      {
        set_union_list(std::move(rhs.value_.union_list));
        break;
      }
      case Type::union_set:
      {
        set_union_set(std::move(rhs.value_.union_set));
        break;
      }
      case Type::union_map:
      {
        set_union_map(std::move(rhs.value_.union_map));
        break;
      }
      case Type::opt_union_map:
      {
        set_opt_union_map(std::move(rhs.value_.opt_union_map));
        break;
      }
      case Type::enum_field:
      {
        set_enum_field(std::move(rhs.value_.enum_field));
        break;
      }
      case Type::enum_container:
      {
        set_enum_container(std::move(rhs.value_.enum_container));
        break;
      }
      case Type::a_struct:
      {
        set_a_struct(std::move(rhs.value_.a_struct));
        break;
      }
      case Type::a_set_struct:
      {
        set_a_set_struct(std::move(rhs.value_.a_set_struct));
        break;
      }
      case Type::a_union:
      {
        set_a_union(std::move(rhs.value_.a_union));
        break;
      }
      case Type::opt_a_union:
      {
        set_opt_a_union(std::move(rhs.value_.opt_a_union));
        break;
      }
      case Type::a_union_list:
      {
        set_a_union_list(std::move(rhs.value_.a_union_list));
        break;
      }
      case Type::a_union_typedef:
      {
        set_a_union_typedef(std::move(rhs.value_.a_union_typedef));
        break;
      }
      case Type::a_union_typedef_list:
      {
        set_a_union_typedef_list(std::move(rhs.value_.a_union_typedef_list));
        break;
      }
      case Type::MyBinaryField:
      {
        set_MyBinaryField(std::move(rhs.value_.MyBinaryField));
        break;
      }
      case Type::MyBinaryField2:
      {
        set_MyBinaryField2(std::move(rhs.value_.MyBinaryField2));
        break;
      }
      case Type::MyBinaryListField4:
      {
        set_MyBinaryListField4(std::move(rhs.value_.MyBinaryListField4));
        break;
      }
      case Type::ref_field:
      {
        set_ref_field(std::move(*rhs.value_.ref_field));
        break;
      }
      case Type::ref_field2:
      {
        set_ref_field2(std::move(*rhs.value_.ref_field2));
        break;
      }
      case Type::excp_field:
      {
        set_excp_field(std::move(rhs.value_.excp_field));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  ComplexUnion& operator=(const ComplexUnion& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::intValue:
      {
        set_intValue(rhs.value_.intValue);
        break;
      }
      case Type::opt_intValue:
      {
        set_opt_intValue(rhs.value_.opt_intValue);
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(rhs.value_.stringValue);
        break;
      }
      case Type::opt_stringValue:
      {
        set_opt_stringValue(rhs.value_.opt_stringValue);
        break;
      }
      case Type::intValue2:
      {
        set_intValue2(rhs.value_.intValue2);
        break;
      }
      case Type::intValue3:
      {
        set_intValue3(rhs.value_.intValue3);
        break;
      }
      case Type::doubelValue:
      {
        set_doubelValue(rhs.value_.doubelValue);
        break;
      }
      case Type::boolValue:
      {
        set_boolValue(rhs.value_.boolValue);
        break;
      }
      case Type::union_list:
      {
        set_union_list(rhs.value_.union_list);
        break;
      }
      case Type::union_set:
      {
        set_union_set(rhs.value_.union_set);
        break;
      }
      case Type::union_map:
      {
        set_union_map(rhs.value_.union_map);
        break;
      }
      case Type::opt_union_map:
      {
        set_opt_union_map(rhs.value_.opt_union_map);
        break;
      }
      case Type::enum_field:
      {
        set_enum_field(rhs.value_.enum_field);
        break;
      }
      case Type::enum_container:
      {
        set_enum_container(rhs.value_.enum_container);
        break;
      }
      case Type::a_struct:
      {
        set_a_struct(rhs.value_.a_struct);
        break;
      }
      case Type::a_set_struct:
      {
        set_a_set_struct(rhs.value_.a_set_struct);
        break;
      }
      case Type::a_union:
      {
        set_a_union(rhs.value_.a_union);
        break;
      }
      case Type::opt_a_union:
      {
        set_opt_a_union(rhs.value_.opt_a_union);
        break;
      }
      case Type::a_union_list:
      {
        set_a_union_list(rhs.value_.a_union_list);
        break;
      }
      case Type::a_union_typedef:
      {
        set_a_union_typedef(rhs.value_.a_union_typedef);
        break;
      }
      case Type::a_union_typedef_list:
      {
        set_a_union_typedef_list(rhs.value_.a_union_typedef_list);
        break;
      }
      case Type::MyBinaryField:
      {
        set_MyBinaryField(rhs.value_.MyBinaryField);
        break;
      }
      case Type::MyBinaryField2:
      {
        set_MyBinaryField2(rhs.value_.MyBinaryField2);
        break;
      }
      case Type::MyBinaryListField4:
      {
        set_MyBinaryListField4(rhs.value_.MyBinaryListField4);
        break;
      }
      case Type::ref_field:
      {
        set_ref_field(*rhs.value_.ref_field);
        break;
      }
      case Type::ref_field2:
      {
        set_ref_field2(*rhs.value_.ref_field2);
        break;
      }
      case Type::excp_field:
      {
        set_excp_field(rhs.value_.excp_field);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    set_intValue(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<201, _T> arg) {
    set_opt_intValue(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<3, _T> arg) {
    set_stringValue(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<203, _T> arg) {
    set_opt_stringValue(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<4, _T> arg) {
    set_intValue2(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<6, _T> arg) {
    set_intValue3(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<7, _T> arg) {
    set_doubelValue(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<8, _T> arg) {
    set_boolValue(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<9, _T> arg) {
    set_union_list(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<10, _T> arg) {
    set_union_set(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<11, _T> arg) {
    set_union_map(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<211, _T> arg) {
    set_opt_union_map(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<12, _T> arg) {
    set_enum_field(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<13, _T> arg) {
    set_enum_container(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<14, _T> arg) {
    set_a_struct(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<15, _T> arg) {
    set_a_set_struct(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<16, _T> arg) {
    set_a_union(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<216, _T> arg) {
    set_opt_a_union(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<17, _T> arg) {
    set_a_union_list(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<18, _T> arg) {
    set_a_union_typedef(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<19, _T> arg) {
    set_a_union_typedef_list(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<20, _T> arg) {
    set_MyBinaryField(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<21, _T> arg) {
    set_MyBinaryField2(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<23, _T> arg) {
    set_MyBinaryListField4(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<24, _T> arg) {
    set_ref_field(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<25, _T> arg) {
    set_ref_field2(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<26, _T> arg) {
    set_excp_field(arg.extract());
  }
  void __clear();

  ~ComplexUnion() {
    __clear();
  }
  union storage_type {
    int64_t intValue;
    int64_t opt_intValue;
    std::string stringValue;
    std::string opt_stringValue;
    int16_t intValue2;
    int32_t intValue3;
    double doubelValue;
    bool boolValue;
    std::vector<int32_t> union_list;
    std::set<int64_t> union_set;
    std::map<std::string, int32_t> union_map;
    std::map<std::string, int32_t> opt_union_map;
     ::some::valid::ns::MyEnumA enum_field;
    std::vector< ::some::valid::ns::MyEnumA> enum_container;
     ::some::valid::ns::MyStruct a_struct;
    std::set< ::some::valid::ns::MyStruct> a_set_struct;
     ::some::valid::ns::SimpleUnion a_union;
     ::some::valid::ns::SimpleUnion opt_a_union;
    std::vector< ::some::valid::ns::SimpleUnion> a_union_list;
     ::some::valid::ns::unionTypeDef a_union_typedef;
    std::vector< ::some::valid::ns::unionTypeDef> a_union_typedef_list;
    std::string MyBinaryField;
    std::string MyBinaryField2;
    std::vector<std::string> MyBinaryListField4;
    std::unique_ptr< ::some::valid::ns::MyStruct> ref_field;
    std::shared_ptr<const  ::some::valid::ns::MyStruct> ref_field2;
     ::some::valid::ns::AnException excp_field;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const ComplexUnion& rhs) const;
  bool operator<(const ComplexUnion& rhs) const;

  int64_t& set_intValue(int64_t t = int64_t()) {
    __clear();
    type_ = Type::intValue;
    ::new (std::addressof(value_.intValue)) int64_t(t);
    return value_.intValue;
  }

  int64_t& set_opt_intValue(int64_t t = int64_t()) {
    __clear();
    type_ = Type::opt_intValue;
    ::new (std::addressof(value_.opt_intValue)) int64_t(t);
    return value_.opt_intValue;
  }

  std::string& set_stringValue(std::string const &t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) std::string(t);
    return value_.stringValue;
  }

  std::string& set_stringValue(std::string&& t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) std::string(std::move(t));
    return value_.stringValue;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::string, T...>> std::string& set_stringValue(T&&... t) {
    __clear();
    type_ = Type::stringValue;
    ::new (std::addressof(value_.stringValue)) std::string(std::forward<T>(t)...);
    return value_.stringValue;
  }

  std::string& set_opt_stringValue(std::string const &t) {
    __clear();
    type_ = Type::opt_stringValue;
    ::new (std::addressof(value_.opt_stringValue)) std::string(t);
    return value_.opt_stringValue;
  }

  std::string& set_opt_stringValue(std::string&& t) {
    __clear();
    type_ = Type::opt_stringValue;
    ::new (std::addressof(value_.opt_stringValue)) std::string(std::move(t));
    return value_.opt_stringValue;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::string, T...>> std::string& set_opt_stringValue(T&&... t) {
    __clear();
    type_ = Type::opt_stringValue;
    ::new (std::addressof(value_.opt_stringValue)) std::string(std::forward<T>(t)...);
    return value_.opt_stringValue;
  }

  int16_t& set_intValue2(int16_t t = int16_t()) {
    __clear();
    type_ = Type::intValue2;
    ::new (std::addressof(value_.intValue2)) int16_t(t);
    return value_.intValue2;
  }

  int32_t& set_intValue3(int32_t t = int32_t()) {
    __clear();
    type_ = Type::intValue3;
    ::new (std::addressof(value_.intValue3)) int32_t(t);
    return value_.intValue3;
  }

  double& set_doubelValue(double t = double()) {
    __clear();
    type_ = Type::doubelValue;
    ::new (std::addressof(value_.doubelValue)) double(t);
    return value_.doubelValue;
  }

  bool& set_boolValue(bool t = bool()) {
    __clear();
    type_ = Type::boolValue;
    ::new (std::addressof(value_.boolValue)) bool(t);
    return value_.boolValue;
  }

  std::vector<int32_t>& set_union_list(std::vector<int32_t> const &t) {
    __clear();
    type_ = Type::union_list;
    ::new (std::addressof(value_.union_list)) std::vector<int32_t>(t);
    return value_.union_list;
  }

  std::vector<int32_t>& set_union_list(std::vector<int32_t>&& t) {
    __clear();
    type_ = Type::union_list;
    ::new (std::addressof(value_.union_list)) std::vector<int32_t>(std::move(t));
    return value_.union_list;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::vector<int32_t>, T...>> std::vector<int32_t>& set_union_list(T&&... t) {
    __clear();
    type_ = Type::union_list;
    ::new (std::addressof(value_.union_list)) std::vector<int32_t>(std::forward<T>(t)...);
    return value_.union_list;
  }

  std::set<int64_t>& set_union_set(std::set<int64_t> const &t) {
    __clear();
    type_ = Type::union_set;
    ::new (std::addressof(value_.union_set)) std::set<int64_t>(t);
    return value_.union_set;
  }

  std::set<int64_t>& set_union_set(std::set<int64_t>&& t) {
    __clear();
    type_ = Type::union_set;
    ::new (std::addressof(value_.union_set)) std::set<int64_t>(std::move(t));
    return value_.union_set;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::set<int64_t>, T...>> std::set<int64_t>& set_union_set(T&&... t) {
    __clear();
    type_ = Type::union_set;
    ::new (std::addressof(value_.union_set)) std::set<int64_t>(std::forward<T>(t)...);
    return value_.union_set;
  }

  std::map<std::string, int32_t>& set_union_map(std::map<std::string, int32_t> const &t) {
    __clear();
    type_ = Type::union_map;
    ::new (std::addressof(value_.union_map)) std::map<std::string, int32_t>(t);
    return value_.union_map;
  }

  std::map<std::string, int32_t>& set_union_map(std::map<std::string, int32_t>&& t) {
    __clear();
    type_ = Type::union_map;
    ::new (std::addressof(value_.union_map)) std::map<std::string, int32_t>(std::move(t));
    return value_.union_map;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::map<std::string, int32_t>, T...>> std::map<std::string, int32_t>& set_union_map(T&&... t) {
    __clear();
    type_ = Type::union_map;
    ::new (std::addressof(value_.union_map)) std::map<std::string, int32_t>(std::forward<T>(t)...);
    return value_.union_map;
  }

  std::map<std::string, int32_t>& set_opt_union_map(std::map<std::string, int32_t> const &t) {
    __clear();
    type_ = Type::opt_union_map;
    ::new (std::addressof(value_.opt_union_map)) std::map<std::string, int32_t>(t);
    return value_.opt_union_map;
  }

  std::map<std::string, int32_t>& set_opt_union_map(std::map<std::string, int32_t>&& t) {
    __clear();
    type_ = Type::opt_union_map;
    ::new (std::addressof(value_.opt_union_map)) std::map<std::string, int32_t>(std::move(t));
    return value_.opt_union_map;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::map<std::string, int32_t>, T...>> std::map<std::string, int32_t>& set_opt_union_map(T&&... t) {
    __clear();
    type_ = Type::opt_union_map;
    ::new (std::addressof(value_.opt_union_map)) std::map<std::string, int32_t>(std::forward<T>(t)...);
    return value_.opt_union_map;
  }

   ::some::valid::ns::MyEnumA& set_enum_field( ::some::valid::ns::MyEnumA t =  ::some::valid::ns::MyEnumA()) {
    __clear();
    type_ = Type::enum_field;
    ::new (std::addressof(value_.enum_field))  ::some::valid::ns::MyEnumA(t);
    return value_.enum_field;
  }

  std::vector< ::some::valid::ns::MyEnumA>& set_enum_container(std::vector< ::some::valid::ns::MyEnumA> const &t) {
    __clear();
    type_ = Type::enum_container;
    ::new (std::addressof(value_.enum_container)) std::vector< ::some::valid::ns::MyEnumA>(t);
    return value_.enum_container;
  }

  std::vector< ::some::valid::ns::MyEnumA>& set_enum_container(std::vector< ::some::valid::ns::MyEnumA>&& t) {
    __clear();
    type_ = Type::enum_container;
    ::new (std::addressof(value_.enum_container)) std::vector< ::some::valid::ns::MyEnumA>(std::move(t));
    return value_.enum_container;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::vector< ::some::valid::ns::MyEnumA>, T...>> std::vector< ::some::valid::ns::MyEnumA>& set_enum_container(T&&... t) {
    __clear();
    type_ = Type::enum_container;
    ::new (std::addressof(value_.enum_container)) std::vector< ::some::valid::ns::MyEnumA>(std::forward<T>(t)...);
    return value_.enum_container;
  }

   ::some::valid::ns::MyStruct& set_a_struct( ::some::valid::ns::MyStruct const &t) {
    __clear();
    type_ = Type::a_struct;
    ::new (std::addressof(value_.a_struct))  ::some::valid::ns::MyStruct(t);
    return value_.a_struct;
  }

   ::some::valid::ns::MyStruct& set_a_struct( ::some::valid::ns::MyStruct&& t) {
    __clear();
    type_ = Type::a_struct;
    ::new (std::addressof(value_.a_struct))  ::some::valid::ns::MyStruct(std::move(t));
    return value_.a_struct;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::some::valid::ns::MyStruct, T...>>  ::some::valid::ns::MyStruct& set_a_struct(T&&... t) {
    __clear();
    type_ = Type::a_struct;
    ::new (std::addressof(value_.a_struct))  ::some::valid::ns::MyStruct(std::forward<T>(t)...);
    return value_.a_struct;
  }

  std::set< ::some::valid::ns::MyStruct>& set_a_set_struct(std::set< ::some::valid::ns::MyStruct> const &t) {
    __clear();
    type_ = Type::a_set_struct;
    ::new (std::addressof(value_.a_set_struct)) std::set< ::some::valid::ns::MyStruct>(t);
    return value_.a_set_struct;
  }

  std::set< ::some::valid::ns::MyStruct>& set_a_set_struct(std::set< ::some::valid::ns::MyStruct>&& t) {
    __clear();
    type_ = Type::a_set_struct;
    ::new (std::addressof(value_.a_set_struct)) std::set< ::some::valid::ns::MyStruct>(std::move(t));
    return value_.a_set_struct;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::set< ::some::valid::ns::MyStruct>, T...>> std::set< ::some::valid::ns::MyStruct>& set_a_set_struct(T&&... t) {
    __clear();
    type_ = Type::a_set_struct;
    ::new (std::addressof(value_.a_set_struct)) std::set< ::some::valid::ns::MyStruct>(std::forward<T>(t)...);
    return value_.a_set_struct;
  }

   ::some::valid::ns::SimpleUnion& set_a_union( ::some::valid::ns::SimpleUnion const &t) {
    __clear();
    type_ = Type::a_union;
    ::new (std::addressof(value_.a_union))  ::some::valid::ns::SimpleUnion(t);
    return value_.a_union;
  }

   ::some::valid::ns::SimpleUnion& set_a_union( ::some::valid::ns::SimpleUnion&& t) {
    __clear();
    type_ = Type::a_union;
    ::new (std::addressof(value_.a_union))  ::some::valid::ns::SimpleUnion(std::move(t));
    return value_.a_union;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::some::valid::ns::SimpleUnion, T...>>  ::some::valid::ns::SimpleUnion& set_a_union(T&&... t) {
    __clear();
    type_ = Type::a_union;
    ::new (std::addressof(value_.a_union))  ::some::valid::ns::SimpleUnion(std::forward<T>(t)...);
    return value_.a_union;
  }

   ::some::valid::ns::SimpleUnion& set_opt_a_union( ::some::valid::ns::SimpleUnion const &t) {
    __clear();
    type_ = Type::opt_a_union;
    ::new (std::addressof(value_.opt_a_union))  ::some::valid::ns::SimpleUnion(t);
    return value_.opt_a_union;
  }

   ::some::valid::ns::SimpleUnion& set_opt_a_union( ::some::valid::ns::SimpleUnion&& t) {
    __clear();
    type_ = Type::opt_a_union;
    ::new (std::addressof(value_.opt_a_union))  ::some::valid::ns::SimpleUnion(std::move(t));
    return value_.opt_a_union;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::some::valid::ns::SimpleUnion, T...>>  ::some::valid::ns::SimpleUnion& set_opt_a_union(T&&... t) {
    __clear();
    type_ = Type::opt_a_union;
    ::new (std::addressof(value_.opt_a_union))  ::some::valid::ns::SimpleUnion(std::forward<T>(t)...);
    return value_.opt_a_union;
  }

  std::vector< ::some::valid::ns::SimpleUnion>& set_a_union_list(std::vector< ::some::valid::ns::SimpleUnion> const &t) {
    __clear();
    type_ = Type::a_union_list;
    ::new (std::addressof(value_.a_union_list)) std::vector< ::some::valid::ns::SimpleUnion>(t);
    return value_.a_union_list;
  }

  std::vector< ::some::valid::ns::SimpleUnion>& set_a_union_list(std::vector< ::some::valid::ns::SimpleUnion>&& t) {
    __clear();
    type_ = Type::a_union_list;
    ::new (std::addressof(value_.a_union_list)) std::vector< ::some::valid::ns::SimpleUnion>(std::move(t));
    return value_.a_union_list;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::vector< ::some::valid::ns::SimpleUnion>, T...>> std::vector< ::some::valid::ns::SimpleUnion>& set_a_union_list(T&&... t) {
    __clear();
    type_ = Type::a_union_list;
    ::new (std::addressof(value_.a_union_list)) std::vector< ::some::valid::ns::SimpleUnion>(std::forward<T>(t)...);
    return value_.a_union_list;
  }

   ::some::valid::ns::unionTypeDef& set_a_union_typedef( ::some::valid::ns::unionTypeDef const &t) {
    __clear();
    type_ = Type::a_union_typedef;
    ::new (std::addressof(value_.a_union_typedef))  ::some::valid::ns::unionTypeDef(t);
    return value_.a_union_typedef;
  }

   ::some::valid::ns::unionTypeDef& set_a_union_typedef( ::some::valid::ns::unionTypeDef&& t) {
    __clear();
    type_ = Type::a_union_typedef;
    ::new (std::addressof(value_.a_union_typedef))  ::some::valid::ns::unionTypeDef(std::move(t));
    return value_.a_union_typedef;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::some::valid::ns::unionTypeDef, T...>>  ::some::valid::ns::unionTypeDef& set_a_union_typedef(T&&... t) {
    __clear();
    type_ = Type::a_union_typedef;
    ::new (std::addressof(value_.a_union_typedef))  ::some::valid::ns::unionTypeDef(std::forward<T>(t)...);
    return value_.a_union_typedef;
  }

  std::vector< ::some::valid::ns::unionTypeDef>& set_a_union_typedef_list(std::vector< ::some::valid::ns::unionTypeDef> const &t) {
    __clear();
    type_ = Type::a_union_typedef_list;
    ::new (std::addressof(value_.a_union_typedef_list)) std::vector< ::some::valid::ns::unionTypeDef>(t);
    return value_.a_union_typedef_list;
  }

  std::vector< ::some::valid::ns::unionTypeDef>& set_a_union_typedef_list(std::vector< ::some::valid::ns::unionTypeDef>&& t) {
    __clear();
    type_ = Type::a_union_typedef_list;
    ::new (std::addressof(value_.a_union_typedef_list)) std::vector< ::some::valid::ns::unionTypeDef>(std::move(t));
    return value_.a_union_typedef_list;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::vector< ::some::valid::ns::unionTypeDef>, T...>> std::vector< ::some::valid::ns::unionTypeDef>& set_a_union_typedef_list(T&&... t) {
    __clear();
    type_ = Type::a_union_typedef_list;
    ::new (std::addressof(value_.a_union_typedef_list)) std::vector< ::some::valid::ns::unionTypeDef>(std::forward<T>(t)...);
    return value_.a_union_typedef_list;
  }

  std::string& set_MyBinaryField(std::string const &t) {
    __clear();
    type_ = Type::MyBinaryField;
    ::new (std::addressof(value_.MyBinaryField)) std::string(t);
    return value_.MyBinaryField;
  }

  std::string& set_MyBinaryField(std::string&& t) {
    __clear();
    type_ = Type::MyBinaryField;
    ::new (std::addressof(value_.MyBinaryField)) std::string(std::move(t));
    return value_.MyBinaryField;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::string, T...>> std::string& set_MyBinaryField(T&&... t) {
    __clear();
    type_ = Type::MyBinaryField;
    ::new (std::addressof(value_.MyBinaryField)) std::string(std::forward<T>(t)...);
    return value_.MyBinaryField;
  }

  std::string& set_MyBinaryField2(std::string const &t) {
    __clear();
    type_ = Type::MyBinaryField2;
    ::new (std::addressof(value_.MyBinaryField2)) std::string(t);
    return value_.MyBinaryField2;
  }

  std::string& set_MyBinaryField2(std::string&& t) {
    __clear();
    type_ = Type::MyBinaryField2;
    ::new (std::addressof(value_.MyBinaryField2)) std::string(std::move(t));
    return value_.MyBinaryField2;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::string, T...>> std::string& set_MyBinaryField2(T&&... t) {
    __clear();
    type_ = Type::MyBinaryField2;
    ::new (std::addressof(value_.MyBinaryField2)) std::string(std::forward<T>(t)...);
    return value_.MyBinaryField2;
  }

  std::vector<std::string>& set_MyBinaryListField4(std::vector<std::string> const &t) {
    __clear();
    type_ = Type::MyBinaryListField4;
    ::new (std::addressof(value_.MyBinaryListField4)) std::vector<std::string>(t);
    return value_.MyBinaryListField4;
  }

  std::vector<std::string>& set_MyBinaryListField4(std::vector<std::string>&& t) {
    __clear();
    type_ = Type::MyBinaryListField4;
    ::new (std::addressof(value_.MyBinaryListField4)) std::vector<std::string>(std::move(t));
    return value_.MyBinaryListField4;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<std::vector<std::string>, T...>> std::vector<std::string>& set_MyBinaryListField4(T&&... t) {
    __clear();
    type_ = Type::MyBinaryListField4;
    ::new (std::addressof(value_.MyBinaryListField4)) std::vector<std::string>(std::forward<T>(t)...);
    return value_.MyBinaryListField4;
  }
  std::unique_ptr< ::some::valid::ns::MyStruct>& set_ref_field( ::some::valid::ns::MyStruct const &t);
  std::unique_ptr< ::some::valid::ns::MyStruct>& set_ref_field( ::some::valid::ns::MyStruct&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::some::valid::ns::MyStruct, T...>> std::unique_ptr< ::some::valid::ns::MyStruct>& set_ref_field(T&&... t);
  std::shared_ptr<const  ::some::valid::ns::MyStruct>& set_ref_field2( ::some::valid::ns::MyStruct const &t);
  std::shared_ptr<const  ::some::valid::ns::MyStruct>& set_ref_field2( ::some::valid::ns::MyStruct&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::some::valid::ns::MyStruct, T...>> std::shared_ptr<const  ::some::valid::ns::MyStruct>& set_ref_field2(T&&... t);

   ::some::valid::ns::AnException& set_excp_field( ::some::valid::ns::AnException const &t) {
    __clear();
    type_ = Type::excp_field;
    ::new (std::addressof(value_.excp_field))  ::some::valid::ns::AnException(t);
    return value_.excp_field;
  }

   ::some::valid::ns::AnException& set_excp_field( ::some::valid::ns::AnException&& t) {
    __clear();
    type_ = Type::excp_field;
    ::new (std::addressof(value_.excp_field))  ::some::valid::ns::AnException(std::move(t));
    return value_.excp_field;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::some::valid::ns::AnException, T...>>  ::some::valid::ns::AnException& set_excp_field(T&&... t) {
    __clear();
    type_ = Type::excp_field;
    ::new (std::addressof(value_.excp_field))  ::some::valid::ns::AnException(std::forward<T>(t)...);
    return value_.excp_field;
  }

  int64_t const & get_intValue() const {
    assert(type_ == Type::intValue);
    return value_.intValue;
  }

  int64_t const & get_opt_intValue() const {
    assert(type_ == Type::opt_intValue);
    return value_.opt_intValue;
  }

  std::string const & get_stringValue() const {
    assert(type_ == Type::stringValue);
    return value_.stringValue;
  }

  std::string const & get_opt_stringValue() const {
    assert(type_ == Type::opt_stringValue);
    return value_.opt_stringValue;
  }

  int16_t const & get_intValue2() const {
    assert(type_ == Type::intValue2);
    return value_.intValue2;
  }

  int32_t const & get_intValue3() const {
    assert(type_ == Type::intValue3);
    return value_.intValue3;
  }

  double const & get_doubelValue() const {
    assert(type_ == Type::doubelValue);
    return value_.doubelValue;
  }

  bool const & get_boolValue() const {
    assert(type_ == Type::boolValue);
    return value_.boolValue;
  }

  std::vector<int32_t> const & get_union_list() const {
    assert(type_ == Type::union_list);
    return value_.union_list;
  }

  std::set<int64_t> const & get_union_set() const {
    assert(type_ == Type::union_set);
    return value_.union_set;
  }

  std::map<std::string, int32_t> const & get_union_map() const {
    assert(type_ == Type::union_map);
    return value_.union_map;
  }

  std::map<std::string, int32_t> const & get_opt_union_map() const {
    assert(type_ == Type::opt_union_map);
    return value_.opt_union_map;
  }

   ::some::valid::ns::MyEnumA const & get_enum_field() const {
    assert(type_ == Type::enum_field);
    return value_.enum_field;
  }

  std::vector< ::some::valid::ns::MyEnumA> const & get_enum_container() const {
    assert(type_ == Type::enum_container);
    return value_.enum_container;
  }

   ::some::valid::ns::MyStruct const & get_a_struct() const {
    assert(type_ == Type::a_struct);
    return value_.a_struct;
  }

  std::set< ::some::valid::ns::MyStruct> const & get_a_set_struct() const {
    assert(type_ == Type::a_set_struct);
    return value_.a_set_struct;
  }

   ::some::valid::ns::SimpleUnion const & get_a_union() const {
    assert(type_ == Type::a_union);
    return value_.a_union;
  }

   ::some::valid::ns::SimpleUnion const & get_opt_a_union() const {
    assert(type_ == Type::opt_a_union);
    return value_.opt_a_union;
  }

  std::vector< ::some::valid::ns::SimpleUnion> const & get_a_union_list() const {
    assert(type_ == Type::a_union_list);
    return value_.a_union_list;
  }

   ::some::valid::ns::unionTypeDef const & get_a_union_typedef() const {
    assert(type_ == Type::a_union_typedef);
    return value_.a_union_typedef;
  }

  std::vector< ::some::valid::ns::unionTypeDef> const & get_a_union_typedef_list() const {
    assert(type_ == Type::a_union_typedef_list);
    return value_.a_union_typedef_list;
  }

  std::string const & get_MyBinaryField() const {
    assert(type_ == Type::MyBinaryField);
    return value_.MyBinaryField;
  }

  std::string const & get_MyBinaryField2() const {
    assert(type_ == Type::MyBinaryField2);
    return value_.MyBinaryField2;
  }

  std::vector<std::string> const & get_MyBinaryListField4() const {
    assert(type_ == Type::MyBinaryListField4);
    return value_.MyBinaryListField4;
  }

  std::unique_ptr< ::some::valid::ns::MyStruct> const & get_ref_field() const {
    assert(type_ == Type::ref_field);
    return value_.ref_field;
  }

  std::shared_ptr<const  ::some::valid::ns::MyStruct> const & get_ref_field2() const {
    assert(type_ == Type::ref_field2);
    return value_.ref_field2;
  }

   ::some::valid::ns::AnException const & get_excp_field() const {
    assert(type_ == Type::excp_field);
    return value_.excp_field;
  }

  int64_t & mutable_intValue() {
    assert(type_ == Type::intValue);
    return value_.intValue;
  }

  int64_t & mutable_opt_intValue() {
    assert(type_ == Type::opt_intValue);
    return value_.opt_intValue;
  }

  std::string & mutable_stringValue() {
    assert(type_ == Type::stringValue);
    return value_.stringValue;
  }

  std::string & mutable_opt_stringValue() {
    assert(type_ == Type::opt_stringValue);
    return value_.opt_stringValue;
  }

  int16_t & mutable_intValue2() {
    assert(type_ == Type::intValue2);
    return value_.intValue2;
  }

  int32_t & mutable_intValue3() {
    assert(type_ == Type::intValue3);
    return value_.intValue3;
  }

  double & mutable_doubelValue() {
    assert(type_ == Type::doubelValue);
    return value_.doubelValue;
  }

  bool & mutable_boolValue() {
    assert(type_ == Type::boolValue);
    return value_.boolValue;
  }

  std::vector<int32_t> & mutable_union_list() {
    assert(type_ == Type::union_list);
    return value_.union_list;
  }

  std::set<int64_t> & mutable_union_set() {
    assert(type_ == Type::union_set);
    return value_.union_set;
  }

  std::map<std::string, int32_t> & mutable_union_map() {
    assert(type_ == Type::union_map);
    return value_.union_map;
  }

  std::map<std::string, int32_t> & mutable_opt_union_map() {
    assert(type_ == Type::opt_union_map);
    return value_.opt_union_map;
  }

   ::some::valid::ns::MyEnumA & mutable_enum_field() {
    assert(type_ == Type::enum_field);
    return value_.enum_field;
  }

  std::vector< ::some::valid::ns::MyEnumA> & mutable_enum_container() {
    assert(type_ == Type::enum_container);
    return value_.enum_container;
  }

   ::some::valid::ns::MyStruct & mutable_a_struct() {
    assert(type_ == Type::a_struct);
    return value_.a_struct;
  }

  std::set< ::some::valid::ns::MyStruct> & mutable_a_set_struct() {
    assert(type_ == Type::a_set_struct);
    return value_.a_set_struct;
  }

   ::some::valid::ns::SimpleUnion & mutable_a_union() {
    assert(type_ == Type::a_union);
    return value_.a_union;
  }

   ::some::valid::ns::SimpleUnion & mutable_opt_a_union() {
    assert(type_ == Type::opt_a_union);
    return value_.opt_a_union;
  }

  std::vector< ::some::valid::ns::SimpleUnion> & mutable_a_union_list() {
    assert(type_ == Type::a_union_list);
    return value_.a_union_list;
  }

   ::some::valid::ns::unionTypeDef & mutable_a_union_typedef() {
    assert(type_ == Type::a_union_typedef);
    return value_.a_union_typedef;
  }

  std::vector< ::some::valid::ns::unionTypeDef> & mutable_a_union_typedef_list() {
    assert(type_ == Type::a_union_typedef_list);
    return value_.a_union_typedef_list;
  }

  std::string & mutable_MyBinaryField() {
    assert(type_ == Type::MyBinaryField);
    return value_.MyBinaryField;
  }

  std::string & mutable_MyBinaryField2() {
    assert(type_ == Type::MyBinaryField2);
    return value_.MyBinaryField2;
  }

  std::vector<std::string> & mutable_MyBinaryListField4() {
    assert(type_ == Type::MyBinaryListField4);
    return value_.MyBinaryListField4;
  }

  std::unique_ptr< ::some::valid::ns::MyStruct> & mutable_ref_field() {
    assert(type_ == Type::ref_field);
    return value_.ref_field;
  }

  std::shared_ptr<const  ::some::valid::ns::MyStruct> & mutable_ref_field2() {
    assert(type_ == Type::ref_field2);
    return value_.ref_field2;
  }

   ::some::valid::ns::AnException & mutable_excp_field() {
    assert(type_ == Type::excp_field);
    return value_.excp_field;
  }

  int64_t move_intValue() {
    assert(type_ == Type::intValue);
    return std::move(value_.intValue);
  }

  int64_t move_opt_intValue() {
    assert(type_ == Type::opt_intValue);
    return std::move(value_.opt_intValue);
  }

  std::string move_stringValue() {
    assert(type_ == Type::stringValue);
    return std::move(value_.stringValue);
  }

  std::string move_opt_stringValue() {
    assert(type_ == Type::opt_stringValue);
    return std::move(value_.opt_stringValue);
  }

  int16_t move_intValue2() {
    assert(type_ == Type::intValue2);
    return std::move(value_.intValue2);
  }

  int32_t move_intValue3() {
    assert(type_ == Type::intValue3);
    return std::move(value_.intValue3);
  }

  double move_doubelValue() {
    assert(type_ == Type::doubelValue);
    return std::move(value_.doubelValue);
  }

  bool move_boolValue() {
    assert(type_ == Type::boolValue);
    return std::move(value_.boolValue);
  }

  std::vector<int32_t> move_union_list() {
    assert(type_ == Type::union_list);
    return std::move(value_.union_list);
  }

  std::set<int64_t> move_union_set() {
    assert(type_ == Type::union_set);
    return std::move(value_.union_set);
  }

  std::map<std::string, int32_t> move_union_map() {
    assert(type_ == Type::union_map);
    return std::move(value_.union_map);
  }

  std::map<std::string, int32_t> move_opt_union_map() {
    assert(type_ == Type::opt_union_map);
    return std::move(value_.opt_union_map);
  }

   ::some::valid::ns::MyEnumA move_enum_field() {
    assert(type_ == Type::enum_field);
    return std::move(value_.enum_field);
  }

  std::vector< ::some::valid::ns::MyEnumA> move_enum_container() {
    assert(type_ == Type::enum_container);
    return std::move(value_.enum_container);
  }

   ::some::valid::ns::MyStruct move_a_struct() {
    assert(type_ == Type::a_struct);
    return std::move(value_.a_struct);
  }

  std::set< ::some::valid::ns::MyStruct> move_a_set_struct() {
    assert(type_ == Type::a_set_struct);
    return std::move(value_.a_set_struct);
  }

   ::some::valid::ns::SimpleUnion move_a_union() {
    assert(type_ == Type::a_union);
    return std::move(value_.a_union);
  }

   ::some::valid::ns::SimpleUnion move_opt_a_union() {
    assert(type_ == Type::opt_a_union);
    return std::move(value_.opt_a_union);
  }

  std::vector< ::some::valid::ns::SimpleUnion> move_a_union_list() {
    assert(type_ == Type::a_union_list);
    return std::move(value_.a_union_list);
  }

   ::some::valid::ns::unionTypeDef move_a_union_typedef() {
    assert(type_ == Type::a_union_typedef);
    return std::move(value_.a_union_typedef);
  }

  std::vector< ::some::valid::ns::unionTypeDef> move_a_union_typedef_list() {
    assert(type_ == Type::a_union_typedef_list);
    return std::move(value_.a_union_typedef_list);
  }

  std::string move_MyBinaryField() {
    assert(type_ == Type::MyBinaryField);
    return std::move(value_.MyBinaryField);
  }

  std::string move_MyBinaryField2() {
    assert(type_ == Type::MyBinaryField2);
    return std::move(value_.MyBinaryField2);
  }

  std::vector<std::string> move_MyBinaryListField4() {
    assert(type_ == Type::MyBinaryListField4);
    return std::move(value_.MyBinaryListField4);
  }

  std::unique_ptr< ::some::valid::ns::MyStruct> move_ref_field() {
    assert(type_ == Type::ref_field);
    return std::move(value_.ref_field);
  }

  std::shared_ptr<const  ::some::valid::ns::MyStruct> move_ref_field2() {
    assert(type_ == Type::ref_field2);
    return std::move(value_.ref_field2);
  }

   ::some::valid::ns::AnException move_excp_field() {
    assert(type_ == Type::excp_field);
    return std::move(value_.excp_field);
  }

  Type getType() const { return type_; }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  Type type_;
  storage_type value_;
  // user defined code (cpp2.methods = ...)
  void foo(const std::string& bar) {}

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ComplexUnion >;
};

void swap(ComplexUnion& a, ComplexUnion& b);

template <class Protocol_>
uint32_t ComplexUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class AnException final : private apache::thrift::detail::st::ComparisonOperators<AnException>, public apache::thrift::TException {
 public:

  AnException();


  explicit AnException(const std::string& __message) :
      message2(__message) {}

  explicit AnException(std::string&& __message) :
      message2(std::move(__message)) {}
  // FragileConstructor for use in initialization lists only.
  AnException(apache::thrift::FragileConstructor, int32_t code__arg, int32_t req_code__arg, std::string message2__arg, std::string req_message__arg, std::vector<int32_t> exception_list__arg, std::set<int64_t> exception_set__arg, std::map<std::string, int32_t> exception_map__arg, std::map<std::string, int32_t> req_exception_map__arg,  ::some::valid::ns::MyEnumA enum_field__arg, std::vector< ::some::valid::ns::MyEnumA> enum_container__arg,  ::some::valid::ns::MyStruct a_struct__arg, std::set< ::some::valid::ns::MyStruct> a_set_struct__arg, std::vector< ::some::valid::ns::SimpleUnion> a_union_list__arg,  ::some::valid::ns::unionTypeDef union_typedef__arg, std::vector< ::some::valid::ns::unionTypeDef> a_union_typedef_list__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    code = arg.extract();
    __isset.code = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<101, _T> arg) {
    req_code = arg.extract();
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    message2 = arg.extract();
    __isset.message2 = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<102, _T> arg) {
    req_message = arg.extract();
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<3, _T> arg) {
    exception_list = arg.extract();
    __isset.exception_list = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<4, _T> arg) {
    exception_set = arg.extract();
    __isset.exception_set = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<5, _T> arg) {
    exception_map = arg.extract();
    __isset.exception_map = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<105, _T> arg) {
    req_exception_map = arg.extract();
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<6, _T> arg) {
    enum_field = arg.extract();
    __isset.enum_field = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<7, _T> arg) {
    enum_container = arg.extract();
    __isset.enum_container = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<8, _T> arg) {
    a_struct = arg.extract();
    __isset.a_struct = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<9, _T> arg) {
    a_set_struct = arg.extract();
    __isset.a_set_struct = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<10, _T> arg) {
    a_union_list = arg.extract();
    __isset.a_union_list = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<11, _T> arg) {
    union_typedef = arg.extract();
    __isset.union_typedef = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<19, _T> arg) {
    a_union_typedef_list = arg.extract();
    __isset.a_union_typedef_list = true;
  }

  AnException(AnException&&) = default;

  AnException(const AnException&) = default;

  AnException& operator=(AnException&&) = default;

  AnException& operator=(const AnException&) = default;
  void __clear();

  ~AnException();

  int32_t code;
  int32_t req_code;
  std::string message2;
  std::string req_message;
  std::vector<int32_t> exception_list;
  std::set<int64_t> exception_set;
  std::map<std::string, int32_t> exception_map;
  std::map<std::string, int32_t> req_exception_map;
   ::some::valid::ns::MyEnumA enum_field;
  std::vector< ::some::valid::ns::MyEnumA> enum_container;
   ::some::valid::ns::MyStruct a_struct;
  std::set< ::some::valid::ns::MyStruct> a_set_struct;
  std::vector< ::some::valid::ns::SimpleUnion> a_union_list;
   ::some::valid::ns::unionTypeDef union_typedef;
  std::vector< ::some::valid::ns::unionTypeDef> a_union_typedef_list;

  struct __isset {
    bool code;
    bool message2;
    bool exception_list;
    bool exception_set;
    bool exception_map;
    bool enum_field;
    bool enum_container;
    bool a_struct;
    bool a_set_struct;
    bool a_union_list;
    bool union_typedef;
    bool a_union_typedef_list;
  } __isset = {};
  bool operator==(const AnException& rhs) const;
  bool operator<(const AnException& rhs) const;

  int32_t get_code() const {
    return code;
  }

  int32_t& set_code(int32_t code_) {
    code = code_;
    __isset.code = true;
    return code;
  }

  int32_t get_req_code() const {
    return req_code;
  }

  int32_t& set_req_code(int32_t req_code_) {
    req_code = req_code_;
    return req_code;
  }

  const std::string& get_message2() const& {
    return message2;
  }

  std::string get_message2() && {
    return std::move(message2);
  }

  template <typename T_AnException_message2_struct_setter = std::string>
  std::string& set_message2(T_AnException_message2_struct_setter&& message2_) {
    message2 = std::forward<T_AnException_message2_struct_setter>(message2_);
    __isset.message2 = true;
    return message2;
  }

  const std::string& get_req_message() const& {
    return req_message;
  }

  std::string get_req_message() && {
    return std::move(req_message);
  }

  template <typename T_AnException_req_message_struct_setter = std::string>
  std::string& set_req_message(T_AnException_req_message_struct_setter&& req_message_) {
    req_message = std::forward<T_AnException_req_message_struct_setter>(req_message_);
    return req_message;
  }
  const std::vector<int32_t>& get_exception_list() const&;
  std::vector<int32_t> get_exception_list() &&;

  template <typename T_AnException_exception_list_struct_setter = std::vector<int32_t>>
  std::vector<int32_t>& set_exception_list(T_AnException_exception_list_struct_setter&& exception_list_) {
    exception_list = std::forward<T_AnException_exception_list_struct_setter>(exception_list_);
    __isset.exception_list = true;
    return exception_list;
  }
  const std::set<int64_t>& get_exception_set() const&;
  std::set<int64_t> get_exception_set() &&;

  template <typename T_AnException_exception_set_struct_setter = std::set<int64_t>>
  std::set<int64_t>& set_exception_set(T_AnException_exception_set_struct_setter&& exception_set_) {
    exception_set = std::forward<T_AnException_exception_set_struct_setter>(exception_set_);
    __isset.exception_set = true;
    return exception_set;
  }
  const std::map<std::string, int32_t>& get_exception_map() const&;
  std::map<std::string, int32_t> get_exception_map() &&;

  template <typename T_AnException_exception_map_struct_setter = std::map<std::string, int32_t>>
  std::map<std::string, int32_t>& set_exception_map(T_AnException_exception_map_struct_setter&& exception_map_) {
    exception_map = std::forward<T_AnException_exception_map_struct_setter>(exception_map_);
    __isset.exception_map = true;
    return exception_map;
  }
  const std::map<std::string, int32_t>& get_req_exception_map() const&;
  std::map<std::string, int32_t> get_req_exception_map() &&;

  template <typename T_AnException_req_exception_map_struct_setter = std::map<std::string, int32_t>>
  std::map<std::string, int32_t>& set_req_exception_map(T_AnException_req_exception_map_struct_setter&& req_exception_map_) {
    req_exception_map = std::forward<T_AnException_req_exception_map_struct_setter>(req_exception_map_);
    return req_exception_map;
  }

   ::some::valid::ns::MyEnumA get_enum_field() const {
    return enum_field;
  }

   ::some::valid::ns::MyEnumA& set_enum_field( ::some::valid::ns::MyEnumA enum_field_) {
    enum_field = enum_field_;
    __isset.enum_field = true;
    return enum_field;
  }
  const std::vector< ::some::valid::ns::MyEnumA>& get_enum_container() const&;
  std::vector< ::some::valid::ns::MyEnumA> get_enum_container() &&;

  template <typename T_AnException_enum_container_struct_setter = std::vector< ::some::valid::ns::MyEnumA>>
  std::vector< ::some::valid::ns::MyEnumA>& set_enum_container(T_AnException_enum_container_struct_setter&& enum_container_) {
    enum_container = std::forward<T_AnException_enum_container_struct_setter>(enum_container_);
    __isset.enum_container = true;
    return enum_container;
  }
  const  ::some::valid::ns::MyStruct& get_a_struct() const&;
   ::some::valid::ns::MyStruct get_a_struct() &&;

  template <typename T_AnException_a_struct_struct_setter =  ::some::valid::ns::MyStruct>
   ::some::valid::ns::MyStruct& set_a_struct(T_AnException_a_struct_struct_setter&& a_struct_) {
    a_struct = std::forward<T_AnException_a_struct_struct_setter>(a_struct_);
    __isset.a_struct = true;
    return a_struct;
  }
  const std::set< ::some::valid::ns::MyStruct>& get_a_set_struct() const&;
  std::set< ::some::valid::ns::MyStruct> get_a_set_struct() &&;

  template <typename T_AnException_a_set_struct_struct_setter = std::set< ::some::valid::ns::MyStruct>>
  std::set< ::some::valid::ns::MyStruct>& set_a_set_struct(T_AnException_a_set_struct_struct_setter&& a_set_struct_) {
    a_set_struct = std::forward<T_AnException_a_set_struct_struct_setter>(a_set_struct_);
    __isset.a_set_struct = true;
    return a_set_struct;
  }
  const std::vector< ::some::valid::ns::SimpleUnion>& get_a_union_list() const&;
  std::vector< ::some::valid::ns::SimpleUnion> get_a_union_list() &&;

  template <typename T_AnException_a_union_list_struct_setter = std::vector< ::some::valid::ns::SimpleUnion>>
  std::vector< ::some::valid::ns::SimpleUnion>& set_a_union_list(T_AnException_a_union_list_struct_setter&& a_union_list_) {
    a_union_list = std::forward<T_AnException_a_union_list_struct_setter>(a_union_list_);
    __isset.a_union_list = true;
    return a_union_list;
  }
  const  ::some::valid::ns::unionTypeDef& get_union_typedef() const&;
   ::some::valid::ns::unionTypeDef get_union_typedef() &&;

  template <typename T_AnException_union_typedef_struct_setter =  ::some::valid::ns::unionTypeDef>
   ::some::valid::ns::unionTypeDef& set_union_typedef(T_AnException_union_typedef_struct_setter&& union_typedef_) {
    union_typedef = std::forward<T_AnException_union_typedef_struct_setter>(union_typedef_);
    __isset.union_typedef = true;
    return union_typedef;
  }
  const std::vector< ::some::valid::ns::unionTypeDef>& get_a_union_typedef_list() const&;
  std::vector< ::some::valid::ns::unionTypeDef> get_a_union_typedef_list() &&;

  template <typename T_AnException_a_union_typedef_list_struct_setter = std::vector< ::some::valid::ns::unionTypeDef>>
  std::vector< ::some::valid::ns::unionTypeDef>& set_a_union_typedef_list(T_AnException_a_union_typedef_list_struct_setter&& a_union_typedef_list_) {
    a_union_typedef_list = std::forward<T_AnException_a_union_typedef_list_struct_setter>(a_union_typedef_list_);
    __isset.a_union_typedef_list = true;
    return a_union_typedef_list;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

  const char* what() const noexcept override {
    return message2.c_str();
  }

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AnException >;
};

void swap(AnException& a, AnException& b);

template <class Protocol_>
uint32_t AnException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class AnotherException : private apache::thrift::detail::st::ComparisonOperators<AnotherException>, public apache::thrift::TException {
 public:

  AnotherException() :
      code(0),
      req_code(0) {}
  // FragileConstructor for use in initialization lists only.
  AnotherException(apache::thrift::FragileConstructor, int32_t code__arg, int32_t req_code__arg, std::string message__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    code = arg.extract();
    __isset.code = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<101, _T> arg) {
    req_code = arg.extract();
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    message = arg.extract();
    __isset.message = true;
  }

  AnotherException(AnotherException&&) = default;

  AnotherException(const AnotherException&) = default;

  AnotherException& operator=(AnotherException&&) = default;

  AnotherException& operator=(const AnotherException&) = default;
  void __clear();

  virtual ~AnotherException() {}

  int32_t code;
  int32_t req_code;
  std::string message;

  struct __isset {
    bool code;
    bool message;
  } __isset = {};
  bool operator==(const AnotherException& rhs) const;
  bool operator<(const AnotherException& rhs) const;

  int32_t get_code() const {
    return code;
  }

  int32_t& set_code(int32_t code_) {
    code = code_;
    __isset.code = true;
    return code;
  }

  int32_t get_req_code() const {
    return req_code;
  }

  int32_t& set_req_code(int32_t req_code_) {
    req_code = req_code_;
    return req_code;
  }

  const std::string& get_message() const& {
    return message;
  }

  std::string get_message() && {
    return std::move(message);
  }

  template <typename T_AnotherException_message_struct_setter = std::string>
  std::string& set_message(T_AnotherException_message_struct_setter&& message_) {
    message = std::forward<T_AnotherException_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

  const char* what() const noexcept override {
    return " ::some::valid::ns::AnotherException";
  }

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AnotherException >;
};

void swap(AnotherException& a, AnotherException& b);

template <class Protocol_>
uint32_t AnotherException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class containerStruct final : private apache::thrift::detail::st::ComparisonOperators<containerStruct> {
 public:

  containerStruct();

  // FragileConstructor for use in initialization lists only.
  containerStruct(apache::thrift::FragileConstructor, bool fieldA__arg, bool req_fieldA__arg, bool opt_fieldA__arg, std::map<std::string, bool> fieldB__arg, std::map<std::string, bool> req_fieldB__arg, std::map<std::string, bool> opt_fieldB__arg, std::set<int32_t> fieldC__arg, std::set<int32_t> req_fieldC__arg, std::set<int32_t> opt_fieldC__arg, std::string fieldD__arg, std::string fieldE__arg, std::string req_fieldE__arg, std::string opt_fieldE__arg, std::vector<std::vector<int32_t>> fieldF__arg, std::map<std::string, std::map<std::string, std::map<std::string, int32_t>>> fieldG__arg, std::vector<std::set<int32_t>> fieldH__arg, bool fieldI__arg, std::map<std::string, std::vector<int32_t>> fieldJ__arg, std::vector<std::vector<std::vector<std::vector<int32_t>>>> fieldK__arg, std::set<std::set<std::set<bool>>> fieldL__arg, std::map<std::set<std::vector<int32_t>>, std::map<std::vector<std::set<std::string>>, std::string>> fieldM__arg,  ::some::valid::ns::simpleTypeDef fieldN__arg,  ::some::valid::ns::complexStructTypeDef fieldO__arg, std::vector< ::some::valid::ns::mostComplexTypeDef> fieldP__arg,  ::some::valid::ns::MyEnumA fieldQ__arg,  ::some::valid::ns::MyEnumA fieldR__arg,  ::some::valid::ns::MyEnumA req_fieldR__arg,  ::some::valid::ns::MyEnumA opt_fieldR__arg,  ::some::valid::ns::MyEnumA fieldS__arg, std::vector< ::some::valid::ns::MyEnumA> fieldT__arg, std::vector< ::some::valid::ns::MyEnumA> fieldU__arg,  ::some::valid::ns::MyStruct fieldV__arg,  ::some::valid::ns::MyStruct req_fieldV__arg,  ::some::valid::ns::MyStruct opt_fieldV__arg, std::set< ::some::valid::ns::MyStruct> fieldW__arg,  ::some::valid::ns::ComplexUnion fieldX__arg,  ::some::valid::ns::ComplexUnion req_fieldX__arg,  ::some::valid::ns::ComplexUnion opt_fieldX__arg, std::vector< ::some::valid::ns::ComplexUnion> fieldY__arg,  ::some::valid::ns::unionTypeDef fieldZ__arg, std::vector< ::some::valid::ns::unionTypeDef> fieldAA__arg, std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC> fieldAB__arg,  ::some::valid::ns::MyEnumB fieldAC__arg,  ::a::different::ns::AnEnum fieldAD__arg, std::map<std::string, int32_t> fieldAE__arg,  ::some::valid::ns::IndirectionD fieldSD__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    fieldA = arg.extract();
    __isset.fieldA = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<101, _T> arg) {
    req_fieldA = arg.extract();
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<201, _T> arg) {
    opt_fieldA = arg.extract();
    __isset.opt_fieldA = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    fieldB = arg.extract();
    __isset.fieldB = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<102, _T> arg) {
    req_fieldB = arg.extract();
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<202, _T> arg) {
    opt_fieldB = arg.extract();
    __isset.opt_fieldB = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<3, _T> arg) {
    fieldC = arg.extract();
    __isset.fieldC = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<103, _T> arg) {
    req_fieldC = arg.extract();
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<203, _T> arg) {
    opt_fieldC = arg.extract();
    __isset.opt_fieldC = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<4, _T> arg) {
    fieldD = arg.extract();
    __isset.fieldD = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<5, _T> arg) {
    fieldE = arg.extract();
    __isset.fieldE = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<105, _T> arg) {
    req_fieldE = arg.extract();
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<205, _T> arg) {
    opt_fieldE = arg.extract();
    __isset.opt_fieldE = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<6, _T> arg) {
    fieldF = arg.extract();
    __isset.fieldF = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<7, _T> arg) {
    fieldG = arg.extract();
    __isset.fieldG = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<8, _T> arg) {
    fieldH = arg.extract();
    __isset.fieldH = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<9, _T> arg) {
    fieldI = arg.extract();
    __isset.fieldI = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<10, _T> arg) {
    fieldJ = arg.extract();
    __isset.fieldJ = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<11, _T> arg) {
    fieldK = arg.extract();
    __isset.fieldK = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<12, _T> arg) {
    fieldL = arg.extract();
    __isset.fieldL = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<13, _T> arg) {
    fieldM = arg.extract();
    __isset.fieldM = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<14, _T> arg) {
    fieldN = arg.extract();
    __isset.fieldN = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<15, _T> arg) {
    fieldO = arg.extract();
    __isset.fieldO = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<16, _T> arg) {
    fieldP = arg.extract();
    __isset.fieldP = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<17, _T> arg) {
    fieldQ = arg.extract();
    __isset.fieldQ = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<18, _T> arg) {
    fieldR = arg.extract();
    __isset.fieldR = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<118, _T> arg) {
    req_fieldR = arg.extract();
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<218, _T> arg) {
    opt_fieldR = arg.extract();
    __isset.opt_fieldR = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<19, _T> arg) {
    fieldS = arg.extract();
    __isset.fieldS = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<21, _T> arg) {
    fieldT = arg.extract();
    __isset.fieldT = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<22, _T> arg) {
    fieldU = arg.extract();
    __isset.fieldU = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<23, _T> arg) {
    fieldV = arg.extract();
    __isset.fieldV = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<123, _T> arg) {
    req_fieldV = arg.extract();
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<223, _T> arg) {
    opt_fieldV = arg.extract();
    __isset.opt_fieldV = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<24, _T> arg) {
    fieldW = arg.extract();
    __isset.fieldW = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<25, _T> arg) {
    fieldX = arg.extract();
    __isset.fieldX = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<125, _T> arg) {
    req_fieldX = arg.extract();
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<225, _T> arg) {
    opt_fieldX = arg.extract();
    __isset.opt_fieldX = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<26, _T> arg) {
    fieldY = arg.extract();
    __isset.fieldY = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<27, _T> arg) {
    fieldZ = arg.extract();
    __isset.fieldZ = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<28, _T> arg) {
    fieldAA = arg.extract();
    __isset.fieldAA = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<29, _T> arg) {
    fieldAB = arg.extract();
    __isset.fieldAB = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<30, _T> arg) {
    fieldAC = arg.extract();
    __isset.fieldAC = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<31, _T> arg) {
    fieldAD = arg.extract();
    __isset.fieldAD = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<32, _T> arg) {
    fieldAE = arg.extract();
    __isset.fieldAE = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<33, _T> arg) {
    fieldSD = arg.extract();
    __isset.fieldSD = true;
  }

  containerStruct(containerStruct&&) = default;

  containerStruct& operator=(containerStruct&&) = default;
  void __clear();

  ~containerStruct();

  bool fieldA;
  bool req_fieldA;
  bool opt_fieldA;
  std::map<std::string, bool> fieldB;
  std::map<std::string, bool> req_fieldB;
  std::map<std::string, bool> opt_fieldB;
  std::set<int32_t> fieldC;
  std::set<int32_t> req_fieldC;
  std::set<int32_t> opt_fieldC;
  std::string fieldD;
  std::string fieldE;
  std::string req_fieldE;
  std::string opt_fieldE;
  std::vector<std::vector<int32_t>> fieldF;
  std::map<std::string, std::map<std::string, std::map<std::string, int32_t>>> fieldG;
  std::vector<std::set<int32_t>> fieldH;
  bool fieldI;
  std::map<std::string, std::vector<int32_t>> fieldJ;
  std::vector<std::vector<std::vector<std::vector<int32_t>>>> fieldK;
  std::set<std::set<std::set<bool>>> fieldL;
  std::map<std::set<std::vector<int32_t>>, std::map<std::vector<std::set<std::string>>, std::string>> fieldM;
   ::some::valid::ns::simpleTypeDef fieldN;
   ::some::valid::ns::complexStructTypeDef fieldO;
  std::vector< ::some::valid::ns::mostComplexTypeDef> fieldP;
   ::some::valid::ns::MyEnumA fieldQ;
   ::some::valid::ns::MyEnumA fieldR;
   ::some::valid::ns::MyEnumA req_fieldR;
   ::some::valid::ns::MyEnumA opt_fieldR;
   ::some::valid::ns::MyEnumA fieldS;
  std::vector< ::some::valid::ns::MyEnumA> fieldT;
  std::vector< ::some::valid::ns::MyEnumA> fieldU;
   ::some::valid::ns::MyStruct fieldV;
   ::some::valid::ns::MyStruct req_fieldV;
   ::some::valid::ns::MyStruct opt_fieldV;
  std::set< ::some::valid::ns::MyStruct> fieldW;
   ::some::valid::ns::ComplexUnion fieldX;
   ::some::valid::ns::ComplexUnion req_fieldX;
   ::some::valid::ns::ComplexUnion opt_fieldX;
  std::vector< ::some::valid::ns::ComplexUnion> fieldY;
   ::some::valid::ns::unionTypeDef fieldZ;
  std::vector< ::some::valid::ns::unionTypeDef> fieldAA;
  std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC> fieldAB;
   ::some::valid::ns::MyEnumB fieldAC;
   ::a::different::ns::AnEnum fieldAD;
  std::map<std::string, int32_t> fieldAE;
   ::some::valid::ns::IndirectionD fieldSD;

  struct __isset {
    bool fieldA;
    bool opt_fieldA;
    bool fieldB;
    bool opt_fieldB;
    bool fieldC;
    bool opt_fieldC;
    bool fieldD;
    bool fieldE;
    bool opt_fieldE;
    bool fieldF;
    bool fieldG;
    bool fieldH;
    bool fieldI;
    bool fieldJ;
    bool fieldK;
    bool fieldL;
    bool fieldM;
    bool fieldN;
    bool fieldO;
    bool fieldP;
    bool fieldQ;
    bool fieldR;
    bool opt_fieldR;
    bool fieldS;
    bool fieldT;
    bool fieldU;
    bool fieldV;
    bool opt_fieldV;
    bool fieldW;
    bool fieldX;
    bool opt_fieldX;
    bool fieldY;
    bool fieldZ;
    bool fieldAA;
    bool fieldAB;
    bool fieldAC;
    bool fieldAD;
    bool fieldAE;
    bool fieldSD;
  } __isset = {};
  bool operator==(const containerStruct& rhs) const;
  bool operator<(const containerStruct& rhs) const;

  bool get_fieldA() const {
    return fieldA;
  }

  bool& set_fieldA(bool fieldA_) {
    fieldA = fieldA_;
    __isset.fieldA = true;
    return fieldA;
  }

  bool get_req_fieldA() const {
    return req_fieldA;
  }

  bool& set_req_fieldA(bool req_fieldA_) {
    req_fieldA = req_fieldA_;
    return req_fieldA;
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<const bool&> opt_fieldA_ref() const& {
    return {opt_fieldA, __isset.opt_fieldA};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<const bool&&> opt_fieldA_ref() const&& {
    return {std::move(opt_fieldA), __isset.opt_fieldA};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<bool&> opt_fieldA_ref() & {
    return {opt_fieldA, __isset.opt_fieldA};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<bool&&> opt_fieldA_ref() && {
    return {std::move(opt_fieldA), __isset.opt_fieldA};
  }

  const bool* get_opt_fieldA() const& {
    return __isset.opt_fieldA ? std::addressof(opt_fieldA) : nullptr;
  }

  bool* get_opt_fieldA() & {
    return __isset.opt_fieldA ? std::addressof(opt_fieldA) : nullptr;
  }
  bool* get_opt_fieldA() && = delete;

  bool& set_opt_fieldA(bool opt_fieldA_) {
    opt_fieldA = opt_fieldA_;
    __isset.opt_fieldA = true;
    return opt_fieldA;
  }
  const std::map<std::string, bool>& get_fieldB() const&;
  std::map<std::string, bool> get_fieldB() &&;

  template <typename T_containerStruct_fieldB_struct_setter = std::map<std::string, bool>>
  std::map<std::string, bool>& set_fieldB(T_containerStruct_fieldB_struct_setter&& fieldB_) {
    fieldB = std::forward<T_containerStruct_fieldB_struct_setter>(fieldB_);
    __isset.fieldB = true;
    return fieldB;
  }
  const std::map<std::string, bool>& get_req_fieldB() const&;
  std::map<std::string, bool> get_req_fieldB() &&;

  template <typename T_containerStruct_req_fieldB_struct_setter = std::map<std::string, bool>>
  std::map<std::string, bool>& set_req_fieldB(T_containerStruct_req_fieldB_struct_setter&& req_fieldB_) {
    req_fieldB = std::forward<T_containerStruct_req_fieldB_struct_setter>(req_fieldB_);
    return req_fieldB;
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<const std::map<std::string, bool>&> opt_fieldB_ref() const& {
    return {opt_fieldB, __isset.opt_fieldB};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<const std::map<std::string, bool>&&> opt_fieldB_ref() const&& {
    return {std::move(opt_fieldB), __isset.opt_fieldB};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<std::map<std::string, bool>&> opt_fieldB_ref() & {
    return {opt_fieldB, __isset.opt_fieldB};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<std::map<std::string, bool>&&> opt_fieldB_ref() && {
    return {std::move(opt_fieldB), __isset.opt_fieldB};
  }
  const std::map<std::string, bool>* get_opt_fieldB() const&;
  std::map<std::string, bool>* get_opt_fieldB() &;
  std::map<std::string, bool>* get_opt_fieldB() && = delete;

  template <typename T_containerStruct_opt_fieldB_struct_setter = std::map<std::string, bool>>
  std::map<std::string, bool>& set_opt_fieldB(T_containerStruct_opt_fieldB_struct_setter&& opt_fieldB_) {
    opt_fieldB = std::forward<T_containerStruct_opt_fieldB_struct_setter>(opt_fieldB_);
    __isset.opt_fieldB = true;
    return opt_fieldB;
  }
  const std::set<int32_t>& get_fieldC() const&;
  std::set<int32_t> get_fieldC() &&;

  template <typename T_containerStruct_fieldC_struct_setter = std::set<int32_t>>
  std::set<int32_t>& set_fieldC(T_containerStruct_fieldC_struct_setter&& fieldC_) {
    fieldC = std::forward<T_containerStruct_fieldC_struct_setter>(fieldC_);
    __isset.fieldC = true;
    return fieldC;
  }
  const std::set<int32_t>& get_req_fieldC() const&;
  std::set<int32_t> get_req_fieldC() &&;

  template <typename T_containerStruct_req_fieldC_struct_setter = std::set<int32_t>>
  std::set<int32_t>& set_req_fieldC(T_containerStruct_req_fieldC_struct_setter&& req_fieldC_) {
    req_fieldC = std::forward<T_containerStruct_req_fieldC_struct_setter>(req_fieldC_);
    return req_fieldC;
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<const std::set<int32_t>&> opt_fieldC_ref() const& {
    return {opt_fieldC, __isset.opt_fieldC};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<const std::set<int32_t>&&> opt_fieldC_ref() const&& {
    return {std::move(opt_fieldC), __isset.opt_fieldC};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<std::set<int32_t>&> opt_fieldC_ref() & {
    return {opt_fieldC, __isset.opt_fieldC};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<std::set<int32_t>&&> opt_fieldC_ref() && {
    return {std::move(opt_fieldC), __isset.opt_fieldC};
  }
  const std::set<int32_t>* get_opt_fieldC() const&;
  std::set<int32_t>* get_opt_fieldC() &;
  std::set<int32_t>* get_opt_fieldC() && = delete;

  template <typename T_containerStruct_opt_fieldC_struct_setter = std::set<int32_t>>
  std::set<int32_t>& set_opt_fieldC(T_containerStruct_opt_fieldC_struct_setter&& opt_fieldC_) {
    opt_fieldC = std::forward<T_containerStruct_opt_fieldC_struct_setter>(opt_fieldC_);
    __isset.opt_fieldC = true;
    return opt_fieldC;
  }

  const std::string& get_fieldD() const& {
    return fieldD;
  }

  std::string get_fieldD() && {
    return std::move(fieldD);
  }

  template <typename T_containerStruct_fieldD_struct_setter = std::string>
  std::string& set_fieldD(T_containerStruct_fieldD_struct_setter&& fieldD_) {
    fieldD = std::forward<T_containerStruct_fieldD_struct_setter>(fieldD_);
    __isset.fieldD = true;
    return fieldD;
  }

  const std::string& get_fieldE() const& {
    return fieldE;
  }

  std::string get_fieldE() && {
    return std::move(fieldE);
  }

  template <typename T_containerStruct_fieldE_struct_setter = std::string>
  std::string& set_fieldE(T_containerStruct_fieldE_struct_setter&& fieldE_) {
    fieldE = std::forward<T_containerStruct_fieldE_struct_setter>(fieldE_);
    __isset.fieldE = true;
    return fieldE;
  }

  const std::string& get_req_fieldE() const& {
    return req_fieldE;
  }

  std::string get_req_fieldE() && {
    return std::move(req_fieldE);
  }

  template <typename T_containerStruct_req_fieldE_struct_setter = std::string>
  std::string& set_req_fieldE(T_containerStruct_req_fieldE_struct_setter&& req_fieldE_) {
    req_fieldE = std::forward<T_containerStruct_req_fieldE_struct_setter>(req_fieldE_);
    return req_fieldE;
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<const std::string&> opt_fieldE_ref() const& {
    return {opt_fieldE, __isset.opt_fieldE};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<const std::string&&> opt_fieldE_ref() const&& {
    return {std::move(opt_fieldE), __isset.opt_fieldE};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<std::string&> opt_fieldE_ref() & {
    return {opt_fieldE, __isset.opt_fieldE};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<std::string&&> opt_fieldE_ref() && {
    return {std::move(opt_fieldE), __isset.opt_fieldE};
  }

  const std::string* get_opt_fieldE() const& {
    return __isset.opt_fieldE ? std::addressof(opt_fieldE) : nullptr;
  }

  std::string* get_opt_fieldE() & {
    return __isset.opt_fieldE ? std::addressof(opt_fieldE) : nullptr;
  }
  std::string* get_opt_fieldE() && = delete;

  template <typename T_containerStruct_opt_fieldE_struct_setter = std::string>
  std::string& set_opt_fieldE(T_containerStruct_opt_fieldE_struct_setter&& opt_fieldE_) {
    opt_fieldE = std::forward<T_containerStruct_opt_fieldE_struct_setter>(opt_fieldE_);
    __isset.opt_fieldE = true;
    return opt_fieldE;
  }
  const std::vector<std::vector<int32_t>>& get_fieldF() const&;
  std::vector<std::vector<int32_t>> get_fieldF() &&;

  template <typename T_containerStruct_fieldF_struct_setter = std::vector<std::vector<int32_t>>>
  std::vector<std::vector<int32_t>>& set_fieldF(T_containerStruct_fieldF_struct_setter&& fieldF_) {
    fieldF = std::forward<T_containerStruct_fieldF_struct_setter>(fieldF_);
    __isset.fieldF = true;
    return fieldF;
  }
  const std::map<std::string, std::map<std::string, std::map<std::string, int32_t>>>& get_fieldG() const&;
  std::map<std::string, std::map<std::string, std::map<std::string, int32_t>>> get_fieldG() &&;

  template <typename T_containerStruct_fieldG_struct_setter = std::map<std::string, std::map<std::string, std::map<std::string, int32_t>>>>
  std::map<std::string, std::map<std::string, std::map<std::string, int32_t>>>& set_fieldG(T_containerStruct_fieldG_struct_setter&& fieldG_) {
    fieldG = std::forward<T_containerStruct_fieldG_struct_setter>(fieldG_);
    __isset.fieldG = true;
    return fieldG;
  }
  const std::vector<std::set<int32_t>>& get_fieldH() const&;
  std::vector<std::set<int32_t>> get_fieldH() &&;

  template <typename T_containerStruct_fieldH_struct_setter = std::vector<std::set<int32_t>>>
  std::vector<std::set<int32_t>>& set_fieldH(T_containerStruct_fieldH_struct_setter&& fieldH_) {
    fieldH = std::forward<T_containerStruct_fieldH_struct_setter>(fieldH_);
    __isset.fieldH = true;
    return fieldH;
  }

  bool get_fieldI() const {
    return fieldI;
  }

  bool& set_fieldI(bool fieldI_) {
    fieldI = fieldI_;
    __isset.fieldI = true;
    return fieldI;
  }
  const std::map<std::string, std::vector<int32_t>>& get_fieldJ() const&;
  std::map<std::string, std::vector<int32_t>> get_fieldJ() &&;

  template <typename T_containerStruct_fieldJ_struct_setter = std::map<std::string, std::vector<int32_t>>>
  std::map<std::string, std::vector<int32_t>>& set_fieldJ(T_containerStruct_fieldJ_struct_setter&& fieldJ_) {
    fieldJ = std::forward<T_containerStruct_fieldJ_struct_setter>(fieldJ_);
    __isset.fieldJ = true;
    return fieldJ;
  }
  const std::vector<std::vector<std::vector<std::vector<int32_t>>>>& get_fieldK() const&;
  std::vector<std::vector<std::vector<std::vector<int32_t>>>> get_fieldK() &&;

  template <typename T_containerStruct_fieldK_struct_setter = std::vector<std::vector<std::vector<std::vector<int32_t>>>>>
  std::vector<std::vector<std::vector<std::vector<int32_t>>>>& set_fieldK(T_containerStruct_fieldK_struct_setter&& fieldK_) {
    fieldK = std::forward<T_containerStruct_fieldK_struct_setter>(fieldK_);
    __isset.fieldK = true;
    return fieldK;
  }
  const std::set<std::set<std::set<bool>>>& get_fieldL() const&;
  std::set<std::set<std::set<bool>>> get_fieldL() &&;

  template <typename T_containerStruct_fieldL_struct_setter = std::set<std::set<std::set<bool>>>>
  std::set<std::set<std::set<bool>>>& set_fieldL(T_containerStruct_fieldL_struct_setter&& fieldL_) {
    fieldL = std::forward<T_containerStruct_fieldL_struct_setter>(fieldL_);
    __isset.fieldL = true;
    return fieldL;
  }
  const std::map<std::set<std::vector<int32_t>>, std::map<std::vector<std::set<std::string>>, std::string>>& get_fieldM() const&;
  std::map<std::set<std::vector<int32_t>>, std::map<std::vector<std::set<std::string>>, std::string>> get_fieldM() &&;

  template <typename T_containerStruct_fieldM_struct_setter = std::map<std::set<std::vector<int32_t>>, std::map<std::vector<std::set<std::string>>, std::string>>>
  std::map<std::set<std::vector<int32_t>>, std::map<std::vector<std::set<std::string>>, std::string>>& set_fieldM(T_containerStruct_fieldM_struct_setter&& fieldM_) {
    fieldM = std::forward<T_containerStruct_fieldM_struct_setter>(fieldM_);
    __isset.fieldM = true;
    return fieldM;
  }

   ::some::valid::ns::simpleTypeDef get_fieldN() const {
    return fieldN;
  }

   ::some::valid::ns::simpleTypeDef& set_fieldN( ::some::valid::ns::simpleTypeDef fieldN_) {
    fieldN = fieldN_;
    __isset.fieldN = true;
    return fieldN;
  }
  const  ::some::valid::ns::complexStructTypeDef& get_fieldO() const&;
   ::some::valid::ns::complexStructTypeDef get_fieldO() &&;

  template <typename T_containerStruct_fieldO_struct_setter =  ::some::valid::ns::complexStructTypeDef>
   ::some::valid::ns::complexStructTypeDef& set_fieldO(T_containerStruct_fieldO_struct_setter&& fieldO_) {
    fieldO = std::forward<T_containerStruct_fieldO_struct_setter>(fieldO_);
    __isset.fieldO = true;
    return fieldO;
  }
  const std::vector< ::some::valid::ns::mostComplexTypeDef>& get_fieldP() const&;
  std::vector< ::some::valid::ns::mostComplexTypeDef> get_fieldP() &&;

  template <typename T_containerStruct_fieldP_struct_setter = std::vector< ::some::valid::ns::mostComplexTypeDef>>
  std::vector< ::some::valid::ns::mostComplexTypeDef>& set_fieldP(T_containerStruct_fieldP_struct_setter&& fieldP_) {
    fieldP = std::forward<T_containerStruct_fieldP_struct_setter>(fieldP_);
    __isset.fieldP = true;
    return fieldP;
  }

   ::some::valid::ns::MyEnumA get_fieldQ() const {
    return fieldQ;
  }

   ::some::valid::ns::MyEnumA& set_fieldQ( ::some::valid::ns::MyEnumA fieldQ_) {
    fieldQ = fieldQ_;
    __isset.fieldQ = true;
    return fieldQ;
  }

   ::some::valid::ns::MyEnumA get_fieldR() const {
    return fieldR;
  }

   ::some::valid::ns::MyEnumA& set_fieldR( ::some::valid::ns::MyEnumA fieldR_) {
    fieldR = fieldR_;
    __isset.fieldR = true;
    return fieldR;
  }

   ::some::valid::ns::MyEnumA get_req_fieldR() const {
    return req_fieldR;
  }

   ::some::valid::ns::MyEnumA& set_req_fieldR( ::some::valid::ns::MyEnumA req_fieldR_) {
    req_fieldR = req_fieldR_;
    return req_fieldR;
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<const  ::some::valid::ns::MyEnumA&> opt_fieldR_ref() const& {
    return {opt_fieldR, __isset.opt_fieldR};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<const  ::some::valid::ns::MyEnumA&&> opt_fieldR_ref() const&& {
    return {std::move(opt_fieldR), __isset.opt_fieldR};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref< ::some::valid::ns::MyEnumA&> opt_fieldR_ref() & {
    return {opt_fieldR, __isset.opt_fieldR};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref< ::some::valid::ns::MyEnumA&&> opt_fieldR_ref() && {
    return {std::move(opt_fieldR), __isset.opt_fieldR};
  }

  const  ::some::valid::ns::MyEnumA* get_opt_fieldR() const& {
    return __isset.opt_fieldR ? std::addressof(opt_fieldR) : nullptr;
  }

   ::some::valid::ns::MyEnumA* get_opt_fieldR() & {
    return __isset.opt_fieldR ? std::addressof(opt_fieldR) : nullptr;
  }
   ::some::valid::ns::MyEnumA* get_opt_fieldR() && = delete;

   ::some::valid::ns::MyEnumA& set_opt_fieldR( ::some::valid::ns::MyEnumA opt_fieldR_) {
    opt_fieldR = opt_fieldR_;
    __isset.opt_fieldR = true;
    return opt_fieldR;
  }

   ::some::valid::ns::MyEnumA get_fieldS() const {
    return fieldS;
  }

   ::some::valid::ns::MyEnumA& set_fieldS( ::some::valid::ns::MyEnumA fieldS_) {
    fieldS = fieldS_;
    __isset.fieldS = true;
    return fieldS;
  }
  const std::vector< ::some::valid::ns::MyEnumA>& get_fieldT() const&;
  std::vector< ::some::valid::ns::MyEnumA> get_fieldT() &&;

  template <typename T_containerStruct_fieldT_struct_setter = std::vector< ::some::valid::ns::MyEnumA>>
  std::vector< ::some::valid::ns::MyEnumA>& set_fieldT(T_containerStruct_fieldT_struct_setter&& fieldT_) {
    fieldT = std::forward<T_containerStruct_fieldT_struct_setter>(fieldT_);
    __isset.fieldT = true;
    return fieldT;
  }
  const std::vector< ::some::valid::ns::MyEnumA>& get_fieldU() const&;
  std::vector< ::some::valid::ns::MyEnumA> get_fieldU() &&;

  template <typename T_containerStruct_fieldU_struct_setter = std::vector< ::some::valid::ns::MyEnumA>>
  std::vector< ::some::valid::ns::MyEnumA>& set_fieldU(T_containerStruct_fieldU_struct_setter&& fieldU_) {
    fieldU = std::forward<T_containerStruct_fieldU_struct_setter>(fieldU_);
    __isset.fieldU = true;
    return fieldU;
  }
  const  ::some::valid::ns::MyStruct& get_fieldV() const&;
   ::some::valid::ns::MyStruct get_fieldV() &&;

  template <typename T_containerStruct_fieldV_struct_setter =  ::some::valid::ns::MyStruct>
   ::some::valid::ns::MyStruct& set_fieldV(T_containerStruct_fieldV_struct_setter&& fieldV_) {
    fieldV = std::forward<T_containerStruct_fieldV_struct_setter>(fieldV_);
    __isset.fieldV = true;
    return fieldV;
  }
  const  ::some::valid::ns::MyStruct& get_req_fieldV() const&;
   ::some::valid::ns::MyStruct get_req_fieldV() &&;

  template <typename T_containerStruct_req_fieldV_struct_setter =  ::some::valid::ns::MyStruct>
   ::some::valid::ns::MyStruct& set_req_fieldV(T_containerStruct_req_fieldV_struct_setter&& req_fieldV_) {
    req_fieldV = std::forward<T_containerStruct_req_fieldV_struct_setter>(req_fieldV_);
    return req_fieldV;
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<const  ::some::valid::ns::MyStruct&> opt_fieldV_ref() const& {
    return {opt_fieldV, __isset.opt_fieldV};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<const  ::some::valid::ns::MyStruct&&> opt_fieldV_ref() const&& {
    return {std::move(opt_fieldV), __isset.opt_fieldV};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref< ::some::valid::ns::MyStruct&> opt_fieldV_ref() & {
    return {opt_fieldV, __isset.opt_fieldV};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref< ::some::valid::ns::MyStruct&&> opt_fieldV_ref() && {
    return {std::move(opt_fieldV), __isset.opt_fieldV};
  }
  const  ::some::valid::ns::MyStruct* get_opt_fieldV() const&;
   ::some::valid::ns::MyStruct* get_opt_fieldV() &;
   ::some::valid::ns::MyStruct* get_opt_fieldV() && = delete;

  template <typename T_containerStruct_opt_fieldV_struct_setter =  ::some::valid::ns::MyStruct>
   ::some::valid::ns::MyStruct& set_opt_fieldV(T_containerStruct_opt_fieldV_struct_setter&& opt_fieldV_) {
    opt_fieldV = std::forward<T_containerStruct_opt_fieldV_struct_setter>(opt_fieldV_);
    __isset.opt_fieldV = true;
    return opt_fieldV;
  }
  const std::set< ::some::valid::ns::MyStruct>& get_fieldW() const&;
  std::set< ::some::valid::ns::MyStruct> get_fieldW() &&;

  template <typename T_containerStruct_fieldW_struct_setter = std::set< ::some::valid::ns::MyStruct>>
  std::set< ::some::valid::ns::MyStruct>& set_fieldW(T_containerStruct_fieldW_struct_setter&& fieldW_) {
    fieldW = std::forward<T_containerStruct_fieldW_struct_setter>(fieldW_);
    __isset.fieldW = true;
    return fieldW;
  }
  const  ::some::valid::ns::ComplexUnion& get_fieldX() const&;
   ::some::valid::ns::ComplexUnion get_fieldX() &&;

  template <typename T_containerStruct_fieldX_struct_setter =  ::some::valid::ns::ComplexUnion>
   ::some::valid::ns::ComplexUnion& set_fieldX(T_containerStruct_fieldX_struct_setter&& fieldX_) {
    fieldX = std::forward<T_containerStruct_fieldX_struct_setter>(fieldX_);
    __isset.fieldX = true;
    return fieldX;
  }
  const  ::some::valid::ns::ComplexUnion& get_req_fieldX() const&;
   ::some::valid::ns::ComplexUnion get_req_fieldX() &&;

  template <typename T_containerStruct_req_fieldX_struct_setter =  ::some::valid::ns::ComplexUnion>
   ::some::valid::ns::ComplexUnion& set_req_fieldX(T_containerStruct_req_fieldX_struct_setter&& req_fieldX_) {
    req_fieldX = std::forward<T_containerStruct_req_fieldX_struct_setter>(req_fieldX_);
    return req_fieldX;
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<const  ::some::valid::ns::ComplexUnion&> opt_fieldX_ref() const& {
    return {opt_fieldX, __isset.opt_fieldX};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref<const  ::some::valid::ns::ComplexUnion&&> opt_fieldX_ref() const&& {
    return {std::move(opt_fieldX), __isset.opt_fieldX};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref< ::some::valid::ns::ComplexUnion&> opt_fieldX_ref() & {
    return {opt_fieldX, __isset.opt_fieldX};
  }

  THRIFT_NOLINK ::apache::thrift::optional_field_ref< ::some::valid::ns::ComplexUnion&&> opt_fieldX_ref() && {
    return {std::move(opt_fieldX), __isset.opt_fieldX};
  }
  const  ::some::valid::ns::ComplexUnion* get_opt_fieldX() const&;
   ::some::valid::ns::ComplexUnion* get_opt_fieldX() &;
   ::some::valid::ns::ComplexUnion* get_opt_fieldX() && = delete;

  template <typename T_containerStruct_opt_fieldX_struct_setter =  ::some::valid::ns::ComplexUnion>
   ::some::valid::ns::ComplexUnion& set_opt_fieldX(T_containerStruct_opt_fieldX_struct_setter&& opt_fieldX_) {
    opt_fieldX = std::forward<T_containerStruct_opt_fieldX_struct_setter>(opt_fieldX_);
    __isset.opt_fieldX = true;
    return opt_fieldX;
  }
  const std::vector< ::some::valid::ns::ComplexUnion>& get_fieldY() const&;
  std::vector< ::some::valid::ns::ComplexUnion> get_fieldY() &&;

  template <typename T_containerStruct_fieldY_struct_setter = std::vector< ::some::valid::ns::ComplexUnion>>
  std::vector< ::some::valid::ns::ComplexUnion>& set_fieldY(T_containerStruct_fieldY_struct_setter&& fieldY_) {
    fieldY = std::forward<T_containerStruct_fieldY_struct_setter>(fieldY_);
    __isset.fieldY = true;
    return fieldY;
  }
  const  ::some::valid::ns::unionTypeDef& get_fieldZ() const&;
   ::some::valid::ns::unionTypeDef get_fieldZ() &&;

  template <typename T_containerStruct_fieldZ_struct_setter =  ::some::valid::ns::unionTypeDef>
   ::some::valid::ns::unionTypeDef& set_fieldZ(T_containerStruct_fieldZ_struct_setter&& fieldZ_) {
    fieldZ = std::forward<T_containerStruct_fieldZ_struct_setter>(fieldZ_);
    __isset.fieldZ = true;
    return fieldZ;
  }
  const std::vector< ::some::valid::ns::unionTypeDef>& get_fieldAA() const&;
  std::vector< ::some::valid::ns::unionTypeDef> get_fieldAA() &&;

  template <typename T_containerStruct_fieldAA_struct_setter = std::vector< ::some::valid::ns::unionTypeDef>>
  std::vector< ::some::valid::ns::unionTypeDef>& set_fieldAA(T_containerStruct_fieldAA_struct_setter&& fieldAA_) {
    fieldAA = std::forward<T_containerStruct_fieldAA_struct_setter>(fieldAA_);
    __isset.fieldAA = true;
    return fieldAA;
  }
  const std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC>& get_fieldAB() const&;
  std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC> get_fieldAB() &&;

  template <typename T_containerStruct_fieldAB_struct_setter = std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC>>
  std::map< ::some::valid::ns::IndirectionB,  ::some::valid::ns::IndirectionC>& set_fieldAB(T_containerStruct_fieldAB_struct_setter&& fieldAB_) {
    fieldAB = std::forward<T_containerStruct_fieldAB_struct_setter>(fieldAB_);
    __isset.fieldAB = true;
    return fieldAB;
  }

   ::some::valid::ns::MyEnumB get_fieldAC() const {
    return fieldAC;
  }

   ::some::valid::ns::MyEnumB& set_fieldAC( ::some::valid::ns::MyEnumB fieldAC_) {
    fieldAC = fieldAC_;
    __isset.fieldAC = true;
    return fieldAC;
  }

   ::a::different::ns::AnEnum get_fieldAD() const {
    return fieldAD;
  }

   ::a::different::ns::AnEnum& set_fieldAD( ::a::different::ns::AnEnum fieldAD_) {
    fieldAD = fieldAD_;
    __isset.fieldAD = true;
    return fieldAD;
  }
  const std::map<std::string, int32_t>& get_fieldAE() const&;
  std::map<std::string, int32_t> get_fieldAE() &&;

  template <typename T_containerStruct_fieldAE_struct_setter = std::map<std::string, int32_t>>
  std::map<std::string, int32_t>& set_fieldAE(T_containerStruct_fieldAE_struct_setter&& fieldAE_) {
    fieldAE = std::forward<T_containerStruct_fieldAE_struct_setter>(fieldAE_);
    __isset.fieldAE = true;
    return fieldAE;
  }

  const  ::some::valid::ns::IndirectionD& get_fieldSD() const& {
    return fieldSD;
  }

   ::some::valid::ns::IndirectionD get_fieldSD() && {
    return std::move(fieldSD);
  }

  template <typename T_containerStruct_fieldSD_struct_setter =  ::some::valid::ns::IndirectionD>
   ::some::valid::ns::IndirectionD& set_fieldSD(T_containerStruct_fieldSD_struct_setter&& fieldSD_) {
    fieldSD = std::forward<T_containerStruct_fieldSD_struct_setter>(fieldSD_);
    __isset.fieldSD = true;
    return fieldSD;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
  // user defined code (cpp2.methods = ...)
  void foo(const std::string& bar) {}

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< containerStruct >;
};

void swap(containerStruct& a, containerStruct& b);

template <class Protocol_>
uint32_t containerStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class MyIncludedStruct final : private apache::thrift::detail::st::ComparisonOperators<MyIncludedStruct> {
 public:

  MyIncludedStruct() :
      MyIncludedInt(42LL),
      ARefField(std::make_unique< ::some::valid::ns::AStruct>()) {}
  // FragileConstructor for use in initialization lists only.
  MyIncludedStruct(apache::thrift::FragileConstructor,  ::a::different::ns::IncludedInt64 MyIncludedInt__arg,  ::some::valid::ns::AStruct MyIncludedStruct__arg, std::unique_ptr< ::some::valid::ns::AStruct> ARefField__arg,  ::some::valid::ns::AStruct ARequiredField__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    MyIncludedInt = arg.extract();
    __isset.MyIncludedInt = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    MyIncludedStruct = arg.extract();
    __isset.MyIncludedStruct = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<3, _T> arg) {
    ARefField = std::make_unique<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<4, _T> arg) {
    ARequiredField = arg.extract();
  }

  MyIncludedStruct(MyIncludedStruct&&) = default;
  MyIncludedStruct(const MyIncludedStruct& src);

  MyIncludedStruct& operator=(MyIncludedStruct&&) = default;
  MyIncludedStruct& operator=(const MyIncludedStruct& src);
  void __clear();
   ::a::different::ns::IncludedInt64 MyIncludedInt;
   ::some::valid::ns::AStruct MyIncludedStruct;
  std::unique_ptr< ::some::valid::ns::AStruct> ARefField;
   ::some::valid::ns::AStruct ARequiredField;

  struct __isset {
    bool MyIncludedInt;
    bool MyIncludedStruct;
  } __isset = {};
  bool operator==(const MyIncludedStruct& rhs) const;
  bool operator<(const MyIncludedStruct& rhs) const;

   ::a::different::ns::IncludedInt64 get_MyIncludedInt() const {
    return MyIncludedInt;
  }

   ::a::different::ns::IncludedInt64& set_MyIncludedInt( ::a::different::ns::IncludedInt64 MyIncludedInt_) {
    MyIncludedInt = MyIncludedInt_;
    __isset.MyIncludedInt = true;
    return MyIncludedInt;
  }
  const  ::some::valid::ns::AStruct& get_MyIncludedStruct() const&;
   ::some::valid::ns::AStruct get_MyIncludedStruct() &&;

  template <typename T_MyIncludedStruct_MyIncludedStruct_struct_setter =  ::some::valid::ns::AStruct>
   ::some::valid::ns::AStruct& set_MyIncludedStruct(T_MyIncludedStruct_MyIncludedStruct_struct_setter&& MyIncludedStruct_) {
    MyIncludedStruct = std::forward<T_MyIncludedStruct_MyIncludedStruct_struct_setter>(MyIncludedStruct_);
    __isset.MyIncludedStruct = true;
    return MyIncludedStruct;
  }
  const  ::some::valid::ns::AStruct& get_ARequiredField() const&;
   ::some::valid::ns::AStruct get_ARequiredField() &&;

  template <typename T_MyIncludedStruct_ARequiredField_struct_setter =  ::some::valid::ns::AStruct>
   ::some::valid::ns::AStruct& set_ARequiredField(T_MyIncludedStruct_ARequiredField_struct_setter&& ARequiredField_) {
    ARequiredField = std::forward<T_MyIncludedStruct_ARequiredField_struct_setter>(ARequiredField_);
    return ARequiredField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< MyIncludedStruct >;
};

void swap(MyIncludedStruct& a, MyIncludedStruct& b);

template <class Protocol_>
uint32_t MyIncludedStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class AnnotatedStruct : private apache::thrift::detail::st::ComparisonOperators<AnnotatedStruct> {
 public:

  AnnotatedStruct();

  // FragileConstructor for use in initialization lists only.
  AnnotatedStruct(apache::thrift::FragileConstructor,  ::some::valid::ns::containerStruct no_annotation__arg, std::unique_ptr< ::some::valid::ns::containerStruct> cpp_unique_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> cpp2_unique_ref__arg, std::unique_ptr<std::map<int32_t, std::vector<std::string>>> container_with_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> req_cpp_unique_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> req_cpp2_unique_ref__arg, std::unique_ptr<std::vector<std::string>> req_container_with_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> opt_cpp_unique_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> opt_cpp2_unique_ref__arg, std::unique_ptr<std::set<int32_t>> opt_container_with_ref__arg, std::unique_ptr< ::some::valid::ns::containerStruct> ref_type_unique__arg, std::shared_ptr< ::some::valid::ns::containerStruct> ref_type_shared__arg, std::shared_ptr<const std::map<int32_t, std::vector<std::string>>> ref_type_const__arg, std::shared_ptr< ::some::valid::ns::containerStruct> req_ref_type_shared__arg, std::shared_ptr<const  ::some::valid::ns::containerStruct> req_ref_type_const__arg, std::unique_ptr<std::vector<std::string>> req_ref_type_unique__arg, std::shared_ptr<const  ::some::valid::ns::containerStruct> opt_ref_type_const__arg, std::unique_ptr< ::some::valid::ns::containerStruct> opt_ref_type_unique__arg, std::shared_ptr<std::set<int32_t>> opt_ref_type_shared__arg,  ::some::valid::ns::CppFakeI32 base_type__arg,  ::some::valid::ns::FollySmallVectorI64 list_type__arg,  ::some::valid::ns::SortedVectorSetString set_type__arg,  ::some::valid::ns::FakeMap map_type__arg,  ::some::valid::ns::UnorderedMapStruct map_struct_type__arg,  ::some::valid::ns::IOBuf iobuf_type__arg,  ::some::valid::ns::IOBufPtr iobuf_ptr__arg, std::list<int32_t> list_i32_template__arg, std::deque<std::string> list_string_template__arg, folly::sorted_vector_set<std::string> set_template__arg, folly::sorted_vector_map<int64_t, std::string> map_template__arg,  ::some::valid::ns::std_list typedef_list_template__arg,  ::some::valid::ns::std_deque typedef_deque_template__arg,  ::some::valid::ns::folly_set typedef_set_template__arg,  ::some::valid::ns::folly_map typedef_map_template__arg,  ::some::valid::ns::IndirectionA indirection_a__arg, std::vector< ::some::valid::ns::IndirectionB> indirection_b__arg, std::set< ::some::valid::ns::IndirectionC> indirection_c__arg,  ::some::valid::ns::IOBuf iobuf_type_val__arg,  ::some::valid::ns::IOBufPtr iobuf_ptr_val__arg,  ::some::valid::ns::containerStruct struct_struct__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    no_annotation = arg.extract();
    __isset.no_annotation = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    cpp_unique_ref = std::make_unique<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<3, _T> arg) {
    cpp2_unique_ref = std::make_unique<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<4, _T> arg) {
    container_with_ref = std::make_unique<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<5, _T> arg) {
    req_cpp_unique_ref = std::make_unique<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<6, _T> arg) {
    req_cpp2_unique_ref = std::make_unique<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<7, _T> arg) {
    req_container_with_ref = std::make_unique<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<8, _T> arg) {
    opt_cpp_unique_ref = std::make_unique<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<9, _T> arg) {
    opt_cpp2_unique_ref = std::make_unique<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<10, _T> arg) {
    opt_container_with_ref = std::make_unique<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<11, _T> arg) {
    ref_type_unique = std::make_unique<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<12, _T> arg) {
    ref_type_shared = std::make_shared<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<13, _T> arg) {
    ref_type_const = std::make_shared<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<14, _T> arg) {
    req_ref_type_shared = std::make_shared<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<15, _T> arg) {
    req_ref_type_const = std::make_shared<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<16, _T> arg) {
    req_ref_type_unique = std::make_unique<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<17, _T> arg) {
    opt_ref_type_const = std::make_shared<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<18, _T> arg) {
    opt_ref_type_unique = std::make_unique<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<19, _T> arg) {
    opt_ref_type_shared = std::make_shared<std::decay_t<_T>>(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<20, _T> arg) {
    base_type = arg.extract();
    __isset.base_type = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<21, _T> arg) {
    list_type = arg.extract();
    __isset.list_type = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<22, _T> arg) {
    set_type = arg.extract();
    __isset.set_type = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<23, _T> arg) {
    map_type = arg.extract();
    __isset.map_type = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<24, _T> arg) {
    map_struct_type = arg.extract();
    __isset.map_struct_type = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<25, _T> arg) {
    iobuf_type = arg.extract();
    __isset.iobuf_type = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<26, _T> arg) {
    iobuf_ptr = arg.extract();
    __isset.iobuf_ptr = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<27, _T> arg) {
    list_i32_template = arg.extract();
    __isset.list_i32_template = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<28, _T> arg) {
    list_string_template = arg.extract();
    __isset.list_string_template = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<29, _T> arg) {
    set_template = arg.extract();
    __isset.set_template = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<30, _T> arg) {
    map_template = arg.extract();
    __isset.map_template = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<31, _T> arg) {
    typedef_list_template = arg.extract();
    __isset.typedef_list_template = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<32, _T> arg) {
    typedef_deque_template = arg.extract();
    __isset.typedef_deque_template = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<33, _T> arg) {
    typedef_set_template = arg.extract();
    __isset.typedef_set_template = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<34, _T> arg) {
    typedef_map_template = arg.extract();
    __isset.typedef_map_template = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<35, _T> arg) {
    indirection_a = arg.extract();
    __isset.indirection_a = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<36, _T> arg) {
    indirection_b = arg.extract();
    __isset.indirection_b = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<37, _T> arg) {
    indirection_c = arg.extract();
    __isset.indirection_c = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<38, _T> arg) {
    iobuf_type_val = arg.extract();
    __isset.iobuf_type_val = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<39, _T> arg) {
    iobuf_ptr_val = arg.extract();
    __isset.iobuf_ptr_val = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<40, _T> arg) {
    struct_struct = arg.extract();
    __isset.struct_struct = true;
  }
  AnnotatedStruct(AnnotatedStruct&& other) noexcept;

  AnnotatedStruct& operator=(AnnotatedStruct&&) = default;
  void __clear();

  virtual ~AnnotatedStruct();

   ::some::valid::ns::containerStruct no_annotation;
  std::unique_ptr< ::some::valid::ns::containerStruct> cpp_unique_ref;
  std::unique_ptr< ::some::valid::ns::containerStruct> cpp2_unique_ref;
  std::unique_ptr<std::map<int32_t, std::vector<std::string>>> container_with_ref;
  std::unique_ptr< ::some::valid::ns::containerStruct> req_cpp_unique_ref;
  std::unique_ptr< ::some::valid::ns::containerStruct> req_cpp2_unique_ref;
  std::unique_ptr<std::vector<std::string>> req_container_with_ref;
  std::unique_ptr< ::some::valid::ns::containerStruct> opt_cpp_unique_ref;
  std::unique_ptr< ::some::valid::ns::containerStruct> opt_cpp2_unique_ref;
  std::unique_ptr<std::set<int32_t>> opt_container_with_ref;
  std::unique_ptr< ::some::valid::ns::containerStruct> ref_type_unique;
  std::shared_ptr< ::some::valid::ns::containerStruct> ref_type_shared;
  std::shared_ptr<const std::map<int32_t, std::vector<std::string>>> ref_type_const;
  std::shared_ptr< ::some::valid::ns::containerStruct> req_ref_type_shared;
  std::shared_ptr<const  ::some::valid::ns::containerStruct> req_ref_type_const;
  std::unique_ptr<std::vector<std::string>> req_ref_type_unique;
  std::shared_ptr<const  ::some::valid::ns::containerStruct> opt_ref_type_const;
  std::unique_ptr< ::some::valid::ns::containerStruct> opt_ref_type_unique;
  std::shared_ptr<std::set<int32_t>> opt_ref_type_shared;
   ::some::valid::ns::CppFakeI32 base_type;
   ::some::valid::ns::FollySmallVectorI64 list_type;
   ::some::valid::ns::SortedVectorSetString set_type;
   ::some::valid::ns::FakeMap map_type;
   ::some::valid::ns::UnorderedMapStruct map_struct_type;
   ::some::valid::ns::IOBuf iobuf_type;
   ::some::valid::ns::IOBufPtr iobuf_ptr;
  std::list<int32_t> list_i32_template;
  std::deque<std::string> list_string_template;
  folly::sorted_vector_set<std::string> set_template;
  folly::sorted_vector_map<int64_t, std::string> map_template;
   ::some::valid::ns::std_list typedef_list_template;
   ::some::valid::ns::std_deque typedef_deque_template;
   ::some::valid::ns::folly_set typedef_set_template;
   ::some::valid::ns::folly_map typedef_map_template;
   ::some::valid::ns::IndirectionA indirection_a;
  std::vector< ::some::valid::ns::IndirectionB> indirection_b;
  std::set< ::some::valid::ns::IndirectionC> indirection_c;
   ::some::valid::ns::IOBuf iobuf_type_val;
   ::some::valid::ns::IOBufPtr iobuf_ptr_val;
   ::some::valid::ns::containerStruct struct_struct;

  struct __isset {
    bool no_annotation;
    bool base_type;
    bool list_type;
    bool set_type;
    bool map_type;
    bool map_struct_type;
    bool iobuf_type;
    bool iobuf_ptr;
    bool list_i32_template;
    bool list_string_template;
    bool set_template;
    bool map_template;
    bool typedef_list_template;
    bool typedef_deque_template;
    bool typedef_set_template;
    bool typedef_map_template;
    bool indirection_a;
    bool indirection_b;
    bool indirection_c;
    bool iobuf_type_val;
    bool iobuf_ptr_val;
    bool struct_struct;
  } __isset = {};
  bool operator==(const AnnotatedStruct& rhs) const;
  bool operator<(const AnnotatedStruct& rhs) const;
  const  ::some::valid::ns::containerStruct& get_no_annotation() const&;
   ::some::valid::ns::containerStruct get_no_annotation() &&;

  template <typename T_AnnotatedStruct_no_annotation_struct_setter =  ::some::valid::ns::containerStruct>
   ::some::valid::ns::containerStruct& set_no_annotation(T_AnnotatedStruct_no_annotation_struct_setter&& no_annotation_) {
    no_annotation = std::forward<T_AnnotatedStruct_no_annotation_struct_setter>(no_annotation_);
    __isset.no_annotation = true;
    return no_annotation;
  }

   ::some::valid::ns::CppFakeI32 get_base_type() const {
    return base_type;
  }

   ::some::valid::ns::CppFakeI32& set_base_type( ::some::valid::ns::CppFakeI32 base_type_) {
    base_type = base_type_;
    __isset.base_type = true;
    return base_type;
  }
  const  ::some::valid::ns::FollySmallVectorI64& get_list_type() const&;
   ::some::valid::ns::FollySmallVectorI64 get_list_type() &&;

  template <typename T_AnnotatedStruct_list_type_struct_setter =  ::some::valid::ns::FollySmallVectorI64>
   ::some::valid::ns::FollySmallVectorI64& set_list_type(T_AnnotatedStruct_list_type_struct_setter&& list_type_) {
    list_type = std::forward<T_AnnotatedStruct_list_type_struct_setter>(list_type_);
    __isset.list_type = true;
    return list_type;
  }
  const  ::some::valid::ns::SortedVectorSetString& get_set_type() const&;
   ::some::valid::ns::SortedVectorSetString get_set_type() &&;

  template <typename T_AnnotatedStruct_set_type_struct_setter =  ::some::valid::ns::SortedVectorSetString>
   ::some::valid::ns::SortedVectorSetString& set_set_type(T_AnnotatedStruct_set_type_struct_setter&& set_type_) {
    set_type = std::forward<T_AnnotatedStruct_set_type_struct_setter>(set_type_);
    __isset.set_type = true;
    return set_type;
  }
  const  ::some::valid::ns::FakeMap& get_map_type() const&;
   ::some::valid::ns::FakeMap get_map_type() &&;

  template <typename T_AnnotatedStruct_map_type_struct_setter =  ::some::valid::ns::FakeMap>
   ::some::valid::ns::FakeMap& set_map_type(T_AnnotatedStruct_map_type_struct_setter&& map_type_) {
    map_type = std::forward<T_AnnotatedStruct_map_type_struct_setter>(map_type_);
    __isset.map_type = true;
    return map_type;
  }
  const  ::some::valid::ns::UnorderedMapStruct& get_map_struct_type() const&;
   ::some::valid::ns::UnorderedMapStruct get_map_struct_type() &&;

  template <typename T_AnnotatedStruct_map_struct_type_struct_setter =  ::some::valid::ns::UnorderedMapStruct>
   ::some::valid::ns::UnorderedMapStruct& set_map_struct_type(T_AnnotatedStruct_map_struct_type_struct_setter&& map_struct_type_) {
    map_struct_type = std::forward<T_AnnotatedStruct_map_struct_type_struct_setter>(map_struct_type_);
    __isset.map_struct_type = true;
    return map_struct_type;
  }

  const  ::some::valid::ns::IOBuf& get_iobuf_type() const& {
    return iobuf_type;
  }

   ::some::valid::ns::IOBuf get_iobuf_type() && {
    return std::move(iobuf_type);
  }

  template <typename T_AnnotatedStruct_iobuf_type_struct_setter =  ::some::valid::ns::IOBuf>
   ::some::valid::ns::IOBuf& set_iobuf_type(T_AnnotatedStruct_iobuf_type_struct_setter&& iobuf_type_) {
    iobuf_type = std::forward<T_AnnotatedStruct_iobuf_type_struct_setter>(iobuf_type_);
    __isset.iobuf_type = true;
    return iobuf_type;
  }

  const  ::some::valid::ns::IOBufPtr& get_iobuf_ptr() const& {
    return iobuf_ptr;
  }

   ::some::valid::ns::IOBufPtr get_iobuf_ptr() && {
    return std::move(iobuf_ptr);
  }

  template <typename T_AnnotatedStruct_iobuf_ptr_struct_setter =  ::some::valid::ns::IOBufPtr>
   ::some::valid::ns::IOBufPtr& set_iobuf_ptr(T_AnnotatedStruct_iobuf_ptr_struct_setter&& iobuf_ptr_) {
    iobuf_ptr = std::forward<T_AnnotatedStruct_iobuf_ptr_struct_setter>(iobuf_ptr_);
    __isset.iobuf_ptr = true;
    return iobuf_ptr;
  }
  const std::list<int32_t>& get_list_i32_template() const&;
  std::list<int32_t> get_list_i32_template() &&;

  template <typename T_AnnotatedStruct_list_i32_template_struct_setter = std::list<int32_t>>
  std::list<int32_t>& set_list_i32_template(T_AnnotatedStruct_list_i32_template_struct_setter&& list_i32_template_) {
    list_i32_template = std::forward<T_AnnotatedStruct_list_i32_template_struct_setter>(list_i32_template_);
    __isset.list_i32_template = true;
    return list_i32_template;
  }
  const std::deque<std::string>& get_list_string_template() const&;
  std::deque<std::string> get_list_string_template() &&;

  template <typename T_AnnotatedStruct_list_string_template_struct_setter = std::deque<std::string>>
  std::deque<std::string>& set_list_string_template(T_AnnotatedStruct_list_string_template_struct_setter&& list_string_template_) {
    list_string_template = std::forward<T_AnnotatedStruct_list_string_template_struct_setter>(list_string_template_);
    __isset.list_string_template = true;
    return list_string_template;
  }
  const folly::sorted_vector_set<std::string>& get_set_template() const&;
  folly::sorted_vector_set<std::string> get_set_template() &&;

  template <typename T_AnnotatedStruct_set_template_struct_setter = folly::sorted_vector_set<std::string>>
  folly::sorted_vector_set<std::string>& set_set_template(T_AnnotatedStruct_set_template_struct_setter&& set_template_) {
    set_template = std::forward<T_AnnotatedStruct_set_template_struct_setter>(set_template_);
    __isset.set_template = true;
    return set_template;
  }
  const folly::sorted_vector_map<int64_t, std::string>& get_map_template() const&;
  folly::sorted_vector_map<int64_t, std::string> get_map_template() &&;

  template <typename T_AnnotatedStruct_map_template_struct_setter = folly::sorted_vector_map<int64_t, std::string>>
  folly::sorted_vector_map<int64_t, std::string>& set_map_template(T_AnnotatedStruct_map_template_struct_setter&& map_template_) {
    map_template = std::forward<T_AnnotatedStruct_map_template_struct_setter>(map_template_);
    __isset.map_template = true;
    return map_template;
  }
  const  ::some::valid::ns::std_list& get_typedef_list_template() const&;
   ::some::valid::ns::std_list get_typedef_list_template() &&;

  template <typename T_AnnotatedStruct_typedef_list_template_struct_setter =  ::some::valid::ns::std_list>
   ::some::valid::ns::std_list& set_typedef_list_template(T_AnnotatedStruct_typedef_list_template_struct_setter&& typedef_list_template_) {
    typedef_list_template = std::forward<T_AnnotatedStruct_typedef_list_template_struct_setter>(typedef_list_template_);
    __isset.typedef_list_template = true;
    return typedef_list_template;
  }
  const  ::some::valid::ns::std_deque& get_typedef_deque_template() const&;
   ::some::valid::ns::std_deque get_typedef_deque_template() &&;

  template <typename T_AnnotatedStruct_typedef_deque_template_struct_setter =  ::some::valid::ns::std_deque>
   ::some::valid::ns::std_deque& set_typedef_deque_template(T_AnnotatedStruct_typedef_deque_template_struct_setter&& typedef_deque_template_) {
    typedef_deque_template = std::forward<T_AnnotatedStruct_typedef_deque_template_struct_setter>(typedef_deque_template_);
    __isset.typedef_deque_template = true;
    return typedef_deque_template;
  }
  const  ::some::valid::ns::folly_set& get_typedef_set_template() const&;
   ::some::valid::ns::folly_set get_typedef_set_template() &&;

  template <typename T_AnnotatedStruct_typedef_set_template_struct_setter =  ::some::valid::ns::folly_set>
   ::some::valid::ns::folly_set& set_typedef_set_template(T_AnnotatedStruct_typedef_set_template_struct_setter&& typedef_set_template_) {
    typedef_set_template = std::forward<T_AnnotatedStruct_typedef_set_template_struct_setter>(typedef_set_template_);
    __isset.typedef_set_template = true;
    return typedef_set_template;
  }
  const  ::some::valid::ns::folly_map& get_typedef_map_template() const&;
   ::some::valid::ns::folly_map get_typedef_map_template() &&;

  template <typename T_AnnotatedStruct_typedef_map_template_struct_setter =  ::some::valid::ns::folly_map>
   ::some::valid::ns::folly_map& set_typedef_map_template(T_AnnotatedStruct_typedef_map_template_struct_setter&& typedef_map_template_) {
    typedef_map_template = std::forward<T_AnnotatedStruct_typedef_map_template_struct_setter>(typedef_map_template_);
    __isset.typedef_map_template = true;
    return typedef_map_template;
  }

   ::some::valid::ns::IndirectionA get_indirection_a() const {
    return indirection_a;
  }

   ::some::valid::ns::IndirectionA& set_indirection_a( ::some::valid::ns::IndirectionA indirection_a_) {
    indirection_a = indirection_a_;
    __isset.indirection_a = true;
    return indirection_a;
  }
  const std::vector< ::some::valid::ns::IndirectionB>& get_indirection_b() const&;
  std::vector< ::some::valid::ns::IndirectionB> get_indirection_b() &&;

  template <typename T_AnnotatedStruct_indirection_b_struct_setter = std::vector< ::some::valid::ns::IndirectionB>>
  std::vector< ::some::valid::ns::IndirectionB>& set_indirection_b(T_AnnotatedStruct_indirection_b_struct_setter&& indirection_b_) {
    indirection_b = std::forward<T_AnnotatedStruct_indirection_b_struct_setter>(indirection_b_);
    __isset.indirection_b = true;
    return indirection_b;
  }
  const std::set< ::some::valid::ns::IndirectionC>& get_indirection_c() const&;
  std::set< ::some::valid::ns::IndirectionC> get_indirection_c() &&;

  template <typename T_AnnotatedStruct_indirection_c_struct_setter = std::set< ::some::valid::ns::IndirectionC>>
  std::set< ::some::valid::ns::IndirectionC>& set_indirection_c(T_AnnotatedStruct_indirection_c_struct_setter&& indirection_c_) {
    indirection_c = std::forward<T_AnnotatedStruct_indirection_c_struct_setter>(indirection_c_);
    __isset.indirection_c = true;
    return indirection_c;
  }

  const  ::some::valid::ns::IOBuf& get_iobuf_type_val() const& {
    return iobuf_type_val;
  }

   ::some::valid::ns::IOBuf get_iobuf_type_val() && {
    return std::move(iobuf_type_val);
  }

  template <typename T_AnnotatedStruct_iobuf_type_val_struct_setter =  ::some::valid::ns::IOBuf>
   ::some::valid::ns::IOBuf& set_iobuf_type_val(T_AnnotatedStruct_iobuf_type_val_struct_setter&& iobuf_type_val_) {
    iobuf_type_val = std::forward<T_AnnotatedStruct_iobuf_type_val_struct_setter>(iobuf_type_val_);
    __isset.iobuf_type_val = true;
    return iobuf_type_val;
  }

  const  ::some::valid::ns::IOBufPtr& get_iobuf_ptr_val() const& {
    return iobuf_ptr_val;
  }

   ::some::valid::ns::IOBufPtr get_iobuf_ptr_val() && {
    return std::move(iobuf_ptr_val);
  }

  template <typename T_AnnotatedStruct_iobuf_ptr_val_struct_setter =  ::some::valid::ns::IOBufPtr>
   ::some::valid::ns::IOBufPtr& set_iobuf_ptr_val(T_AnnotatedStruct_iobuf_ptr_val_struct_setter&& iobuf_ptr_val_) {
    iobuf_ptr_val = std::forward<T_AnnotatedStruct_iobuf_ptr_val_struct_setter>(iobuf_ptr_val_);
    __isset.iobuf_ptr_val = true;
    return iobuf_ptr_val;
  }
  const  ::some::valid::ns::containerStruct& get_struct_struct() const&;
   ::some::valid::ns::containerStruct get_struct_struct() &&;

  template <typename T_AnnotatedStruct_struct_struct_struct_setter =  ::some::valid::ns::containerStruct>
   ::some::valid::ns::containerStruct& set_struct_struct(T_AnnotatedStruct_struct_struct_struct_setter&& struct_struct_) {
    struct_struct = std::forward<T_AnnotatedStruct_struct_struct_struct_setter>(struct_struct_);
    __isset.struct_struct = true;
    return struct_struct;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
  // user defined code (cpp2.methods = ...)
  void foo(const std::string& bar) {}

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AnnotatedStruct >;
};

void swap(AnnotatedStruct& a, AnnotatedStruct& b);

template <class Protocol_>
uint32_t AnnotatedStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class ComplexContainerStruct final : private apache::thrift::detail::st::ComparisonOperators<ComplexContainerStruct> {
 public:

  ComplexContainerStruct() {}
  // FragileConstructor for use in initialization lists only.
  ComplexContainerStruct(apache::thrift::FragileConstructor, std::map<std::string,  ::some::valid::ns::IOBuf> map_of_iobufs__arg, std::map<std::string,  ::some::valid::ns::IOBufPtr> map_of_iobuf_ptrs__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    map_of_iobufs = arg.extract();
    __isset.map_of_iobufs = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    map_of_iobuf_ptrs = arg.extract();
    __isset.map_of_iobuf_ptrs = true;
  }

  ComplexContainerStruct(ComplexContainerStruct&&) = default;

  ComplexContainerStruct(const ComplexContainerStruct&) = default;

  ComplexContainerStruct& operator=(ComplexContainerStruct&&) = default;

  ComplexContainerStruct& operator=(const ComplexContainerStruct&) = default;
  void __clear();
  std::map<std::string,  ::some::valid::ns::IOBuf> map_of_iobufs;
  std::map<std::string,  ::some::valid::ns::IOBufPtr> map_of_iobuf_ptrs;

  struct __isset {
    bool map_of_iobufs;
    bool map_of_iobuf_ptrs;
  } __isset = {};
  bool operator==(const ComplexContainerStruct& rhs) const;
  bool operator<(const ComplexContainerStruct& rhs) const;
  const std::map<std::string,  ::some::valid::ns::IOBuf>& get_map_of_iobufs() const&;
  std::map<std::string,  ::some::valid::ns::IOBuf> get_map_of_iobufs() &&;

  template <typename T_ComplexContainerStruct_map_of_iobufs_struct_setter = std::map<std::string,  ::some::valid::ns::IOBuf>>
  std::map<std::string,  ::some::valid::ns::IOBuf>& set_map_of_iobufs(T_ComplexContainerStruct_map_of_iobufs_struct_setter&& map_of_iobufs_) {
    map_of_iobufs = std::forward<T_ComplexContainerStruct_map_of_iobufs_struct_setter>(map_of_iobufs_);
    __isset.map_of_iobufs = true;
    return map_of_iobufs;
  }
  const std::map<std::string,  ::some::valid::ns::IOBufPtr>& get_map_of_iobuf_ptrs() const&;
  std::map<std::string,  ::some::valid::ns::IOBufPtr> get_map_of_iobuf_ptrs() &&;

  template <typename T_ComplexContainerStruct_map_of_iobuf_ptrs_struct_setter = std::map<std::string,  ::some::valid::ns::IOBufPtr>>
  std::map<std::string,  ::some::valid::ns::IOBufPtr>& set_map_of_iobuf_ptrs(T_ComplexContainerStruct_map_of_iobuf_ptrs_struct_setter&& map_of_iobuf_ptrs_) {
    map_of_iobuf_ptrs = std::forward<T_ComplexContainerStruct_map_of_iobuf_ptrs_struct_setter>(map_of_iobuf_ptrs_);
    __isset.map_of_iobuf_ptrs = true;
    return map_of_iobuf_ptrs;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ComplexContainerStruct >;
};

void swap(ComplexContainerStruct& a, ComplexContainerStruct& b);

template <class Protocol_>
uint32_t ComplexContainerStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class FloatStruct final : private apache::thrift::detail::st::ComparisonOperators<FloatStruct> {
 public:

  FloatStruct() :
      floatField(0),
      doubleField(0) {}
  // FragileConstructor for use in initialization lists only.
  FloatStruct(apache::thrift::FragileConstructor, float floatField__arg, double doubleField__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    floatField = arg.extract();
    __isset.floatField = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    doubleField = arg.extract();
    __isset.doubleField = true;
  }

  FloatStruct(FloatStruct&&) = default;

  FloatStruct(const FloatStruct&) = default;

  FloatStruct& operator=(FloatStruct&&) = default;

  FloatStruct& operator=(const FloatStruct&) = default;
  void __clear();
  float floatField;
  double doubleField;

  struct __isset {
    bool floatField;
    bool doubleField;
  } __isset = {};
  bool operator==(const FloatStruct& rhs) const;
  bool operator<(const FloatStruct& rhs) const;

  float get_floatField() const {
    return floatField;
  }

  float& set_floatField(float floatField_) {
    floatField = floatField_;
    __isset.floatField = true;
    return floatField;
  }

  double get_doubleField() const {
    return doubleField;
  }

  double& set_doubleField(double doubleField_) {
    doubleField = doubleField_;
    __isset.doubleField = true;
    return doubleField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< FloatStruct >;
};

void swap(FloatStruct& a, FloatStruct& b);

template <class Protocol_>
uint32_t FloatStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class FloatUnion final : private apache::thrift::detail::st::ComparisonOperators<FloatUnion> {
 public:
  enum Type {
    __EMPTY__ = 0,
    floatSide = 1,
    doubleSide = 2,
  } ;

  FloatUnion()
      : type_(Type::__EMPTY__) {}

  FloatUnion(FloatUnion&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::floatSide:
      {
        set_floatSide(std::move(rhs.value_.floatSide));
        break;
      }
      case Type::doubleSide:
      {
        set_doubleSide(std::move(rhs.value_.doubleSide));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  FloatUnion(const FloatUnion& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::floatSide:
      {
        set_floatSide(rhs.value_.floatSide);
        break;
      }
      case Type::doubleSide:
      {
        set_doubleSide(rhs.value_.doubleSide);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  FloatUnion& operator=(FloatUnion&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::floatSide:
      {
        set_floatSide(std::move(rhs.value_.floatSide));
        break;
      }
      case Type::doubleSide:
      {
        set_doubleSide(std::move(rhs.value_.doubleSide));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  FloatUnion& operator=(const FloatUnion& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::floatSide:
      {
        set_floatSide(rhs.value_.floatSide);
        break;
      }
      case Type::doubleSide:
      {
        set_doubleSide(rhs.value_.doubleSide);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    set_floatSide(arg.extract());
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    set_doubleSide(arg.extract());
  }
  void __clear();

  ~FloatUnion() {
    __clear();
  }
  union storage_type {
    float floatSide;
    double doubleSide;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const FloatUnion& rhs) const;
  bool operator<(const FloatUnion& rhs) const;

  float& set_floatSide(float t = float()) {
    __clear();
    type_ = Type::floatSide;
    ::new (std::addressof(value_.floatSide)) float(t);
    return value_.floatSide;
  }

  double& set_doubleSide(double t = double()) {
    __clear();
    type_ = Type::doubleSide;
    ::new (std::addressof(value_.doubleSide)) double(t);
    return value_.doubleSide;
  }

  float const & get_floatSide() const {
    assert(type_ == Type::floatSide);
    return value_.floatSide;
  }

  double const & get_doubleSide() const {
    assert(type_ == Type::doubleSide);
    return value_.doubleSide;
  }

  float & mutable_floatSide() {
    assert(type_ == Type::floatSide);
    return value_.floatSide;
  }

  double & mutable_doubleSide() {
    assert(type_ == Type::doubleSide);
    return value_.doubleSide;
  }

  float move_floatSide() {
    assert(type_ == Type::floatSide);
    return std::move(value_.floatSide);
  }

  double move_doubleSide() {
    assert(type_ == Type::doubleSide);
    return std::move(value_.doubleSide);
  }

  Type getType() const { return type_; }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  Type type_;
  storage_type value_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< FloatUnion >;
};

void swap(FloatUnion& a, FloatUnion& b);

template <class Protocol_>
uint32_t FloatUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}} // some::valid::ns
namespace some { namespace valid { namespace ns {
class AllRequiredNoExceptMoveCtrStruct final : private apache::thrift::detail::st::ComparisonOperators<AllRequiredNoExceptMoveCtrStruct> {
 public:

  AllRequiredNoExceptMoveCtrStruct() :
      intField(0) {}
  // FragileConstructor for use in initialization lists only.
  AllRequiredNoExceptMoveCtrStruct(apache::thrift::FragileConstructor, int64_t intField__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    intField = arg.extract();
  }
  AllRequiredNoExceptMoveCtrStruct(AllRequiredNoExceptMoveCtrStruct&& other) noexcept :
      intField(std::move(other.intField)) {}

  AllRequiredNoExceptMoveCtrStruct(const AllRequiredNoExceptMoveCtrStruct&) = default;

  AllRequiredNoExceptMoveCtrStruct& operator=(AllRequiredNoExceptMoveCtrStruct&&) = default;

  AllRequiredNoExceptMoveCtrStruct& operator=(const AllRequiredNoExceptMoveCtrStruct&) = default;
  void __clear();
  int64_t intField;
  bool operator==(const AllRequiredNoExceptMoveCtrStruct& rhs) const;
  bool operator<(const AllRequiredNoExceptMoveCtrStruct& rhs) const;

  int64_t get_intField() const {
    return intField;
  }

  int64_t& set_intField(int64_t intField_) {
    intField = intField_;
    return intField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< AllRequiredNoExceptMoveCtrStruct >;
};

void swap(AllRequiredNoExceptMoveCtrStruct& a, AllRequiredNoExceptMoveCtrStruct& b);

template <class Protocol_>
uint32_t AllRequiredNoExceptMoveCtrStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCurrentPosition().getCurrentPosition();
  readNoXfer(iprot);
  return iprot->getCurrentPosition().getCurrentPosition() - _xferStart;
}

}}} // some::valid::ns
