/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/fatal/gen-cpp2/service_with_special_names.h"

#include "thrift/compiler/test/fixtures/fatal/gen-cpp2/service_with_special_names.tcc"

#include <thrift/lib/cpp2/protocol/BinaryProtocol.h>
#include <thrift/lib/cpp2/protocol/CompactProtocol.h>
namespace test_cpp2 { namespace cpp_reflection {

const char* service_with_special_namesAsyncClient::getServiceName() {
  return "service_with_special_names";
}

void service_with_special_namesAsyncClient::get(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  get(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::get(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_get() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_get(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_get(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback485 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  get(rpcOptions, std::move(callback485));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_get(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_get() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_get(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_get(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise486;
  auto future487 = promise486.getFuture();
  auto callback488 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise486), recv_wrapped_get, channel_);
  get(rpcOptions, std::move(callback488));
  return future487;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_get(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise489;
  auto future490 = promise489.getFuture();
  auto callback491 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise489), recv_wrapped_get, channel_);
  get(rpcOptions, std::move(callback491));
  return future490;
}

void service_with_special_namesAsyncClient::get(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  get(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_get(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_getT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_getT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_get(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_get(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_get(::apache::thrift::ClientReceiveState& state) {
  return recv_get(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_get(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_get(_return, state);
}

void service_with_special_namesAsyncClient::getter(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  getter(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::getter(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getterT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getterT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_getter() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_getter(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_getter(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback492 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  getter(rpcOptions, std::move(callback492));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_getter(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_getter() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getter(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_getter(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise493;
  auto future494 = promise493.getFuture();
  auto callback495 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise493), recv_wrapped_getter, channel_);
  getter(rpcOptions, std::move(callback495));
  return future494;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_getter(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise496;
  auto future497 = promise496.getFuture();
  auto callback498 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise496), recv_wrapped_getter, channel_);
  getter(rpcOptions, std::move(callback498));
  return future497;
}

void service_with_special_namesAsyncClient::getter(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  getter(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_getter(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_getterT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_getterT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_getter(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_getter(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_getter(::apache::thrift::ClientReceiveState& state) {
  return recv_getter(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_getter(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getter(_return, state);
}

void service_with_special_namesAsyncClient::lists(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  lists(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::lists(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      listsT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      listsT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_lists() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_lists(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_lists(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback499 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  lists(rpcOptions, std::move(callback499));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_lists(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_lists() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_lists(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_lists(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise500;
  auto future501 = promise500.getFuture();
  auto callback502 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise500), recv_wrapped_lists, channel_);
  lists(rpcOptions, std::move(callback502));
  return future501;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_lists(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise503;
  auto future504 = promise503.getFuture();
  auto callback505 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise503), recv_wrapped_lists, channel_);
  lists(rpcOptions, std::move(callback505));
  return future504;
}

void service_with_special_namesAsyncClient::lists(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  lists(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_lists(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_listsT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_listsT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_lists(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_lists(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_lists(::apache::thrift::ClientReceiveState& state) {
  return recv_lists(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_lists(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_lists(_return, state);
}

void service_with_special_namesAsyncClient::maps(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  maps(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::maps(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      mapsT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      mapsT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_maps() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_maps(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_maps(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback506 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  maps(rpcOptions, std::move(callback506));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_maps(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_maps() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_maps(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_maps(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise507;
  auto future508 = promise507.getFuture();
  auto callback509 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise507), recv_wrapped_maps, channel_);
  maps(rpcOptions, std::move(callback509));
  return future508;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_maps(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise510;
  auto future511 = promise510.getFuture();
  auto callback512 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise510), recv_wrapped_maps, channel_);
  maps(rpcOptions, std::move(callback512));
  return future511;
}

void service_with_special_namesAsyncClient::maps(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  maps(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_maps(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_mapsT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_mapsT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_maps(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_maps(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_maps(::apache::thrift::ClientReceiveState& state) {
  return recv_maps(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_maps(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_maps(_return, state);
}

void service_with_special_namesAsyncClient::name(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  name(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::name(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      nameT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      nameT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_name() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_name(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_name(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback513 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  name(rpcOptions, std::move(callback513));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_name(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_name() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_name(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_name(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise514;
  auto future515 = promise514.getFuture();
  auto callback516 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise514), recv_wrapped_name, channel_);
  name(rpcOptions, std::move(callback516));
  return future515;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_name(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise517;
  auto future518 = promise517.getFuture();
  auto callback519 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise517), recv_wrapped_name, channel_);
  name(rpcOptions, std::move(callback519));
  return future518;
}

void service_with_special_namesAsyncClient::name(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  name(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_name(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_nameT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_nameT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_name(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_name(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_name(::apache::thrift::ClientReceiveState& state) {
  return recv_name(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_name(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_name(_return, state);
}

void service_with_special_namesAsyncClient::name_to_value(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  name_to_value(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::name_to_value(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      name_to_valueT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      name_to_valueT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_name_to_value() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_name_to_value(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_name_to_value(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback520 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  name_to_value(rpcOptions, std::move(callback520));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_name_to_value(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_name_to_value() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_name_to_value(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_name_to_value(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise521;
  auto future522 = promise521.getFuture();
  auto callback523 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise521), recv_wrapped_name_to_value, channel_);
  name_to_value(rpcOptions, std::move(callback523));
  return future522;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_name_to_value(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise524;
  auto future525 = promise524.getFuture();
  auto callback526 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise524), recv_wrapped_name_to_value, channel_);
  name_to_value(rpcOptions, std::move(callback526));
  return future525;
}

void service_with_special_namesAsyncClient::name_to_value(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  name_to_value(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_name_to_value(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_name_to_valueT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_name_to_valueT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_name_to_value(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_name_to_value(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_name_to_value(::apache::thrift::ClientReceiveState& state) {
  return recv_name_to_value(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_name_to_value(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_name_to_value(_return, state);
}

void service_with_special_namesAsyncClient::names(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  names(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::names(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      namesT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      namesT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_names() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_names(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_names(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback527 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  names(rpcOptions, std::move(callback527));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_names(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_names() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_names(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_names(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise528;
  auto future529 = promise528.getFuture();
  auto callback530 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise528), recv_wrapped_names, channel_);
  names(rpcOptions, std::move(callback530));
  return future529;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_names(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise531;
  auto future532 = promise531.getFuture();
  auto callback533 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise531), recv_wrapped_names, channel_);
  names(rpcOptions, std::move(callback533));
  return future532;
}

void service_with_special_namesAsyncClient::names(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  names(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_names(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_namesT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_namesT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_names(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_names(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_names(::apache::thrift::ClientReceiveState& state) {
  return recv_names(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_names(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_names(_return, state);
}

void service_with_special_namesAsyncClient::prefix_tree(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  prefix_tree(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::prefix_tree(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      prefix_treeT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      prefix_treeT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_prefix_tree() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_prefix_tree(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_prefix_tree(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback534 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  prefix_tree(rpcOptions, std::move(callback534));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_prefix_tree(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_prefix_tree() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_prefix_tree(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_prefix_tree(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise535;
  auto future536 = promise535.getFuture();
  auto callback537 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise535), recv_wrapped_prefix_tree, channel_);
  prefix_tree(rpcOptions, std::move(callback537));
  return future536;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_prefix_tree(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise538;
  auto future539 = promise538.getFuture();
  auto callback540 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise538), recv_wrapped_prefix_tree, channel_);
  prefix_tree(rpcOptions, std::move(callback540));
  return future539;
}

void service_with_special_namesAsyncClient::prefix_tree(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  prefix_tree(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_prefix_tree(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_prefix_treeT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_prefix_treeT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_prefix_tree(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_prefix_tree(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_prefix_tree(::apache::thrift::ClientReceiveState& state) {
  return recv_prefix_tree(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_prefix_tree(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_prefix_tree(_return, state);
}

void service_with_special_namesAsyncClient::sets(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  sets(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::sets(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      setsT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      setsT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_sets() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_sets(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_sets(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback541 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  sets(rpcOptions, std::move(callback541));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_sets(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_sets() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_sets(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_sets(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise542;
  auto future543 = promise542.getFuture();
  auto callback544 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise542), recv_wrapped_sets, channel_);
  sets(rpcOptions, std::move(callback544));
  return future543;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_sets(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise545;
  auto future546 = promise545.getFuture();
  auto callback547 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise545), recv_wrapped_sets, channel_);
  sets(rpcOptions, std::move(callback547));
  return future546;
}

void service_with_special_namesAsyncClient::sets(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  sets(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_sets(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_setsT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_setsT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_sets(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_sets(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_sets(::apache::thrift::ClientReceiveState& state) {
  return recv_sets(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_sets(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_sets(_return, state);
}

void service_with_special_namesAsyncClient::setter(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  setter(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::setter(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      setterT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      setterT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_setter() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_setter(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_setter(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback548 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  setter(rpcOptions, std::move(callback548));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_setter(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_setter() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_setter(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_setter(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise549;
  auto future550 = promise549.getFuture();
  auto callback551 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise549), recv_wrapped_setter, channel_);
  setter(rpcOptions, std::move(callback551));
  return future550;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_setter(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise552;
  auto future553 = promise552.getFuture();
  auto callback554 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise552), recv_wrapped_setter, channel_);
  setter(rpcOptions, std::move(callback554));
  return future553;
}

void service_with_special_namesAsyncClient::setter(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  setter(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_setter(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_setterT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_setterT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_setter(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_setter(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_setter(::apache::thrift::ClientReceiveState& state) {
  return recv_setter(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_setter(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_setter(_return, state);
}

void service_with_special_namesAsyncClient::str(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  str(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::str(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      strT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      strT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_str() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_str(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_str(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback555 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  str(rpcOptions, std::move(callback555));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_str(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_str() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_str(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_str(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise556;
  auto future557 = promise556.getFuture();
  auto callback558 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise556), recv_wrapped_str, channel_);
  str(rpcOptions, std::move(callback558));
  return future557;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_str(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise559;
  auto future560 = promise559.getFuture();
  auto callback561 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise559), recv_wrapped_str, channel_);
  str(rpcOptions, std::move(callback561));
  return future560;
}

void service_with_special_namesAsyncClient::str(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  str(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_str(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_strT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_strT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_str(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_str(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_str(::apache::thrift::ClientReceiveState& state) {
  return recv_str(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_str(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_str(_return, state);
}

void service_with_special_namesAsyncClient::strings(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  strings(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::strings(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      stringsT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      stringsT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_strings() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_strings(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_strings(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback562 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  strings(rpcOptions, std::move(callback562));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_strings(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_strings() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_strings(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_strings(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise563;
  auto future564 = promise563.getFuture();
  auto callback565 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise563), recv_wrapped_strings, channel_);
  strings(rpcOptions, std::move(callback565));
  return future564;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_strings(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise566;
  auto future567 = promise566.getFuture();
  auto callback568 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise566), recv_wrapped_strings, channel_);
  strings(rpcOptions, std::move(callback568));
  return future567;
}

void service_with_special_namesAsyncClient::strings(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  strings(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_strings(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_stringsT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_stringsT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_strings(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_strings(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_strings(::apache::thrift::ClientReceiveState& state) {
  return recv_strings(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_strings(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_strings(_return, state);
}

void service_with_special_namesAsyncClient::type(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  type(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::type(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      typeT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      typeT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_type() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_type(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_type(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback569 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  type(rpcOptions, std::move(callback569));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_type(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_type() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_type(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_type(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise570;
  auto future571 = promise570.getFuture();
  auto callback572 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise570), recv_wrapped_type, channel_);
  type(rpcOptions, std::move(callback572));
  return future571;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_type(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise573;
  auto future574 = promise573.getFuture();
  auto callback575 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise573), recv_wrapped_type, channel_);
  type(rpcOptions, std::move(callback575));
  return future574;
}

void service_with_special_namesAsyncClient::type(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  type(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_type(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_typeT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_typeT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_type(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_type(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_type(::apache::thrift::ClientReceiveState& state) {
  return recv_type(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_type(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_type(_return, state);
}

void service_with_special_namesAsyncClient::value(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  value(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::value(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      valueT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      valueT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_value() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_value(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_value(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback576 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  value(rpcOptions, std::move(callback576));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_value(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_value() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_value(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_value(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise577;
  auto future578 = promise577.getFuture();
  auto callback579 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise577), recv_wrapped_value, channel_);
  value(rpcOptions, std::move(callback579));
  return future578;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_value(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise580;
  auto future581 = promise580.getFuture();
  auto callback582 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise580), recv_wrapped_value, channel_);
  value(rpcOptions, std::move(callback582));
  return future581;
}

void service_with_special_namesAsyncClient::value(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  value(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_value(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_valueT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_valueT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_value(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_value(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_value(::apache::thrift::ClientReceiveState& state) {
  return recv_value(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_value(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_value(_return, state);
}

void service_with_special_namesAsyncClient::value_to_name(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  value_to_name(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::value_to_name(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      value_to_nameT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      value_to_nameT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_value_to_name() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_value_to_name(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_value_to_name(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback583 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  value_to_name(rpcOptions, std::move(callback583));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_value_to_name(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_value_to_name() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_value_to_name(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_value_to_name(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise584;
  auto future585 = promise584.getFuture();
  auto callback586 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise584), recv_wrapped_value_to_name, channel_);
  value_to_name(rpcOptions, std::move(callback586));
  return future585;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_value_to_name(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise587;
  auto future588 = promise587.getFuture();
  auto callback589 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise587), recv_wrapped_value_to_name, channel_);
  value_to_name(rpcOptions, std::move(callback589));
  return future588;
}

void service_with_special_namesAsyncClient::value_to_name(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  value_to_name(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_value_to_name(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_value_to_nameT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_value_to_nameT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_value_to_name(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_value_to_name(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_value_to_name(::apache::thrift::ClientReceiveState& state) {
  return recv_value_to_name(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_value_to_name(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_value_to_name(_return, state);
}

void service_with_special_namesAsyncClient::values(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  values(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::values(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      valuesT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      valuesT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_values() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_values(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_values(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback590 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  values(rpcOptions, std::move(callback590));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_values(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_values() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_values(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_values(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise591;
  auto future592 = promise591.getFuture();
  auto callback593 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise591), recv_wrapped_values, channel_);
  values(rpcOptions, std::move(callback593));
  return future592;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_values(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise594;
  auto future595 = promise594.getFuture();
  auto callback596 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise594), recv_wrapped_values, channel_);
  values(rpcOptions, std::move(callback596));
  return future595;
}

void service_with_special_namesAsyncClient::values(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  values(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_values(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_valuesT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_valuesT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_values(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_values(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_values(::apache::thrift::ClientReceiveState& state) {
  return recv_values(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_values(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_values(_return, state);
}

void service_with_special_namesAsyncClient::id(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  id(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::id(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      idT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      idT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_id() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_id(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_id(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback597 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  id(rpcOptions, std::move(callback597));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_id(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_id() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_id(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_id(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise598;
  auto future599 = promise598.getFuture();
  auto callback600 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise598), recv_wrapped_id, channel_);
  id(rpcOptions, std::move(callback600));
  return future599;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_id(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise601;
  auto future602 = promise601.getFuture();
  auto callback603 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise601), recv_wrapped_id, channel_);
  id(rpcOptions, std::move(callback603));
  return future602;
}

void service_with_special_namesAsyncClient::id(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  id(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_id(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_idT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_idT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_id(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_id(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_id(::apache::thrift::ClientReceiveState& state) {
  return recv_id(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_id(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_id(_return, state);
}

void service_with_special_namesAsyncClient::ids(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  ids(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::ids(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      idsT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      idsT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_ids() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_ids(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_ids(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback604 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  ids(rpcOptions, std::move(callback604));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_ids(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_ids() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_ids(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_ids(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise605;
  auto future606 = promise605.getFuture();
  auto callback607 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise605), recv_wrapped_ids, channel_);
  ids(rpcOptions, std::move(callback607));
  return future606;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_ids(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise608;
  auto future609 = promise608.getFuture();
  auto callback610 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise608), recv_wrapped_ids, channel_);
  ids(rpcOptions, std::move(callback610));
  return future609;
}

void service_with_special_namesAsyncClient::ids(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  ids(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_ids(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_idsT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_idsT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_ids(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_ids(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_ids(::apache::thrift::ClientReceiveState& state) {
  return recv_ids(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_ids(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_ids(_return, state);
}

void service_with_special_namesAsyncClient::descriptor(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  descriptor(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::descriptor(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      descriptorT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      descriptorT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_descriptor() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_descriptor(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_descriptor(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback611 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  descriptor(rpcOptions, std::move(callback611));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_descriptor(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_descriptor() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_descriptor(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_descriptor(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise612;
  auto future613 = promise612.getFuture();
  auto callback614 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise612), recv_wrapped_descriptor, channel_);
  descriptor(rpcOptions, std::move(callback614));
  return future613;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_descriptor(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise615;
  auto future616 = promise615.getFuture();
  auto callback617 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise615), recv_wrapped_descriptor, channel_);
  descriptor(rpcOptions, std::move(callback617));
  return future616;
}

void service_with_special_namesAsyncClient::descriptor(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  descriptor(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_descriptor(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_descriptorT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_descriptorT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_descriptor(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_descriptor(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_descriptor(::apache::thrift::ClientReceiveState& state) {
  return recv_descriptor(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_descriptor(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_descriptor(_return, state);
}

void service_with_special_namesAsyncClient::descriptors(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  descriptors(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::descriptors(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      descriptorsT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      descriptorsT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_descriptors() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_descriptors(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_descriptors(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback618 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  descriptors(rpcOptions, std::move(callback618));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_descriptors(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_descriptors() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_descriptors(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_descriptors(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise619;
  auto future620 = promise619.getFuture();
  auto callback621 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise619), recv_wrapped_descriptors, channel_);
  descriptors(rpcOptions, std::move(callback621));
  return future620;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_descriptors(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise622;
  auto future623 = promise622.getFuture();
  auto callback624 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise622), recv_wrapped_descriptors, channel_);
  descriptors(rpcOptions, std::move(callback624));
  return future623;
}

void service_with_special_namesAsyncClient::descriptors(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  descriptors(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_descriptors(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_descriptorsT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_descriptorsT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_descriptors(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_descriptors(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_descriptors(::apache::thrift::ClientReceiveState& state) {
  return recv_descriptors(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_descriptors(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_descriptors(_return, state);
}

void service_with_special_namesAsyncClient::key(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  key(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::key(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      keyT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      keyT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_key() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_key(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_key(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback625 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  key(rpcOptions, std::move(callback625));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_key(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_key() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_key(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_key(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise626;
  auto future627 = promise626.getFuture();
  auto callback628 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise626), recv_wrapped_key, channel_);
  key(rpcOptions, std::move(callback628));
  return future627;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_key(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise629;
  auto future630 = promise629.getFuture();
  auto callback631 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise629), recv_wrapped_key, channel_);
  key(rpcOptions, std::move(callback631));
  return future630;
}

void service_with_special_namesAsyncClient::key(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  key(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_key(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_keyT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_keyT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_key(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_key(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_key(::apache::thrift::ClientReceiveState& state) {
  return recv_key(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_key(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_key(_return, state);
}

void service_with_special_namesAsyncClient::keys(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  keys(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::keys(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      keysT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      keysT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_keys() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_keys(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_keys(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback632 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  keys(rpcOptions, std::move(callback632));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_keys(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_keys() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_keys(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_keys(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise633;
  auto future634 = promise633.getFuture();
  auto callback635 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise633), recv_wrapped_keys, channel_);
  keys(rpcOptions, std::move(callback635));
  return future634;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_keys(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise636;
  auto future637 = promise636.getFuture();
  auto callback638 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise636), recv_wrapped_keys, channel_);
  keys(rpcOptions, std::move(callback638));
  return future637;
}

void service_with_special_namesAsyncClient::keys(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  keys(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_keys(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_keysT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_keysT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_keys(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_keys(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_keys(::apache::thrift::ClientReceiveState& state) {
  return recv_keys(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_keys(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_keys(_return, state);
}

void service_with_special_namesAsyncClient::annotation(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  annotation(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::annotation(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      annotationT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      annotationT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_annotation() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_annotation(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_annotation(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback639 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  annotation(rpcOptions, std::move(callback639));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_annotation(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_annotation() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_annotation(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_annotation(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise640;
  auto future641 = promise640.getFuture();
  auto callback642 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise640), recv_wrapped_annotation, channel_);
  annotation(rpcOptions, std::move(callback642));
  return future641;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_annotation(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise643;
  auto future644 = promise643.getFuture();
  auto callback645 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise643), recv_wrapped_annotation, channel_);
  annotation(rpcOptions, std::move(callback645));
  return future644;
}

void service_with_special_namesAsyncClient::annotation(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  annotation(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_annotation(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_annotationT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_annotationT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_annotation(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_annotation(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_annotation(::apache::thrift::ClientReceiveState& state) {
  return recv_annotation(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_annotation(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_annotation(_return, state);
}

void service_with_special_namesAsyncClient::annotations(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  annotations(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::annotations(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      annotationsT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      annotationsT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_annotations() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_annotations(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_annotations(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback646 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  annotations(rpcOptions, std::move(callback646));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_annotations(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_annotations() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_annotations(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_annotations(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise647;
  auto future648 = promise647.getFuture();
  auto callback649 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise647), recv_wrapped_annotations, channel_);
  annotations(rpcOptions, std::move(callback649));
  return future648;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_annotations(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise650;
  auto future651 = promise650.getFuture();
  auto callback652 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise650), recv_wrapped_annotations, channel_);
  annotations(rpcOptions, std::move(callback652));
  return future651;
}

void service_with_special_namesAsyncClient::annotations(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  annotations(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_annotations(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_annotationsT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_annotationsT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_annotations(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_annotations(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_annotations(::apache::thrift::ClientReceiveState& state) {
  return recv_annotations(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_annotations(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_annotations(_return, state);
}

void service_with_special_namesAsyncClient::member(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  member(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::member(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      memberT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      memberT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_member() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_member(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_member(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback653 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  member(rpcOptions, std::move(callback653));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_member(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_member() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_member(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_member(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise654;
  auto future655 = promise654.getFuture();
  auto callback656 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise654), recv_wrapped_member, channel_);
  member(rpcOptions, std::move(callback656));
  return future655;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_member(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise657;
  auto future658 = promise657.getFuture();
  auto callback659 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise657), recv_wrapped_member, channel_);
  member(rpcOptions, std::move(callback659));
  return future658;
}

void service_with_special_namesAsyncClient::member(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  member(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_member(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_memberT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_memberT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_member(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_member(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_member(::apache::thrift::ClientReceiveState& state) {
  return recv_member(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_member(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_member(_return, state);
}

void service_with_special_namesAsyncClient::members(std::unique_ptr<apache::thrift::RequestCallback> callback) {
  ::apache::thrift::RpcOptions rpcOptions;
  members(rpcOptions, std::move(callback));
}

void service_with_special_namesAsyncClient::members(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      membersT(&writer, rpcOptions, std::move(callback));
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      membersT(&writer, rpcOptions, std::move(callback));
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t service_with_special_namesAsyncClient::sync_members() {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_members(rpcOptions);
}

int32_t service_with_special_namesAsyncClient::sync_members(apache::thrift::RpcOptions& rpcOptions) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback660 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  members(rpcOptions, std::move(callback660));
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_members(_returnState);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_members() {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_members(rpcOptions);
}

folly::Future<int32_t> service_with_special_namesAsyncClient::future_members(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<int32_t> promise661;
  auto future662 = promise661.getFuture();
  auto callback663 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise661), recv_wrapped_members, channel_);
  members(rpcOptions, std::move(callback663));
  return future662;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> service_with_special_namesAsyncClient::header_future_members(apache::thrift::RpcOptions& rpcOptions) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise664;
  auto future665 = promise664.getFuture();
  auto callback666 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise664), recv_wrapped_members, channel_);
  members(rpcOptions, std::move(callback666));
  return future665;
}

void service_with_special_namesAsyncClient::members(std::function<void (::apache::thrift::ClientReceiveState&&)> callback) {
  members(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)));
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_wrapped_members(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_membersT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_membersT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t service_with_special_namesAsyncClient::recv_members(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_members(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t service_with_special_namesAsyncClient::recv_instance_members(::apache::thrift::ClientReceiveState& state) {
  return recv_members(state);
}

folly::exception_wrapper service_with_special_namesAsyncClient::recv_instance_wrapped_members(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_members(_return, state);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift