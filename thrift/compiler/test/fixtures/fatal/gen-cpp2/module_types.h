/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>


#include "thrift/compiler/test/fixtures/fatal/gen-cpp2/reflection_dep_B_types.h"
#include "thrift/compiler/test/fixtures/fatal/gen-cpp2/reflection_dep_C_types.h"
#include "thrift/test/fatal_custom_types.h"

namespace apache {
namespace thrift {
namespace accessor {
#ifndef APACHE_THRIFT_ACCESSOR_ui
#define APACHE_THRIFT_ACCESSOR_ui
APACHE_THRIFT_DEFINE_ACCESSOR(ui);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ud
#define APACHE_THRIFT_ACCESSOR_ud
APACHE_THRIFT_DEFINE_ACCESSOR(ud);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_us
#define APACHE_THRIFT_ACCESSOR_us
APACHE_THRIFT_DEFINE_ACCESSOR(us);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ue
#define APACHE_THRIFT_ACCESSOR_ue
APACHE_THRIFT_DEFINE_ACCESSOR(ue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ui_2
#define APACHE_THRIFT_ACCESSOR_ui_2
APACHE_THRIFT_DEFINE_ACCESSOR(ui_2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ud_2
#define APACHE_THRIFT_ACCESSOR_ud_2
APACHE_THRIFT_DEFINE_ACCESSOR(ud_2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_us_2
#define APACHE_THRIFT_ACCESSOR_us_2
APACHE_THRIFT_DEFINE_ACCESSOR(us_2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ue_2
#define APACHE_THRIFT_ACCESSOR_ue_2
APACHE_THRIFT_DEFINE_ACCESSOR(ue_2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ui_3
#define APACHE_THRIFT_ACCESSOR_ui_3
APACHE_THRIFT_DEFINE_ACCESSOR(ui_3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ud_3
#define APACHE_THRIFT_ACCESSOR_ud_3
APACHE_THRIFT_DEFINE_ACCESSOR(ud_3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_us_3
#define APACHE_THRIFT_ACCESSOR_us_3
APACHE_THRIFT_DEFINE_ACCESSOR(us_3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ue_3
#define APACHE_THRIFT_ACCESSOR_ue_3
APACHE_THRIFT_DEFINE_ACCESSOR(ue_3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a
#define APACHE_THRIFT_ACCESSOR_a
APACHE_THRIFT_DEFINE_ACCESSOR(a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_b
#define APACHE_THRIFT_ACCESSOR_b
APACHE_THRIFT_DEFINE_ACCESSOR(b);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_i
#define APACHE_THRIFT_ACCESSOR_i
APACHE_THRIFT_DEFINE_ACCESSOR(i);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_d
#define APACHE_THRIFT_ACCESSOR_d
APACHE_THRIFT_DEFINE_ACCESSOR(d);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_s
#define APACHE_THRIFT_ACCESSOR_s
APACHE_THRIFT_DEFINE_ACCESSOR(s);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_e
#define APACHE_THRIFT_ACCESSOR_e
APACHE_THRIFT_DEFINE_ACCESSOR(e);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a
#define APACHE_THRIFT_ACCESSOR_a
APACHE_THRIFT_DEFINE_ACCESSOR(a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_c
#define APACHE_THRIFT_ACCESSOR_c
APACHE_THRIFT_DEFINE_ACCESSOR(c);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_d
#define APACHE_THRIFT_ACCESSOR_d
APACHE_THRIFT_DEFINE_ACCESSOR(d);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a
#define APACHE_THRIFT_ACCESSOR_a
APACHE_THRIFT_DEFINE_ACCESSOR(a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_b
#define APACHE_THRIFT_ACCESSOR_b
APACHE_THRIFT_DEFINE_ACCESSOR(b);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_c
#define APACHE_THRIFT_ACCESSOR_c
APACHE_THRIFT_DEFINE_ACCESSOR(c);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_d
#define APACHE_THRIFT_ACCESSOR_d
APACHE_THRIFT_DEFINE_ACCESSOR(d);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_e
#define APACHE_THRIFT_ACCESSOR_e
APACHE_THRIFT_DEFINE_ACCESSOR(e);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_f
#define APACHE_THRIFT_ACCESSOR_f
APACHE_THRIFT_DEFINE_ACCESSOR(f);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_g
#define APACHE_THRIFT_ACCESSOR_g
APACHE_THRIFT_DEFINE_ACCESSOR(g);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_h
#define APACHE_THRIFT_ACCESSOR_h
APACHE_THRIFT_DEFINE_ACCESSOR(h);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_i
#define APACHE_THRIFT_ACCESSOR_i
APACHE_THRIFT_DEFINE_ACCESSOR(i);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_j
#define APACHE_THRIFT_ACCESSOR_j
APACHE_THRIFT_DEFINE_ACCESSOR(j);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_j1
#define APACHE_THRIFT_ACCESSOR_j1
APACHE_THRIFT_DEFINE_ACCESSOR(j1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_j2
#define APACHE_THRIFT_ACCESSOR_j2
APACHE_THRIFT_DEFINE_ACCESSOR(j2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_j3
#define APACHE_THRIFT_ACCESSOR_j3
APACHE_THRIFT_DEFINE_ACCESSOR(j3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_k
#define APACHE_THRIFT_ACCESSOR_k
APACHE_THRIFT_DEFINE_ACCESSOR(k);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_k1
#define APACHE_THRIFT_ACCESSOR_k1
APACHE_THRIFT_DEFINE_ACCESSOR(k1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_k2
#define APACHE_THRIFT_ACCESSOR_k2
APACHE_THRIFT_DEFINE_ACCESSOR(k2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_k3
#define APACHE_THRIFT_ACCESSOR_k3
APACHE_THRIFT_DEFINE_ACCESSOR(k3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_l
#define APACHE_THRIFT_ACCESSOR_l
APACHE_THRIFT_DEFINE_ACCESSOR(l);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_l1
#define APACHE_THRIFT_ACCESSOR_l1
APACHE_THRIFT_DEFINE_ACCESSOR(l1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_l2
#define APACHE_THRIFT_ACCESSOR_l2
APACHE_THRIFT_DEFINE_ACCESSOR(l2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_l3
#define APACHE_THRIFT_ACCESSOR_l3
APACHE_THRIFT_DEFINE_ACCESSOR(l3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_m1
#define APACHE_THRIFT_ACCESSOR_m1
APACHE_THRIFT_DEFINE_ACCESSOR(m1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_m2
#define APACHE_THRIFT_ACCESSOR_m2
APACHE_THRIFT_DEFINE_ACCESSOR(m2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_m3
#define APACHE_THRIFT_ACCESSOR_m3
APACHE_THRIFT_DEFINE_ACCESSOR(m3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_n1
#define APACHE_THRIFT_ACCESSOR_n1
APACHE_THRIFT_DEFINE_ACCESSOR(n1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_n2
#define APACHE_THRIFT_ACCESSOR_n2
APACHE_THRIFT_DEFINE_ACCESSOR(n2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_n3
#define APACHE_THRIFT_ACCESSOR_n3
APACHE_THRIFT_DEFINE_ACCESSOR(n3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_o1
#define APACHE_THRIFT_ACCESSOR_o1
APACHE_THRIFT_DEFINE_ACCESSOR(o1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_o2
#define APACHE_THRIFT_ACCESSOR_o2
APACHE_THRIFT_DEFINE_ACCESSOR(o2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_o3
#define APACHE_THRIFT_ACCESSOR_o3
APACHE_THRIFT_DEFINE_ACCESSOR(o3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field0
#define APACHE_THRIFT_ACCESSOR_field0
APACHE_THRIFT_DEFINE_ACCESSOR(field0);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field1
#define APACHE_THRIFT_ACCESSOR_field1
APACHE_THRIFT_DEFINE_ACCESSOR(field1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field2
#define APACHE_THRIFT_ACCESSOR_field2
APACHE_THRIFT_DEFINE_ACCESSOR(field2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field3
#define APACHE_THRIFT_ACCESSOR_field3
APACHE_THRIFT_DEFINE_ACCESSOR(field3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field4
#define APACHE_THRIFT_ACCESSOR_field4
APACHE_THRIFT_DEFINE_ACCESSOR(field4);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field5
#define APACHE_THRIFT_ACCESSOR_field5
APACHE_THRIFT_DEFINE_ACCESSOR(field5);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldA
#define APACHE_THRIFT_ACCESSOR_fieldA
APACHE_THRIFT_DEFINE_ACCESSOR(fieldA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldB
#define APACHE_THRIFT_ACCESSOR_fieldB
APACHE_THRIFT_DEFINE_ACCESSOR(fieldB);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldC
#define APACHE_THRIFT_ACCESSOR_fieldC
APACHE_THRIFT_DEFINE_ACCESSOR(fieldC);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldD
#define APACHE_THRIFT_ACCESSOR_fieldD
APACHE_THRIFT_DEFINE_ACCESSOR(fieldD);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldE
#define APACHE_THRIFT_ACCESSOR_fieldE
APACHE_THRIFT_DEFINE_ACCESSOR(fieldE);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldF
#define APACHE_THRIFT_ACCESSOR_fieldF
APACHE_THRIFT_DEFINE_ACCESSOR(fieldF);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldG
#define APACHE_THRIFT_ACCESSOR_fieldG
APACHE_THRIFT_DEFINE_ACCESSOR(fieldG);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldA
#define APACHE_THRIFT_ACCESSOR_fieldA
APACHE_THRIFT_DEFINE_ACCESSOR(fieldA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldB
#define APACHE_THRIFT_ACCESSOR_fieldB
APACHE_THRIFT_DEFINE_ACCESSOR(fieldB);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldC
#define APACHE_THRIFT_ACCESSOR_fieldC
APACHE_THRIFT_DEFINE_ACCESSOR(fieldC);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldD
#define APACHE_THRIFT_ACCESSOR_fieldD
APACHE_THRIFT_DEFINE_ACCESSOR(fieldD);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldE
#define APACHE_THRIFT_ACCESSOR_fieldE
APACHE_THRIFT_DEFINE_ACCESSOR(fieldE);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldF
#define APACHE_THRIFT_ACCESSOR_fieldF
APACHE_THRIFT_DEFINE_ACCESSOR(fieldF);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldG
#define APACHE_THRIFT_ACCESSOR_fieldG
APACHE_THRIFT_DEFINE_ACCESSOR(fieldG);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldH
#define APACHE_THRIFT_ACCESSOR_fieldH
APACHE_THRIFT_DEFINE_ACCESSOR(fieldH);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldI
#define APACHE_THRIFT_ACCESSOR_fieldI
APACHE_THRIFT_DEFINE_ACCESSOR(fieldI);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldJ
#define APACHE_THRIFT_ACCESSOR_fieldJ
APACHE_THRIFT_DEFINE_ACCESSOR(fieldJ);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldK
#define APACHE_THRIFT_ACCESSOR_fieldK
APACHE_THRIFT_DEFINE_ACCESSOR(fieldK);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldL
#define APACHE_THRIFT_ACCESSOR_fieldL
APACHE_THRIFT_DEFINE_ACCESSOR(fieldL);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldM
#define APACHE_THRIFT_ACCESSOR_fieldM
APACHE_THRIFT_DEFINE_ACCESSOR(fieldM);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldN
#define APACHE_THRIFT_ACCESSOR_fieldN
APACHE_THRIFT_DEFINE_ACCESSOR(fieldN);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldO
#define APACHE_THRIFT_ACCESSOR_fieldO
APACHE_THRIFT_DEFINE_ACCESSOR(fieldO);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldP
#define APACHE_THRIFT_ACCESSOR_fieldP
APACHE_THRIFT_DEFINE_ACCESSOR(fieldP);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldQ
#define APACHE_THRIFT_ACCESSOR_fieldQ
APACHE_THRIFT_DEFINE_ACCESSOR(fieldQ);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldR
#define APACHE_THRIFT_ACCESSOR_fieldR
APACHE_THRIFT_DEFINE_ACCESSOR(fieldR);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field0
#define APACHE_THRIFT_ACCESSOR_field0
APACHE_THRIFT_DEFINE_ACCESSOR(field0);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field1
#define APACHE_THRIFT_ACCESSOR_field1
APACHE_THRIFT_DEFINE_ACCESSOR(field1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field2
#define APACHE_THRIFT_ACCESSOR_field2
APACHE_THRIFT_DEFINE_ACCESSOR(field2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field3
#define APACHE_THRIFT_ACCESSOR_field3
APACHE_THRIFT_DEFINE_ACCESSOR(field3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field0
#define APACHE_THRIFT_ACCESSOR_field0
APACHE_THRIFT_DEFINE_ACCESSOR(field0);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field1
#define APACHE_THRIFT_ACCESSOR_field1
APACHE_THRIFT_DEFINE_ACCESSOR(field1);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field2
#define APACHE_THRIFT_ACCESSOR_field2
APACHE_THRIFT_DEFINE_ACCESSOR(field2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field3
#define APACHE_THRIFT_ACCESSOR_field3
APACHE_THRIFT_DEFINE_ACCESSOR(field3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field4
#define APACHE_THRIFT_ACCESSOR_field4
APACHE_THRIFT_DEFINE_ACCESSOR(field4);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_bi
#define APACHE_THRIFT_ACCESSOR_bi
APACHE_THRIFT_DEFINE_ACCESSOR(bi);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_b
#define APACHE_THRIFT_ACCESSOR_b
APACHE_THRIFT_DEFINE_ACCESSOR(b);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_c
#define APACHE_THRIFT_ACCESSOR_c
APACHE_THRIFT_DEFINE_ACCESSOR(c);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_i_a
#define APACHE_THRIFT_ACCESSOR_i_a
APACHE_THRIFT_DEFINE_ACCESSOR(i_a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_b
#define APACHE_THRIFT_ACCESSOR_b
APACHE_THRIFT_DEFINE_ACCESSOR(b);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_c
#define APACHE_THRIFT_ACCESSOR_c
APACHE_THRIFT_DEFINE_ACCESSOR(c);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_i_a
#define APACHE_THRIFT_ACCESSOR_i_a
APACHE_THRIFT_DEFINE_ACCESSOR(i_a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a
#define APACHE_THRIFT_ACCESSOR_a
APACHE_THRIFT_DEFINE_ACCESSOR(a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_get
#define APACHE_THRIFT_ACCESSOR_get
APACHE_THRIFT_DEFINE_ACCESSOR(get);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_getter
#define APACHE_THRIFT_ACCESSOR_getter
APACHE_THRIFT_DEFINE_ACCESSOR(getter);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_lists
#define APACHE_THRIFT_ACCESSOR_lists
APACHE_THRIFT_DEFINE_ACCESSOR(lists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_maps
#define APACHE_THRIFT_ACCESSOR_maps
APACHE_THRIFT_DEFINE_ACCESSOR(maps);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name_to_value
#define APACHE_THRIFT_ACCESSOR_name_to_value
APACHE_THRIFT_DEFINE_ACCESSOR(name_to_value);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_names
#define APACHE_THRIFT_ACCESSOR_names
APACHE_THRIFT_DEFINE_ACCESSOR(names);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_prefix_tree
#define APACHE_THRIFT_ACCESSOR_prefix_tree
APACHE_THRIFT_DEFINE_ACCESSOR(prefix_tree);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_sets
#define APACHE_THRIFT_ACCESSOR_sets
APACHE_THRIFT_DEFINE_ACCESSOR(sets);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_setter
#define APACHE_THRIFT_ACCESSOR_setter
APACHE_THRIFT_DEFINE_ACCESSOR(setter);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_str
#define APACHE_THRIFT_ACCESSOR_str
APACHE_THRIFT_DEFINE_ACCESSOR(str);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_strings
#define APACHE_THRIFT_ACCESSOR_strings
APACHE_THRIFT_DEFINE_ACCESSOR(strings);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_value
#define APACHE_THRIFT_ACCESSOR_value
APACHE_THRIFT_DEFINE_ACCESSOR(value);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_value_to_name
#define APACHE_THRIFT_ACCESSOR_value_to_name
APACHE_THRIFT_DEFINE_ACCESSOR(value_to_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_values
#define APACHE_THRIFT_ACCESSOR_values
APACHE_THRIFT_DEFINE_ACCESSOR(values);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_id
#define APACHE_THRIFT_ACCESSOR_id
APACHE_THRIFT_DEFINE_ACCESSOR(id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ids
#define APACHE_THRIFT_ACCESSOR_ids
APACHE_THRIFT_DEFINE_ACCESSOR(ids);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_descriptor
#define APACHE_THRIFT_ACCESSOR_descriptor
APACHE_THRIFT_DEFINE_ACCESSOR(descriptor);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_descriptors
#define APACHE_THRIFT_ACCESSOR_descriptors
APACHE_THRIFT_DEFINE_ACCESSOR(descriptors);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_key
#define APACHE_THRIFT_ACCESSOR_key
APACHE_THRIFT_DEFINE_ACCESSOR(key);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_keys
#define APACHE_THRIFT_ACCESSOR_keys
APACHE_THRIFT_DEFINE_ACCESSOR(keys);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_annotation
#define APACHE_THRIFT_ACCESSOR_annotation
APACHE_THRIFT_DEFINE_ACCESSOR(annotation);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_annotations
#define APACHE_THRIFT_ACCESSOR_annotations
APACHE_THRIFT_DEFINE_ACCESSOR(annotations);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_member
#define APACHE_THRIFT_ACCESSOR_member
APACHE_THRIFT_DEFINE_ACCESSOR(member);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_members
#define APACHE_THRIFT_ACCESSOR_members
APACHE_THRIFT_DEFINE_ACCESSOR(members);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field
#define APACHE_THRIFT_ACCESSOR_field
APACHE_THRIFT_DEFINE_ACCESSOR(field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fields
#define APACHE_THRIFT_ACCESSOR_fields
APACHE_THRIFT_DEFINE_ACCESSOR(fields);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_get
#define APACHE_THRIFT_ACCESSOR_get
APACHE_THRIFT_DEFINE_ACCESSOR(get);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_getter
#define APACHE_THRIFT_ACCESSOR_getter
APACHE_THRIFT_DEFINE_ACCESSOR(getter);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_lists
#define APACHE_THRIFT_ACCESSOR_lists
APACHE_THRIFT_DEFINE_ACCESSOR(lists);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_maps
#define APACHE_THRIFT_ACCESSOR_maps
APACHE_THRIFT_DEFINE_ACCESSOR(maps);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name_to_value
#define APACHE_THRIFT_ACCESSOR_name_to_value
APACHE_THRIFT_DEFINE_ACCESSOR(name_to_value);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_names
#define APACHE_THRIFT_ACCESSOR_names
APACHE_THRIFT_DEFINE_ACCESSOR(names);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_prefix_tree
#define APACHE_THRIFT_ACCESSOR_prefix_tree
APACHE_THRIFT_DEFINE_ACCESSOR(prefix_tree);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_sets
#define APACHE_THRIFT_ACCESSOR_sets
APACHE_THRIFT_DEFINE_ACCESSOR(sets);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_setter
#define APACHE_THRIFT_ACCESSOR_setter
APACHE_THRIFT_DEFINE_ACCESSOR(setter);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_str
#define APACHE_THRIFT_ACCESSOR_str
APACHE_THRIFT_DEFINE_ACCESSOR(str);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_strings
#define APACHE_THRIFT_ACCESSOR_strings
APACHE_THRIFT_DEFINE_ACCESSOR(strings);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_value
#define APACHE_THRIFT_ACCESSOR_value
APACHE_THRIFT_DEFINE_ACCESSOR(value);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_value_to_name
#define APACHE_THRIFT_ACCESSOR_value_to_name
APACHE_THRIFT_DEFINE_ACCESSOR(value_to_name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_values
#define APACHE_THRIFT_ACCESSOR_values
APACHE_THRIFT_DEFINE_ACCESSOR(values);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_id
#define APACHE_THRIFT_ACCESSOR_id
APACHE_THRIFT_DEFINE_ACCESSOR(id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ids
#define APACHE_THRIFT_ACCESSOR_ids
APACHE_THRIFT_DEFINE_ACCESSOR(ids);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_descriptor
#define APACHE_THRIFT_ACCESSOR_descriptor
APACHE_THRIFT_DEFINE_ACCESSOR(descriptor);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_descriptors
#define APACHE_THRIFT_ACCESSOR_descriptors
APACHE_THRIFT_DEFINE_ACCESSOR(descriptors);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_key
#define APACHE_THRIFT_ACCESSOR_key
APACHE_THRIFT_DEFINE_ACCESSOR(key);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_keys
#define APACHE_THRIFT_ACCESSOR_keys
APACHE_THRIFT_DEFINE_ACCESSOR(keys);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_annotation
#define APACHE_THRIFT_ACCESSOR_annotation
APACHE_THRIFT_DEFINE_ACCESSOR(annotation);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_annotations
#define APACHE_THRIFT_ACCESSOR_annotations
APACHE_THRIFT_DEFINE_ACCESSOR(annotations);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_member
#define APACHE_THRIFT_ACCESSOR_member
APACHE_THRIFT_DEFINE_ACCESSOR(member);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_members
#define APACHE_THRIFT_ACCESSOR_members
APACHE_THRIFT_DEFINE_ACCESSOR(members);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_field
#define APACHE_THRIFT_ACCESSOR_field
APACHE_THRIFT_DEFINE_ACCESSOR(field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fields
#define APACHE_THRIFT_ACCESSOR_fields
APACHE_THRIFT_DEFINE_ACCESSOR(fields);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_real
#define APACHE_THRIFT_ACCESSOR_real
APACHE_THRIFT_DEFINE_ACCESSOR(real);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fake
#define APACHE_THRIFT_ACCESSOR_fake
APACHE_THRIFT_DEFINE_ACCESSOR(fake);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_number
#define APACHE_THRIFT_ACCESSOR_number
APACHE_THRIFT_DEFINE_ACCESSOR(number);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_result
#define APACHE_THRIFT_ACCESSOR_result
APACHE_THRIFT_DEFINE_ACCESSOR(result);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_phrase
#define APACHE_THRIFT_ACCESSOR_phrase
APACHE_THRIFT_DEFINE_ACCESSOR(phrase);
#endif
} // namespace accessor
} // namespace thrift
} // namespace apache

// BEGIN declare_enums
namespace test_cpp2 { namespace cpp_reflection {

enum class enum1 {
  field0 = 0,
  field1 = 1,
  field2 = 2
};




enum class enum2 {
  field0_2 = 0,
  field1_2 = 1,
  field2_2 = 2
};




enum class enum3 {
  field0_3 = 0,
  field1_3 = 1
};




enum class enum_with_special_names {
  get = 0,
  getter = 1,
  lists = 2,
  maps = 3,
  name = 4,
  name_to_value = 5,
  names = 6,
  prefix_tree = 7,
  sets = 8,
  setter = 9,
  str = 10,
  strings = 11,
  type = 12,
  value = 13,
  value_to_name = 14,
  values = 15,
  id = 16,
  ids = 17,
  descriptor = 18,
  descriptors = 19,
  key = 20,
  keys = 21,
  annotation = 22,
  annotations = 23,
  member = 24,
  members = 25,
  field = 26,
  fields = 27
};




}} // test_cpp2::cpp_reflection
namespace std {


template<> struct hash<typename ::test_cpp2::cpp_reflection::enum1> : public apache::thrift::detail::enum_hash<typename ::test_cpp2::cpp_reflection::enum1> {};
template<> struct equal_to<typename ::test_cpp2::cpp_reflection::enum1> : public apache::thrift::detail::enum_equal_to<typename ::test_cpp2::cpp_reflection::enum1> {};


template<> struct hash<typename ::test_cpp2::cpp_reflection::enum2> : public apache::thrift::detail::enum_hash<typename ::test_cpp2::cpp_reflection::enum2> {};
template<> struct equal_to<typename ::test_cpp2::cpp_reflection::enum2> : public apache::thrift::detail::enum_equal_to<typename ::test_cpp2::cpp_reflection::enum2> {};


template<> struct hash<typename ::test_cpp2::cpp_reflection::enum3> : public apache::thrift::detail::enum_hash<typename ::test_cpp2::cpp_reflection::enum3> {};
template<> struct equal_to<typename ::test_cpp2::cpp_reflection::enum3> : public apache::thrift::detail::enum_equal_to<typename ::test_cpp2::cpp_reflection::enum3> {};


template<> struct hash<typename ::test_cpp2::cpp_reflection::enum_with_special_names> : public apache::thrift::detail::enum_hash<typename ::test_cpp2::cpp_reflection::enum_with_special_names> {};
template<> struct equal_to<typename ::test_cpp2::cpp_reflection::enum_with_special_names> : public apache::thrift::detail::enum_equal_to<typename ::test_cpp2::cpp_reflection::enum_with_special_names> {};


} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage<::test_cpp2::cpp_reflection::enum1>;

template <> struct TEnumTraits<::test_cpp2::cpp_reflection::enum1> {
  using type = ::test_cpp2::cpp_reflection::enum1;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::field0; }
  static constexpr type max() { return type::field2; }
};


template <> struct TEnumDataStorage<::test_cpp2::cpp_reflection::enum2>;

template <> struct TEnumTraits<::test_cpp2::cpp_reflection::enum2> {
  using type = ::test_cpp2::cpp_reflection::enum2;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::field0_2; }
  static constexpr type max() { return type::field2_2; }
};


template <> struct TEnumDataStorage<::test_cpp2::cpp_reflection::enum3>;

template <> struct TEnumTraits<::test_cpp2::cpp_reflection::enum3> {
  using type = ::test_cpp2::cpp_reflection::enum3;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::field0_3; }
  static constexpr type max() { return type::field1_3; }
};


template <> struct TEnumDataStorage<::test_cpp2::cpp_reflection::enum_with_special_names>;

template <> struct TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names> {
  using type = ::test_cpp2::cpp_reflection::enum_with_special_names;

  static constexpr std::size_t const size = 28;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::get; }
  static constexpr type max() { return type::fields; }
};


}} // apache::thrift

namespace test_cpp2 { namespace cpp_reflection {

using _enum1_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<enum1>;
extern const _enum1_EnumMapFactory::ValuesToNamesMapType _enum1_VALUES_TO_NAMES;
extern const _enum1_EnumMapFactory::NamesToValuesMapType _enum1_NAMES_TO_VALUES;

using _enum2_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<enum2>;
extern const _enum2_EnumMapFactory::ValuesToNamesMapType _enum2_VALUES_TO_NAMES;
extern const _enum2_EnumMapFactory::NamesToValuesMapType _enum2_NAMES_TO_VALUES;

using _enum3_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<enum3>;
extern const _enum3_EnumMapFactory::ValuesToNamesMapType _enum3_VALUES_TO_NAMES;
extern const _enum3_EnumMapFactory::NamesToValuesMapType _enum3_NAMES_TO_VALUES;

using _enum_with_special_names_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<enum_with_special_names>;
extern const _enum_with_special_names_EnumMapFactory::ValuesToNamesMapType _enum_with_special_names_VALUES_TO_NAMES;
extern const _enum_with_special_names_EnumMapFactory::NamesToValuesMapType _enum_with_special_names_NAMES_TO_VALUES;

}} // test_cpp2::cpp_reflection

// END declare_enums
// BEGIN struct_indirection
namespace test_cpp2 { namespace cpp_reflection {
struct apache_thrift_indirection_module_HasANumber {
  template <typename T> static auto&& get(T&& x) {
    return std::forward<T>(x).number;
  }

  template <typename T> static auto&& get(T const&& x) {
    return std::forward<T>(x).number;
  }
};

struct apache_thrift_indirection_module_HasAResult {
  template <typename T> static auto&& get(T&& x) {
    return std::forward<T>(x).foo().result();
  }

  template <typename T> static auto&& get(T const&& x) {
    return std::forward<T>(x).foo().result();
  }
};

struct apache_thrift_indirection_module_HasAPhrase {
  template <typename T> static auto&& get(T&& x) {
    return std::forward<T>(x).phrase;
  }

  template <typename T> static auto&& get(T const&& x) {
    return std::forward<T>(x).phrase;
  }
};


}} // test_cpp2::cpp_reflection
// END struct_indirection
// BEGIN forward_declare
namespace test_cpp2 { namespace cpp_reflection {
class union1;
class union2;
class union3;
class structA;
class unionA;
class structB;
class structC;
class struct1;
class struct2;
class struct3;
class struct4;
class struct5;
class struct_binary;
class dep_A_struct;
class dep_B_struct;
class annotated;
class union_with_special_names;
class struct_with_special_names;
class struct_with_indirections;
}} // test_cpp2::cpp_reflection
// END forward_declare
// BEGIN typedefs
namespace test_cpp2 { namespace cpp_reflection {
typedef test_cpp_reflection::custom_structA my_structA;
typedef CppFakeI32 FakeI32;
typedef CppHasANumber HasANumber;
typedef CppHasAResult HasAResult;
typedef CppHasAPhrase HasAPhrase;

}} // test_cpp2::cpp_reflection
// END typedefs
// BEGIN hash_and_equal_to
// END hash_and_equal_to
namespace test_cpp2 { namespace cpp_reflection {
class union1 final : private apache::thrift::detail::st::ComparisonOperators<union1> {
 public:
  enum Type {
    __EMPTY__ = 0,
    ui = 1,
    ud = 2,
    us = 3,
    ue = 4,
  } ;

  union1()
      : type_(Type::__EMPTY__) {}

  union1(union1&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui:
      {
        set_ui(std::move(rhs.value_.ui));
        break;
      }
      case Type::ud:
      {
        set_ud(std::move(rhs.value_.ud));
        break;
      }
      case Type::us:
      {
        set_us(std::move(rhs.value_.us));
        break;
      }
      case Type::ue:
      {
        set_ue(std::move(rhs.value_.ue));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  union1(const union1& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui:
      {
        set_ui(rhs.value_.ui);
        break;
      }
      case Type::ud:
      {
        set_ud(rhs.value_.ud);
        break;
      }
      case Type::us:
      {
        set_us(rhs.value_.us);
        break;
      }
      case Type::ue:
      {
        set_ue(rhs.value_.ue);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  union1& operator=(union1&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui:
      {
        set_ui(std::move(rhs.value_.ui));
        break;
      }
      case Type::ud:
      {
        set_ud(std::move(rhs.value_.ud));
        break;
      }
      case Type::us:
      {
        set_us(std::move(rhs.value_.us));
        break;
      }
      case Type::ue:
      {
        set_ue(std::move(rhs.value_.ue));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  union1& operator=(const union1& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui:
      {
        set_ui(rhs.value_.ui);
        break;
      }
      case Type::ud:
      {
        set_ud(rhs.value_.ud);
        break;
      }
      case Type::us:
      {
        set_us(rhs.value_.us);
        break;
      }
      case Type::ue:
      {
        set_ue(rhs.value_.ue);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~union1() {
    __clear();
  }
  union storage_type {
    int32_t ui;
    double ud;
    ::std::string us;
     ::test_cpp2::cpp_reflection::enum1 ue;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const union1& rhs) const;
  bool operator<(const union1& rhs) const;

  int32_t& set_ui(int32_t t = int32_t()) {
    __clear();
    type_ = Type::ui;
    ::new (std::addressof(value_.ui)) int32_t(t);
    return value_.ui;
  }

  double& set_ud(double t = double()) {
    __clear();
    type_ = Type::ud;
    ::new (std::addressof(value_.ud)) double(t);
    return value_.ud;
  }

  ::std::string& set_us(::std::string const &t) {
    __clear();
    type_ = Type::us;
    ::new (std::addressof(value_.us)) ::std::string(t);
    return value_.us;
  }

  ::std::string& set_us(::std::string&& t) {
    __clear();
    type_ = Type::us;
    ::new (std::addressof(value_.us)) ::std::string(std::move(t));
    return value_.us;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_us(T&&... t) {
    __clear();
    type_ = Type::us;
    ::new (std::addressof(value_.us)) ::std::string(std::forward<T>(t)...);
    return value_.us;
  }

   ::test_cpp2::cpp_reflection::enum1& set_ue( ::test_cpp2::cpp_reflection::enum1 t =  ::test_cpp2::cpp_reflection::enum1()) {
    __clear();
    type_ = Type::ue;
    ::new (std::addressof(value_.ue))  ::test_cpp2::cpp_reflection::enum1(t);
    return value_.ue;
  }

  int32_t const & get_ui() const {
    assert(type_ == Type::ui);
    return value_.ui;
  }

  double const & get_ud() const {
    assert(type_ == Type::ud);
    return value_.ud;
  }

  ::std::string const & get_us() const {
    assert(type_ == Type::us);
    return value_.us;
  }

   ::test_cpp2::cpp_reflection::enum1 const & get_ue() const {
    assert(type_ == Type::ue);
    return value_.ue;
  }

  int32_t & mutable_ui() {
    assert(type_ == Type::ui);
    return value_.ui;
  }

  double & mutable_ud() {
    assert(type_ == Type::ud);
    return value_.ud;
  }

  ::std::string & mutable_us() {
    assert(type_ == Type::us);
    return value_.us;
  }

   ::test_cpp2::cpp_reflection::enum1 & mutable_ue() {
    assert(type_ == Type::ue);
    return value_.ue;
  }

  int32_t move_ui() {
    assert(type_ == Type::ui);
    return std::move(value_.ui);
  }

  double move_ud() {
    assert(type_ == Type::ud);
    return std::move(value_.ud);
  }

  ::std::string move_us() {
    assert(type_ == Type::us);
    return std::move(value_.us);
  }

   ::test_cpp2::cpp_reflection::enum1 move_ue() {
    assert(type_ == Type::ue);
    return std::move(value_.ue);
  }

  Type getType() const { return type_; }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  Type type_;
  storage_type value_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< union1 >;
};

void swap(union1& a, union1& b);

template <class Protocol_>
uint32_t union1::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class union2 final : private apache::thrift::detail::st::ComparisonOperators<union2> {
 public:
  enum Type {
    __EMPTY__ = 0,
    ui_2 = 1,
    ud_2 = 2,
    us_2 = 3,
    ue_2 = 4,
  } ;

  union2()
      : type_(Type::__EMPTY__) {}

  union2(union2&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui_2:
      {
        set_ui_2(std::move(rhs.value_.ui_2));
        break;
      }
      case Type::ud_2:
      {
        set_ud_2(std::move(rhs.value_.ud_2));
        break;
      }
      case Type::us_2:
      {
        set_us_2(std::move(rhs.value_.us_2));
        break;
      }
      case Type::ue_2:
      {
        set_ue_2(std::move(rhs.value_.ue_2));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  union2(const union2& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui_2:
      {
        set_ui_2(rhs.value_.ui_2);
        break;
      }
      case Type::ud_2:
      {
        set_ud_2(rhs.value_.ud_2);
        break;
      }
      case Type::us_2:
      {
        set_us_2(rhs.value_.us_2);
        break;
      }
      case Type::ue_2:
      {
        set_ue_2(rhs.value_.ue_2);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  union2& operator=(union2&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui_2:
      {
        set_ui_2(std::move(rhs.value_.ui_2));
        break;
      }
      case Type::ud_2:
      {
        set_ud_2(std::move(rhs.value_.ud_2));
        break;
      }
      case Type::us_2:
      {
        set_us_2(std::move(rhs.value_.us_2));
        break;
      }
      case Type::ue_2:
      {
        set_ue_2(std::move(rhs.value_.ue_2));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  union2& operator=(const union2& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui_2:
      {
        set_ui_2(rhs.value_.ui_2);
        break;
      }
      case Type::ud_2:
      {
        set_ud_2(rhs.value_.ud_2);
        break;
      }
      case Type::us_2:
      {
        set_us_2(rhs.value_.us_2);
        break;
      }
      case Type::ue_2:
      {
        set_ue_2(rhs.value_.ue_2);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~union2() {
    __clear();
  }
  union storage_type {
    int32_t ui_2;
    double ud_2;
    ::std::string us_2;
     ::test_cpp2::cpp_reflection::enum1 ue_2;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const union2& rhs) const;
  bool operator<(const union2& rhs) const;

  int32_t& set_ui_2(int32_t t = int32_t()) {
    __clear();
    type_ = Type::ui_2;
    ::new (std::addressof(value_.ui_2)) int32_t(t);
    return value_.ui_2;
  }

  double& set_ud_2(double t = double()) {
    __clear();
    type_ = Type::ud_2;
    ::new (std::addressof(value_.ud_2)) double(t);
    return value_.ud_2;
  }

  ::std::string& set_us_2(::std::string const &t) {
    __clear();
    type_ = Type::us_2;
    ::new (std::addressof(value_.us_2)) ::std::string(t);
    return value_.us_2;
  }

  ::std::string& set_us_2(::std::string&& t) {
    __clear();
    type_ = Type::us_2;
    ::new (std::addressof(value_.us_2)) ::std::string(std::move(t));
    return value_.us_2;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_us_2(T&&... t) {
    __clear();
    type_ = Type::us_2;
    ::new (std::addressof(value_.us_2)) ::std::string(std::forward<T>(t)...);
    return value_.us_2;
  }

   ::test_cpp2::cpp_reflection::enum1& set_ue_2( ::test_cpp2::cpp_reflection::enum1 t =  ::test_cpp2::cpp_reflection::enum1()) {
    __clear();
    type_ = Type::ue_2;
    ::new (std::addressof(value_.ue_2))  ::test_cpp2::cpp_reflection::enum1(t);
    return value_.ue_2;
  }

  int32_t const & get_ui_2() const {
    assert(type_ == Type::ui_2);
    return value_.ui_2;
  }

  double const & get_ud_2() const {
    assert(type_ == Type::ud_2);
    return value_.ud_2;
  }

  ::std::string const & get_us_2() const {
    assert(type_ == Type::us_2);
    return value_.us_2;
  }

   ::test_cpp2::cpp_reflection::enum1 const & get_ue_2() const {
    assert(type_ == Type::ue_2);
    return value_.ue_2;
  }

  int32_t & mutable_ui_2() {
    assert(type_ == Type::ui_2);
    return value_.ui_2;
  }

  double & mutable_ud_2() {
    assert(type_ == Type::ud_2);
    return value_.ud_2;
  }

  ::std::string & mutable_us_2() {
    assert(type_ == Type::us_2);
    return value_.us_2;
  }

   ::test_cpp2::cpp_reflection::enum1 & mutable_ue_2() {
    assert(type_ == Type::ue_2);
    return value_.ue_2;
  }

  int32_t move_ui_2() {
    assert(type_ == Type::ui_2);
    return std::move(value_.ui_2);
  }

  double move_ud_2() {
    assert(type_ == Type::ud_2);
    return std::move(value_.ud_2);
  }

  ::std::string move_us_2() {
    assert(type_ == Type::us_2);
    return std::move(value_.us_2);
  }

   ::test_cpp2::cpp_reflection::enum1 move_ue_2() {
    assert(type_ == Type::ue_2);
    return std::move(value_.ue_2);
  }

  Type getType() const { return type_; }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  Type type_;
  storage_type value_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< union2 >;
};

void swap(union2& a, union2& b);

template <class Protocol_>
uint32_t union2::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class union3 final : private apache::thrift::detail::st::ComparisonOperators<union3> {
 public:
  enum Type {
    __EMPTY__ = 0,
    ui_3 = 1,
    ud_3 = 2,
    us_3 = 3,
    ue_3 = 4,
  } ;

  union3()
      : type_(Type::__EMPTY__) {}

  union3(union3&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui_3:
      {
        set_ui_3(std::move(rhs.value_.ui_3));
        break;
      }
      case Type::ud_3:
      {
        set_ud_3(std::move(rhs.value_.ud_3));
        break;
      }
      case Type::us_3:
      {
        set_us_3(std::move(rhs.value_.us_3));
        break;
      }
      case Type::ue_3:
      {
        set_ue_3(std::move(rhs.value_.ue_3));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  union3(const union3& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::ui_3:
      {
        set_ui_3(rhs.value_.ui_3);
        break;
      }
      case Type::ud_3:
      {
        set_ud_3(rhs.value_.ud_3);
        break;
      }
      case Type::us_3:
      {
        set_us_3(rhs.value_.us_3);
        break;
      }
      case Type::ue_3:
      {
        set_ue_3(rhs.value_.ue_3);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  union3& operator=(union3&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui_3:
      {
        set_ui_3(std::move(rhs.value_.ui_3));
        break;
      }
      case Type::ud_3:
      {
        set_ud_3(std::move(rhs.value_.ud_3));
        break;
      }
      case Type::us_3:
      {
        set_us_3(std::move(rhs.value_.us_3));
        break;
      }
      case Type::ue_3:
      {
        set_ue_3(std::move(rhs.value_.ue_3));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  union3& operator=(const union3& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::ui_3:
      {
        set_ui_3(rhs.value_.ui_3);
        break;
      }
      case Type::ud_3:
      {
        set_ud_3(rhs.value_.ud_3);
        break;
      }
      case Type::us_3:
      {
        set_us_3(rhs.value_.us_3);
        break;
      }
      case Type::ue_3:
      {
        set_ue_3(rhs.value_.ue_3);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~union3() {
    __clear();
  }
  union storage_type {
    int32_t ui_3;
    double ud_3;
    ::std::string us_3;
     ::test_cpp2::cpp_reflection::enum1 ue_3;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const union3& rhs) const;
  bool operator<(const union3& rhs) const;

  int32_t& set_ui_3(int32_t t = int32_t()) {
    __clear();
    type_ = Type::ui_3;
    ::new (std::addressof(value_.ui_3)) int32_t(t);
    return value_.ui_3;
  }

  double& set_ud_3(double t = double()) {
    __clear();
    type_ = Type::ud_3;
    ::new (std::addressof(value_.ud_3)) double(t);
    return value_.ud_3;
  }

  ::std::string& set_us_3(::std::string const &t) {
    __clear();
    type_ = Type::us_3;
    ::new (std::addressof(value_.us_3)) ::std::string(t);
    return value_.us_3;
  }

  ::std::string& set_us_3(::std::string&& t) {
    __clear();
    type_ = Type::us_3;
    ::new (std::addressof(value_.us_3)) ::std::string(std::move(t));
    return value_.us_3;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_us_3(T&&... t) {
    __clear();
    type_ = Type::us_3;
    ::new (std::addressof(value_.us_3)) ::std::string(std::forward<T>(t)...);
    return value_.us_3;
  }

   ::test_cpp2::cpp_reflection::enum1& set_ue_3( ::test_cpp2::cpp_reflection::enum1 t =  ::test_cpp2::cpp_reflection::enum1()) {
    __clear();
    type_ = Type::ue_3;
    ::new (std::addressof(value_.ue_3))  ::test_cpp2::cpp_reflection::enum1(t);
    return value_.ue_3;
  }

  int32_t const & get_ui_3() const {
    assert(type_ == Type::ui_3);
    return value_.ui_3;
  }

  double const & get_ud_3() const {
    assert(type_ == Type::ud_3);
    return value_.ud_3;
  }

  ::std::string const & get_us_3() const {
    assert(type_ == Type::us_3);
    return value_.us_3;
  }

   ::test_cpp2::cpp_reflection::enum1 const & get_ue_3() const {
    assert(type_ == Type::ue_3);
    return value_.ue_3;
  }

  int32_t & mutable_ui_3() {
    assert(type_ == Type::ui_3);
    return value_.ui_3;
  }

  double & mutable_ud_3() {
    assert(type_ == Type::ud_3);
    return value_.ud_3;
  }

  ::std::string & mutable_us_3() {
    assert(type_ == Type::us_3);
    return value_.us_3;
  }

   ::test_cpp2::cpp_reflection::enum1 & mutable_ue_3() {
    assert(type_ == Type::ue_3);
    return value_.ue_3;
  }

  int32_t move_ui_3() {
    assert(type_ == Type::ui_3);
    return std::move(value_.ui_3);
  }

  double move_ud_3() {
    assert(type_ == Type::ud_3);
    return std::move(value_.ud_3);
  }

  ::std::string move_us_3() {
    assert(type_ == Type::us_3);
    return std::move(value_.us_3);
  }

   ::test_cpp2::cpp_reflection::enum1 move_ue_3() {
    assert(type_ == Type::ue_3);
    return std::move(value_.ue_3);
  }

  Type getType() const { return type_; }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  Type type_;
  storage_type value_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< union3 >;
};

void swap(union3& a, union3& b);

template <class Protocol_>
uint32_t union3::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class structA final : private apache::thrift::detail::st::ComparisonOperators<structA> {
 public:

  structA() :
      a(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  structA(apache::thrift::FragileConstructor, int32_t a__arg, ::std::string b__arg);

  structA(structA&&) = default;

  structA(const structA&) = default;

  structA& operator=(structA&&) = default;

  structA& operator=(const structA&) = default;
  void __clear();
  int32_t a;
  ::std::string b;

  struct __isset {
    bool a;
    bool b;
  } __isset = {};
  bool operator==(const structA& rhs) const;
  bool operator<(const structA& rhs) const;

  int32_t get_a() const {
    return a;
  }

  int32_t& set_a(int32_t a_) {
    a = a_;
    __isset.a = true;
    return a;
  }

  const ::std::string& get_b() const& {
    return b;
  }

  ::std::string get_b() && {
    return std::move(b);
  }

  template <typename T_structA_b_struct_setter = ::std::string>
  ::std::string& set_b(T_structA_b_struct_setter&& b_) {
    b = std::forward<T_structA_b_struct_setter>(b_);
    __isset.b = true;
    return b;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< structA >;
};

void swap(structA& a, structA& b);

template <class Protocol_>
uint32_t structA::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class unionA final : private apache::thrift::detail::st::ComparisonOperators<unionA> {
 public:
  enum Type {
    __EMPTY__ = 0,
    i = 1,
    d = 2,
    s = 3,
    e = 4,
    a = 5,
  } ;

  unionA()
      : type_(Type::__EMPTY__) {}

  unionA(unionA&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::i:
      {
        set_i(std::move(rhs.value_.i));
        break;
      }
      case Type::d:
      {
        set_d(std::move(rhs.value_.d));
        break;
      }
      case Type::s:
      {
        set_s(std::move(rhs.value_.s));
        break;
      }
      case Type::e:
      {
        set_e(std::move(rhs.value_.e));
        break;
      }
      case Type::a:
      {
        set_a(std::move(rhs.value_.a));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  unionA(const unionA& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::i:
      {
        set_i(rhs.value_.i);
        break;
      }
      case Type::d:
      {
        set_d(rhs.value_.d);
        break;
      }
      case Type::s:
      {
        set_s(rhs.value_.s);
        break;
      }
      case Type::e:
      {
        set_e(rhs.value_.e);
        break;
      }
      case Type::a:
      {
        set_a(rhs.value_.a);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  unionA& operator=(unionA&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::i:
      {
        set_i(std::move(rhs.value_.i));
        break;
      }
      case Type::d:
      {
        set_d(std::move(rhs.value_.d));
        break;
      }
      case Type::s:
      {
        set_s(std::move(rhs.value_.s));
        break;
      }
      case Type::e:
      {
        set_e(std::move(rhs.value_.e));
        break;
      }
      case Type::a:
      {
        set_a(std::move(rhs.value_.a));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  unionA& operator=(const unionA& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::i:
      {
        set_i(rhs.value_.i);
        break;
      }
      case Type::d:
      {
        set_d(rhs.value_.d);
        break;
      }
      case Type::s:
      {
        set_s(rhs.value_.s);
        break;
      }
      case Type::e:
      {
        set_e(rhs.value_.e);
        break;
      }
      case Type::a:
      {
        set_a(rhs.value_.a);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~unionA() {
    __clear();
  }
  union storage_type {
    int32_t i;
    double d;
    ::std::string s;
     ::test_cpp2::cpp_reflection::enum1 e;
     ::test_cpp2::cpp_reflection::structA a;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const unionA& rhs) const;
  bool operator<(const unionA& rhs) const;

  int32_t& set_i(int32_t t = int32_t()) {
    __clear();
    type_ = Type::i;
    ::new (std::addressof(value_.i)) int32_t(t);
    return value_.i;
  }

  double& set_d(double t = double()) {
    __clear();
    type_ = Type::d;
    ::new (std::addressof(value_.d)) double(t);
    return value_.d;
  }

  ::std::string& set_s(::std::string const &t) {
    __clear();
    type_ = Type::s;
    ::new (std::addressof(value_.s)) ::std::string(t);
    return value_.s;
  }

  ::std::string& set_s(::std::string&& t) {
    __clear();
    type_ = Type::s;
    ::new (std::addressof(value_.s)) ::std::string(std::move(t));
    return value_.s;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_s(T&&... t) {
    __clear();
    type_ = Type::s;
    ::new (std::addressof(value_.s)) ::std::string(std::forward<T>(t)...);
    return value_.s;
  }

   ::test_cpp2::cpp_reflection::enum1& set_e( ::test_cpp2::cpp_reflection::enum1 t =  ::test_cpp2::cpp_reflection::enum1()) {
    __clear();
    type_ = Type::e;
    ::new (std::addressof(value_.e))  ::test_cpp2::cpp_reflection::enum1(t);
    return value_.e;
  }

   ::test_cpp2::cpp_reflection::structA& set_a( ::test_cpp2::cpp_reflection::structA const &t) {
    __clear();
    type_ = Type::a;
    ::new (std::addressof(value_.a))  ::test_cpp2::cpp_reflection::structA(t);
    return value_.a;
  }

   ::test_cpp2::cpp_reflection::structA& set_a( ::test_cpp2::cpp_reflection::structA&& t) {
    __clear();
    type_ = Type::a;
    ::new (std::addressof(value_.a))  ::test_cpp2::cpp_reflection::structA(std::move(t));
    return value_.a;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::test_cpp2::cpp_reflection::structA, T...>>  ::test_cpp2::cpp_reflection::structA& set_a(T&&... t) {
    __clear();
    type_ = Type::a;
    ::new (std::addressof(value_.a))  ::test_cpp2::cpp_reflection::structA(std::forward<T>(t)...);
    return value_.a;
  }

  int32_t const & get_i() const {
    assert(type_ == Type::i);
    return value_.i;
  }

  double const & get_d() const {
    assert(type_ == Type::d);
    return value_.d;
  }

  ::std::string const & get_s() const {
    assert(type_ == Type::s);
    return value_.s;
  }

   ::test_cpp2::cpp_reflection::enum1 const & get_e() const {
    assert(type_ == Type::e);
    return value_.e;
  }

   ::test_cpp2::cpp_reflection::structA const & get_a() const {
    assert(type_ == Type::a);
    return value_.a;
  }

  int32_t & mutable_i() {
    assert(type_ == Type::i);
    return value_.i;
  }

  double & mutable_d() {
    assert(type_ == Type::d);
    return value_.d;
  }

  ::std::string & mutable_s() {
    assert(type_ == Type::s);
    return value_.s;
  }

   ::test_cpp2::cpp_reflection::enum1 & mutable_e() {
    assert(type_ == Type::e);
    return value_.e;
  }

   ::test_cpp2::cpp_reflection::structA & mutable_a() {
    assert(type_ == Type::a);
    return value_.a;
  }

  int32_t move_i() {
    assert(type_ == Type::i);
    return std::move(value_.i);
  }

  double move_d() {
    assert(type_ == Type::d);
    return std::move(value_.d);
  }

  ::std::string move_s() {
    assert(type_ == Type::s);
    return std::move(value_.s);
  }

   ::test_cpp2::cpp_reflection::enum1 move_e() {
    assert(type_ == Type::e);
    return std::move(value_.e);
  }

   ::test_cpp2::cpp_reflection::structA move_a() {
    assert(type_ == Type::a);
    return std::move(value_.a);
  }

  Type getType() const { return type_; }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  Type type_;
  storage_type value_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< unionA >;
};

void swap(unionA& a, unionA& b);

template <class Protocol_>
uint32_t unionA::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class structB final : private apache::thrift::detail::st::ComparisonOperators<structB> {
 public:

  structB() :
      c(0),
      d(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  structB(apache::thrift::FragileConstructor, double c__arg, bool d__arg);

  structB(structB&&) = default;

  structB(const structB&) = default;

  structB& operator=(structB&&) = default;

  structB& operator=(const structB&) = default;
  void __clear();
  double c;
  bool d;

  struct __isset {
    bool c;
    bool d;
  } __isset = {};
  bool operator==(const structB& rhs) const;
  bool operator<(const structB& rhs) const;

  double get_c() const {
    return c;
  }

  double& set_c(double c_) {
    c = c_;
    __isset.c = true;
    return c;
  }

  bool get_d() const {
    return d;
  }

  bool& set_d(bool d_) {
    d = d_;
    __isset.d = true;
    return d;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< structB >;
};

void swap(structB& a, structB& b);

template <class Protocol_>
uint32_t structB::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class structC final : private apache::thrift::detail::st::ComparisonOperators<structC> {
 public:

  structC();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  structC(apache::thrift::FragileConstructor, int32_t a__arg, ::std::string b__arg, double c__arg, bool d__arg,  ::test_cpp2::cpp_reflection::enum1 e__arg,  ::test_cpp2::cpp_reflection::enum2 f__arg,  ::test_cpp2::cpp_reflection::union1 g__arg,  ::test_cpp2::cpp_reflection::unionA h__arg,  ::test_cpp2::cpp_reflection::unionA i__arg, ::std::vector<int32_t> j__arg, ::std::vector<int32_t> j1__arg, ::std::vector< ::test_cpp2::cpp_reflection::enum1> j2__arg, ::std::vector< ::test_cpp2::cpp_reflection::structA> j3__arg, ::std::set<int32_t> k__arg, ::std::set<int32_t> k1__arg, ::std::set< ::test_cpp2::cpp_reflection::enum2> k2__arg, ::std::set< ::test_cpp2::cpp_reflection::structB> k3__arg, ::std::map<int32_t, int32_t> l__arg, ::std::map<int32_t, int32_t> l1__arg, ::std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1> l2__arg, ::std::map<int32_t,  ::test_cpp2::cpp_reflection::structB> l3__arg, ::std::map< ::test_cpp2::cpp_reflection::enum1, int32_t> m1__arg, ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2> m2__arg, ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB> m3__arg, ::std::map<::std::string, int32_t> n1__arg, ::std::map<::std::string,  ::test_cpp2::cpp_reflection::enum1> n2__arg, ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB> n3__arg, ::std::map< ::test_cpp2::cpp_reflection::structA, int32_t> o1__arg, ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1> o2__arg, ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB> o3__arg);

  structC(structC&&) = default;

  structC(const structC&) = default;

  structC& operator=(structC&&) = default;

  structC& operator=(const structC&) = default;
  void __clear();

  ~structC();

  int32_t a;
  ::std::string b;
  double c;
  bool d;
   ::test_cpp2::cpp_reflection::enum1 e;
   ::test_cpp2::cpp_reflection::enum2 f;
   ::test_cpp2::cpp_reflection::union1 g;
   ::test_cpp2::cpp_reflection::unionA h;
   ::test_cpp2::cpp_reflection::unionA i;
  ::std::vector<int32_t> j;
  ::std::vector<int32_t> j1;
  ::std::vector< ::test_cpp2::cpp_reflection::enum1> j2;
  ::std::vector< ::test_cpp2::cpp_reflection::structA> j3;
  ::std::set<int32_t> k;
  ::std::set<int32_t> k1;
  ::std::set< ::test_cpp2::cpp_reflection::enum2> k2;
  ::std::set< ::test_cpp2::cpp_reflection::structB> k3;
  ::std::map<int32_t, int32_t> l;
  ::std::map<int32_t, int32_t> l1;
  ::std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1> l2;
  ::std::map<int32_t,  ::test_cpp2::cpp_reflection::structB> l3;
  ::std::map< ::test_cpp2::cpp_reflection::enum1, int32_t> m1;
  ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2> m2;
  ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB> m3;
  ::std::map<::std::string, int32_t> n1;
  ::std::map<::std::string,  ::test_cpp2::cpp_reflection::enum1> n2;
  ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB> n3;
  ::std::map< ::test_cpp2::cpp_reflection::structA, int32_t> o1;
  ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1> o2;
  ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB> o3;

  struct __isset {
    bool a;
    bool b;
    bool c;
    bool d;
    bool e;
    bool f;
    bool g;
    bool h;
    bool i;
    bool j;
    bool j1;
    bool j2;
    bool j3;
    bool k;
    bool k1;
    bool k2;
    bool k3;
    bool l;
    bool l1;
    bool l2;
    bool l3;
    bool m1;
    bool m2;
    bool m3;
    bool n1;
    bool n2;
    bool n3;
    bool o1;
    bool o2;
    bool o3;
  } __isset = {};
  bool operator==(const structC& rhs) const;
  bool operator<(const structC& rhs) const;

  int32_t get_a() const {
    return a;
  }

  int32_t& set_a(int32_t a_) {
    a = a_;
    __isset.a = true;
    return a;
  }

  const ::std::string& get_b() const& {
    return b;
  }

  ::std::string get_b() && {
    return std::move(b);
  }

  template <typename T_structC_b_struct_setter = ::std::string>
  ::std::string& set_b(T_structC_b_struct_setter&& b_) {
    b = std::forward<T_structC_b_struct_setter>(b_);
    __isset.b = true;
    return b;
  }

  double get_c() const {
    return c;
  }

  double& set_c(double c_) {
    c = c_;
    __isset.c = true;
    return c;
  }

  bool get_d() const {
    return d;
  }

  bool& set_d(bool d_) {
    d = d_;
    __isset.d = true;
    return d;
  }

   ::test_cpp2::cpp_reflection::enum1 get_e() const {
    return e;
  }

   ::test_cpp2::cpp_reflection::enum1& set_e( ::test_cpp2::cpp_reflection::enum1 e_) {
    e = e_;
    __isset.e = true;
    return e;
  }

   ::test_cpp2::cpp_reflection::enum2 get_f() const {
    return f;
  }

   ::test_cpp2::cpp_reflection::enum2& set_f( ::test_cpp2::cpp_reflection::enum2 f_) {
    f = f_;
    __isset.f = true;
    return f;
  }
  const  ::test_cpp2::cpp_reflection::union1& get_g() const&;
   ::test_cpp2::cpp_reflection::union1 get_g() &&;

  template <typename T_structC_g_struct_setter =  ::test_cpp2::cpp_reflection::union1>
   ::test_cpp2::cpp_reflection::union1& set_g(T_structC_g_struct_setter&& g_) {
    g = std::forward<T_structC_g_struct_setter>(g_);
    __isset.g = true;
    return g;
  }
  const  ::test_cpp2::cpp_reflection::unionA& get_h() const&;
   ::test_cpp2::cpp_reflection::unionA get_h() &&;

  template <typename T_structC_h_struct_setter =  ::test_cpp2::cpp_reflection::unionA>
   ::test_cpp2::cpp_reflection::unionA& set_h(T_structC_h_struct_setter&& h_) {
    h = std::forward<T_structC_h_struct_setter>(h_);
    __isset.h = true;
    return h;
  }
  const  ::test_cpp2::cpp_reflection::unionA& get_i() const&;
   ::test_cpp2::cpp_reflection::unionA get_i() &&;

  template <typename T_structC_i_struct_setter =  ::test_cpp2::cpp_reflection::unionA>
   ::test_cpp2::cpp_reflection::unionA& set_i(T_structC_i_struct_setter&& i_) {
    i = std::forward<T_structC_i_struct_setter>(i_);
    __isset.i = true;
    return i;
  }
  const ::std::vector<int32_t>& get_j() const&;
  ::std::vector<int32_t> get_j() &&;

  template <typename T_structC_j_struct_setter = ::std::vector<int32_t>>
  ::std::vector<int32_t>& set_j(T_structC_j_struct_setter&& j_) {
    j = std::forward<T_structC_j_struct_setter>(j_);
    __isset.j = true;
    return j;
  }
  const ::std::vector<int32_t>& get_j1() const&;
  ::std::vector<int32_t> get_j1() &&;

  template <typename T_structC_j1_struct_setter = ::std::vector<int32_t>>
  ::std::vector<int32_t>& set_j1(T_structC_j1_struct_setter&& j1_) {
    j1 = std::forward<T_structC_j1_struct_setter>(j1_);
    __isset.j1 = true;
    return j1;
  }
  const ::std::vector< ::test_cpp2::cpp_reflection::enum1>& get_j2() const&;
  ::std::vector< ::test_cpp2::cpp_reflection::enum1> get_j2() &&;

  template <typename T_structC_j2_struct_setter = ::std::vector< ::test_cpp2::cpp_reflection::enum1>>
  ::std::vector< ::test_cpp2::cpp_reflection::enum1>& set_j2(T_structC_j2_struct_setter&& j2_) {
    j2 = std::forward<T_structC_j2_struct_setter>(j2_);
    __isset.j2 = true;
    return j2;
  }
  const ::std::vector< ::test_cpp2::cpp_reflection::structA>& get_j3() const&;
  ::std::vector< ::test_cpp2::cpp_reflection::structA> get_j3() &&;

  template <typename T_structC_j3_struct_setter = ::std::vector< ::test_cpp2::cpp_reflection::structA>>
  ::std::vector< ::test_cpp2::cpp_reflection::structA>& set_j3(T_structC_j3_struct_setter&& j3_) {
    j3 = std::forward<T_structC_j3_struct_setter>(j3_);
    __isset.j3 = true;
    return j3;
  }
  const ::std::set<int32_t>& get_k() const&;
  ::std::set<int32_t> get_k() &&;

  template <typename T_structC_k_struct_setter = ::std::set<int32_t>>
  ::std::set<int32_t>& set_k(T_structC_k_struct_setter&& k_) {
    k = std::forward<T_structC_k_struct_setter>(k_);
    __isset.k = true;
    return k;
  }
  const ::std::set<int32_t>& get_k1() const&;
  ::std::set<int32_t> get_k1() &&;

  template <typename T_structC_k1_struct_setter = ::std::set<int32_t>>
  ::std::set<int32_t>& set_k1(T_structC_k1_struct_setter&& k1_) {
    k1 = std::forward<T_structC_k1_struct_setter>(k1_);
    __isset.k1 = true;
    return k1;
  }
  const ::std::set< ::test_cpp2::cpp_reflection::enum2>& get_k2() const&;
  ::std::set< ::test_cpp2::cpp_reflection::enum2> get_k2() &&;

  template <typename T_structC_k2_struct_setter = ::std::set< ::test_cpp2::cpp_reflection::enum2>>
  ::std::set< ::test_cpp2::cpp_reflection::enum2>& set_k2(T_structC_k2_struct_setter&& k2_) {
    k2 = std::forward<T_structC_k2_struct_setter>(k2_);
    __isset.k2 = true;
    return k2;
  }
  const ::std::set< ::test_cpp2::cpp_reflection::structB>& get_k3() const&;
  ::std::set< ::test_cpp2::cpp_reflection::structB> get_k3() &&;

  template <typename T_structC_k3_struct_setter = ::std::set< ::test_cpp2::cpp_reflection::structB>>
  ::std::set< ::test_cpp2::cpp_reflection::structB>& set_k3(T_structC_k3_struct_setter&& k3_) {
    k3 = std::forward<T_structC_k3_struct_setter>(k3_);
    __isset.k3 = true;
    return k3;
  }
  const ::std::map<int32_t, int32_t>& get_l() const&;
  ::std::map<int32_t, int32_t> get_l() &&;

  template <typename T_structC_l_struct_setter = ::std::map<int32_t, int32_t>>
  ::std::map<int32_t, int32_t>& set_l(T_structC_l_struct_setter&& l_) {
    l = std::forward<T_structC_l_struct_setter>(l_);
    __isset.l = true;
    return l;
  }
  const ::std::map<int32_t, int32_t>& get_l1() const&;
  ::std::map<int32_t, int32_t> get_l1() &&;

  template <typename T_structC_l1_struct_setter = ::std::map<int32_t, int32_t>>
  ::std::map<int32_t, int32_t>& set_l1(T_structC_l1_struct_setter&& l1_) {
    l1 = std::forward<T_structC_l1_struct_setter>(l1_);
    __isset.l1 = true;
    return l1;
  }
  const ::std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1>& get_l2() const&;
  ::std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1> get_l2() &&;

  template <typename T_structC_l2_struct_setter = ::std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1>>
  ::std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1>& set_l2(T_structC_l2_struct_setter&& l2_) {
    l2 = std::forward<T_structC_l2_struct_setter>(l2_);
    __isset.l2 = true;
    return l2;
  }
  const ::std::map<int32_t,  ::test_cpp2::cpp_reflection::structB>& get_l3() const&;
  ::std::map<int32_t,  ::test_cpp2::cpp_reflection::structB> get_l3() &&;

  template <typename T_structC_l3_struct_setter = ::std::map<int32_t,  ::test_cpp2::cpp_reflection::structB>>
  ::std::map<int32_t,  ::test_cpp2::cpp_reflection::structB>& set_l3(T_structC_l3_struct_setter&& l3_) {
    l3 = std::forward<T_structC_l3_struct_setter>(l3_);
    __isset.l3 = true;
    return l3;
  }
  const ::std::map< ::test_cpp2::cpp_reflection::enum1, int32_t>& get_m1() const&;
  ::std::map< ::test_cpp2::cpp_reflection::enum1, int32_t> get_m1() &&;

  template <typename T_structC_m1_struct_setter = ::std::map< ::test_cpp2::cpp_reflection::enum1, int32_t>>
  ::std::map< ::test_cpp2::cpp_reflection::enum1, int32_t>& set_m1(T_structC_m1_struct_setter&& m1_) {
    m1 = std::forward<T_structC_m1_struct_setter>(m1_);
    __isset.m1 = true;
    return m1;
  }
  const ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2>& get_m2() const&;
  ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2> get_m2() &&;

  template <typename T_structC_m2_struct_setter = ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2>>
  ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2>& set_m2(T_structC_m2_struct_setter&& m2_) {
    m2 = std::forward<T_structC_m2_struct_setter>(m2_);
    __isset.m2 = true;
    return m2;
  }
  const ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB>& get_m3() const&;
  ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB> get_m3() &&;

  template <typename T_structC_m3_struct_setter = ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB>>
  ::std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB>& set_m3(T_structC_m3_struct_setter&& m3_) {
    m3 = std::forward<T_structC_m3_struct_setter>(m3_);
    __isset.m3 = true;
    return m3;
  }
  const ::std::map<::std::string, int32_t>& get_n1() const&;
  ::std::map<::std::string, int32_t> get_n1() &&;

  template <typename T_structC_n1_struct_setter = ::std::map<::std::string, int32_t>>
  ::std::map<::std::string, int32_t>& set_n1(T_structC_n1_struct_setter&& n1_) {
    n1 = std::forward<T_structC_n1_struct_setter>(n1_);
    __isset.n1 = true;
    return n1;
  }
  const ::std::map<::std::string,  ::test_cpp2::cpp_reflection::enum1>& get_n2() const&;
  ::std::map<::std::string,  ::test_cpp2::cpp_reflection::enum1> get_n2() &&;

  template <typename T_structC_n2_struct_setter = ::std::map<::std::string,  ::test_cpp2::cpp_reflection::enum1>>
  ::std::map<::std::string,  ::test_cpp2::cpp_reflection::enum1>& set_n2(T_structC_n2_struct_setter&& n2_) {
    n2 = std::forward<T_structC_n2_struct_setter>(n2_);
    __isset.n2 = true;
    return n2;
  }
  const ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB>& get_n3() const&;
  ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB> get_n3() &&;

  template <typename T_structC_n3_struct_setter = ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB>>
  ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB>& set_n3(T_structC_n3_struct_setter&& n3_) {
    n3 = std::forward<T_structC_n3_struct_setter>(n3_);
    __isset.n3 = true;
    return n3;
  }
  const ::std::map< ::test_cpp2::cpp_reflection::structA, int32_t>& get_o1() const&;
  ::std::map< ::test_cpp2::cpp_reflection::structA, int32_t> get_o1() &&;

  template <typename T_structC_o1_struct_setter = ::std::map< ::test_cpp2::cpp_reflection::structA, int32_t>>
  ::std::map< ::test_cpp2::cpp_reflection::structA, int32_t>& set_o1(T_structC_o1_struct_setter&& o1_) {
    o1 = std::forward<T_structC_o1_struct_setter>(o1_);
    __isset.o1 = true;
    return o1;
  }
  const ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1>& get_o2() const&;
  ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1> get_o2() &&;

  template <typename T_structC_o2_struct_setter = ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1>>
  ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1>& set_o2(T_structC_o2_struct_setter&& o2_) {
    o2 = std::forward<T_structC_o2_struct_setter>(o2_);
    __isset.o2 = true;
    return o2;
  }
  const ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB>& get_o3() const&;
  ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB> get_o3() &&;

  template <typename T_structC_o3_struct_setter = ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB>>
  ::std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB>& set_o3(T_structC_o3_struct_setter&& o3_) {
    o3 = std::forward<T_structC_o3_struct_setter>(o3_);
    __isset.o3 = true;
    return o3;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< structC >;
};

void swap(structC& a, structC& b);

template <class Protocol_>
uint32_t structC::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class struct1 final : private apache::thrift::detail::st::ComparisonOperators<struct1> {
 public:

  struct1();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  struct1(apache::thrift::FragileConstructor, int32_t field0__arg, ::std::string field1__arg,  ::test_cpp2::cpp_reflection::enum1 field2__arg,  ::test_cpp2::cpp_reflection::enum2 field3__arg,  ::test_cpp2::cpp_reflection::union1 field4__arg,  ::test_cpp2::cpp_reflection::union2 field5__arg);

  struct1(struct1&&) = default;

  struct1(const struct1&) = default;

  struct1& operator=(struct1&&) = default;

  struct1& operator=(const struct1&) = default;
  void __clear();

  ~struct1();

  int32_t field0;
  ::std::string field1;
   ::test_cpp2::cpp_reflection::enum1 field2;
   ::test_cpp2::cpp_reflection::enum2 field3;
   ::test_cpp2::cpp_reflection::union1 field4;
   ::test_cpp2::cpp_reflection::union2 field5;

  struct __isset {
    bool field1;
    bool field2;
    bool field4;
    bool field5;
  } __isset = {};
  bool operator==(const struct1& rhs) const;
  bool operator<(const struct1& rhs) const;

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const ::std::string&> field1_ref() const& {
    return {field1, __isset.field1};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const ::std::string&&> field1_ref() const&& {
    return {std::move(field1), __isset.field1};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<::std::string&> field1_ref() & {
    return {field1, __isset.field1};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<::std::string&&> field1_ref() && {
    return {std::move(field1), __isset.field1};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const  ::test_cpp2::cpp_reflection::union1&> field4_ref() const& {
    return {field4, __isset.field4};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const  ::test_cpp2::cpp_reflection::union1&&> field4_ref() const&& {
    return {std::move(field4), __isset.field4};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref< ::test_cpp2::cpp_reflection::union1&> field4_ref() & {
    return {field4, __isset.field4};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref< ::test_cpp2::cpp_reflection::union1&&> field4_ref() && {
    return {std::move(field4), __isset.field4};
  }

  int32_t get_field0() const {
    return field0;
  }

  int32_t& set_field0(int32_t field0_) {
    field0 = field0_;
    return field0;
  }

  const ::std::string* get_field1() const& {
    return __isset.field1 ? std::addressof(field1) : nullptr;
  }

  ::std::string* get_field1() & {
    return __isset.field1 ? std::addressof(field1) : nullptr;
  }
  ::std::string* get_field1() && = delete;

  template <typename T_struct1_field1_struct_setter = ::std::string>
  ::std::string& set_field1(T_struct1_field1_struct_setter&& field1_) {
    field1 = std::forward<T_struct1_field1_struct_setter>(field1_);
    __isset.field1 = true;
    return field1;
  }

   ::test_cpp2::cpp_reflection::enum1 get_field2() const {
    return field2;
  }

   ::test_cpp2::cpp_reflection::enum1& set_field2( ::test_cpp2::cpp_reflection::enum1 field2_) {
    field2 = field2_;
    __isset.field2 = true;
    return field2;
  }

   ::test_cpp2::cpp_reflection::enum2 get_field3() const {
    return field3;
  }

   ::test_cpp2::cpp_reflection::enum2& set_field3( ::test_cpp2::cpp_reflection::enum2 field3_) {
    field3 = field3_;
    return field3;
  }
  const  ::test_cpp2::cpp_reflection::union1* get_field4() const&;
   ::test_cpp2::cpp_reflection::union1* get_field4() &;
   ::test_cpp2::cpp_reflection::union1* get_field4() && = delete;

  template <typename T_struct1_field4_struct_setter =  ::test_cpp2::cpp_reflection::union1>
   ::test_cpp2::cpp_reflection::union1& set_field4(T_struct1_field4_struct_setter&& field4_) {
    field4 = std::forward<T_struct1_field4_struct_setter>(field4_);
    __isset.field4 = true;
    return field4;
  }
  const  ::test_cpp2::cpp_reflection::union2& get_field5() const&;
   ::test_cpp2::cpp_reflection::union2 get_field5() &&;

  template <typename T_struct1_field5_struct_setter =  ::test_cpp2::cpp_reflection::union2>
   ::test_cpp2::cpp_reflection::union2& set_field5(T_struct1_field5_struct_setter&& field5_) {
    field5 = std::forward<T_struct1_field5_struct_setter>(field5_);
    __isset.field5 = true;
    return field5;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< struct1 >;
};

void swap(struct1& a, struct1& b);

template <class Protocol_>
uint32_t struct1::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class struct2 final : private apache::thrift::detail::st::ComparisonOperators<struct2> {
 public:

  struct2();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  struct2(apache::thrift::FragileConstructor, int32_t fieldA__arg, ::std::string fieldB__arg,  ::test_cpp2::cpp_reflection::enum1 fieldC__arg,  ::test_cpp2::cpp_reflection::enum2 fieldD__arg,  ::test_cpp2::cpp_reflection::union1 fieldE__arg,  ::test_cpp2::cpp_reflection::union2 fieldF__arg,  ::test_cpp2::cpp_reflection::struct1 fieldG__arg);

  struct2(struct2&&) = default;

  struct2(const struct2&) = default;

  struct2& operator=(struct2&&) = default;

  struct2& operator=(const struct2&) = default;
  void __clear();

  ~struct2();

  int32_t fieldA;
  ::std::string fieldB;
   ::test_cpp2::cpp_reflection::enum1 fieldC;
   ::test_cpp2::cpp_reflection::enum2 fieldD;
   ::test_cpp2::cpp_reflection::union1 fieldE;
   ::test_cpp2::cpp_reflection::union2 fieldF;
   ::test_cpp2::cpp_reflection::struct1 fieldG;

  struct __isset {
    bool fieldA;
    bool fieldB;
    bool fieldC;
    bool fieldD;
    bool fieldE;
    bool fieldF;
    bool fieldG;
  } __isset = {};
  bool operator==(const struct2& rhs) const;
  bool operator<(const struct2& rhs) const;

  int32_t get_fieldA() const {
    return fieldA;
  }

  int32_t& set_fieldA(int32_t fieldA_) {
    fieldA = fieldA_;
    __isset.fieldA = true;
    return fieldA;
  }

  const ::std::string& get_fieldB() const& {
    return fieldB;
  }

  ::std::string get_fieldB() && {
    return std::move(fieldB);
  }

  template <typename T_struct2_fieldB_struct_setter = ::std::string>
  ::std::string& set_fieldB(T_struct2_fieldB_struct_setter&& fieldB_) {
    fieldB = std::forward<T_struct2_fieldB_struct_setter>(fieldB_);
    __isset.fieldB = true;
    return fieldB;
  }

   ::test_cpp2::cpp_reflection::enum1 get_fieldC() const {
    return fieldC;
  }

   ::test_cpp2::cpp_reflection::enum1& set_fieldC( ::test_cpp2::cpp_reflection::enum1 fieldC_) {
    fieldC = fieldC_;
    __isset.fieldC = true;
    return fieldC;
  }

   ::test_cpp2::cpp_reflection::enum2 get_fieldD() const {
    return fieldD;
  }

   ::test_cpp2::cpp_reflection::enum2& set_fieldD( ::test_cpp2::cpp_reflection::enum2 fieldD_) {
    fieldD = fieldD_;
    __isset.fieldD = true;
    return fieldD;
  }
  const  ::test_cpp2::cpp_reflection::union1& get_fieldE() const&;
   ::test_cpp2::cpp_reflection::union1 get_fieldE() &&;

  template <typename T_struct2_fieldE_struct_setter =  ::test_cpp2::cpp_reflection::union1>
   ::test_cpp2::cpp_reflection::union1& set_fieldE(T_struct2_fieldE_struct_setter&& fieldE_) {
    fieldE = std::forward<T_struct2_fieldE_struct_setter>(fieldE_);
    __isset.fieldE = true;
    return fieldE;
  }
  const  ::test_cpp2::cpp_reflection::union2& get_fieldF() const&;
   ::test_cpp2::cpp_reflection::union2 get_fieldF() &&;

  template <typename T_struct2_fieldF_struct_setter =  ::test_cpp2::cpp_reflection::union2>
   ::test_cpp2::cpp_reflection::union2& set_fieldF(T_struct2_fieldF_struct_setter&& fieldF_) {
    fieldF = std::forward<T_struct2_fieldF_struct_setter>(fieldF_);
    __isset.fieldF = true;
    return fieldF;
  }
  const  ::test_cpp2::cpp_reflection::struct1& get_fieldG() const&;
   ::test_cpp2::cpp_reflection::struct1 get_fieldG() &&;

  template <typename T_struct2_fieldG_struct_setter =  ::test_cpp2::cpp_reflection::struct1>
   ::test_cpp2::cpp_reflection::struct1& set_fieldG(T_struct2_fieldG_struct_setter&& fieldG_) {
    fieldG = std::forward<T_struct2_fieldG_struct_setter>(fieldG_);
    __isset.fieldG = true;
    return fieldG;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< struct2 >;
};

void swap(struct2& a, struct2& b);

template <class Protocol_>
uint32_t struct2::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class struct3 final : private apache::thrift::detail::st::ComparisonOperators<struct3> {
 public:

  struct3();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  struct3(apache::thrift::FragileConstructor, int32_t fieldA__arg, ::std::string fieldB__arg,  ::test_cpp2::cpp_reflection::enum1 fieldC__arg,  ::test_cpp2::cpp_reflection::enum2 fieldD__arg,  ::test_cpp2::cpp_reflection::union1 fieldE__arg,  ::test_cpp2::cpp_reflection::union2 fieldF__arg,  ::test_cpp2::cpp_reflection::struct1 fieldG__arg,  ::test_cpp2::cpp_reflection::union2 fieldH__arg, ::std::vector<int32_t> fieldI__arg, ::std::vector<::std::string> fieldJ__arg, ::std::vector<::std::string> fieldK__arg, ::std::vector< ::test_cpp2::cpp_reflection::structA> fieldL__arg, ::std::set<int32_t> fieldM__arg, ::std::set<::std::string> fieldN__arg, ::std::set<::std::string> fieldO__arg, ::std::set< ::test_cpp2::cpp_reflection::structB> fieldP__arg, ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structA> fieldQ__arg, ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB> fieldR__arg);

  struct3(struct3&&) = default;

  struct3(const struct3&) = default;

  struct3& operator=(struct3&&) = default;

  struct3& operator=(const struct3&) = default;
  void __clear();

  ~struct3();

  int32_t fieldA;
  ::std::string fieldB;
   ::test_cpp2::cpp_reflection::enum1 fieldC;
   ::test_cpp2::cpp_reflection::enum2 fieldD;
   ::test_cpp2::cpp_reflection::union1 fieldE;
   ::test_cpp2::cpp_reflection::union2 fieldF;
   ::test_cpp2::cpp_reflection::struct1 fieldG;
   ::test_cpp2::cpp_reflection::union2 fieldH;
  ::std::vector<int32_t> fieldI;
  ::std::vector<::std::string> fieldJ;
  ::std::vector<::std::string> fieldK;
  ::std::vector< ::test_cpp2::cpp_reflection::structA> fieldL;
  ::std::set<int32_t> fieldM;
  ::std::set<::std::string> fieldN;
  ::std::set<::std::string> fieldO;
  ::std::set< ::test_cpp2::cpp_reflection::structB> fieldP;
  ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structA> fieldQ;
  ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB> fieldR;

  struct __isset {
    bool fieldA;
    bool fieldB;
    bool fieldC;
    bool fieldD;
    bool fieldE;
    bool fieldF;
    bool fieldG;
    bool fieldH;
    bool fieldI;
    bool fieldJ;
    bool fieldK;
    bool fieldL;
    bool fieldM;
    bool fieldN;
    bool fieldO;
    bool fieldP;
    bool fieldQ;
    bool fieldR;
  } __isset = {};
  bool operator==(const struct3& rhs) const;
  bool operator<(const struct3& rhs) const;

  int32_t get_fieldA() const {
    return fieldA;
  }

  int32_t& set_fieldA(int32_t fieldA_) {
    fieldA = fieldA_;
    __isset.fieldA = true;
    return fieldA;
  }

  const ::std::string& get_fieldB() const& {
    return fieldB;
  }

  ::std::string get_fieldB() && {
    return std::move(fieldB);
  }

  template <typename T_struct3_fieldB_struct_setter = ::std::string>
  ::std::string& set_fieldB(T_struct3_fieldB_struct_setter&& fieldB_) {
    fieldB = std::forward<T_struct3_fieldB_struct_setter>(fieldB_);
    __isset.fieldB = true;
    return fieldB;
  }

   ::test_cpp2::cpp_reflection::enum1 get_fieldC() const {
    return fieldC;
  }

   ::test_cpp2::cpp_reflection::enum1& set_fieldC( ::test_cpp2::cpp_reflection::enum1 fieldC_) {
    fieldC = fieldC_;
    __isset.fieldC = true;
    return fieldC;
  }

   ::test_cpp2::cpp_reflection::enum2 get_fieldD() const {
    return fieldD;
  }

   ::test_cpp2::cpp_reflection::enum2& set_fieldD( ::test_cpp2::cpp_reflection::enum2 fieldD_) {
    fieldD = fieldD_;
    __isset.fieldD = true;
    return fieldD;
  }
  const  ::test_cpp2::cpp_reflection::union1& get_fieldE() const&;
   ::test_cpp2::cpp_reflection::union1 get_fieldE() &&;

  template <typename T_struct3_fieldE_struct_setter =  ::test_cpp2::cpp_reflection::union1>
   ::test_cpp2::cpp_reflection::union1& set_fieldE(T_struct3_fieldE_struct_setter&& fieldE_) {
    fieldE = std::forward<T_struct3_fieldE_struct_setter>(fieldE_);
    __isset.fieldE = true;
    return fieldE;
  }
  const  ::test_cpp2::cpp_reflection::union2& get_fieldF() const&;
   ::test_cpp2::cpp_reflection::union2 get_fieldF() &&;

  template <typename T_struct3_fieldF_struct_setter =  ::test_cpp2::cpp_reflection::union2>
   ::test_cpp2::cpp_reflection::union2& set_fieldF(T_struct3_fieldF_struct_setter&& fieldF_) {
    fieldF = std::forward<T_struct3_fieldF_struct_setter>(fieldF_);
    __isset.fieldF = true;
    return fieldF;
  }
  const  ::test_cpp2::cpp_reflection::struct1& get_fieldG() const&;
   ::test_cpp2::cpp_reflection::struct1 get_fieldG() &&;

  template <typename T_struct3_fieldG_struct_setter =  ::test_cpp2::cpp_reflection::struct1>
   ::test_cpp2::cpp_reflection::struct1& set_fieldG(T_struct3_fieldG_struct_setter&& fieldG_) {
    fieldG = std::forward<T_struct3_fieldG_struct_setter>(fieldG_);
    __isset.fieldG = true;
    return fieldG;
  }
  const  ::test_cpp2::cpp_reflection::union2& get_fieldH() const&;
   ::test_cpp2::cpp_reflection::union2 get_fieldH() &&;

  template <typename T_struct3_fieldH_struct_setter =  ::test_cpp2::cpp_reflection::union2>
   ::test_cpp2::cpp_reflection::union2& set_fieldH(T_struct3_fieldH_struct_setter&& fieldH_) {
    fieldH = std::forward<T_struct3_fieldH_struct_setter>(fieldH_);
    __isset.fieldH = true;
    return fieldH;
  }
  const ::std::vector<int32_t>& get_fieldI() const&;
  ::std::vector<int32_t> get_fieldI() &&;

  template <typename T_struct3_fieldI_struct_setter = ::std::vector<int32_t>>
  ::std::vector<int32_t>& set_fieldI(T_struct3_fieldI_struct_setter&& fieldI_) {
    fieldI = std::forward<T_struct3_fieldI_struct_setter>(fieldI_);
    __isset.fieldI = true;
    return fieldI;
  }
  const ::std::vector<::std::string>& get_fieldJ() const&;
  ::std::vector<::std::string> get_fieldJ() &&;

  template <typename T_struct3_fieldJ_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_fieldJ(T_struct3_fieldJ_struct_setter&& fieldJ_) {
    fieldJ = std::forward<T_struct3_fieldJ_struct_setter>(fieldJ_);
    __isset.fieldJ = true;
    return fieldJ;
  }
  const ::std::vector<::std::string>& get_fieldK() const&;
  ::std::vector<::std::string> get_fieldK() &&;

  template <typename T_struct3_fieldK_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_fieldK(T_struct3_fieldK_struct_setter&& fieldK_) {
    fieldK = std::forward<T_struct3_fieldK_struct_setter>(fieldK_);
    __isset.fieldK = true;
    return fieldK;
  }
  const ::std::vector< ::test_cpp2::cpp_reflection::structA>& get_fieldL() const&;
  ::std::vector< ::test_cpp2::cpp_reflection::structA> get_fieldL() &&;

  template <typename T_struct3_fieldL_struct_setter = ::std::vector< ::test_cpp2::cpp_reflection::structA>>
  ::std::vector< ::test_cpp2::cpp_reflection::structA>& set_fieldL(T_struct3_fieldL_struct_setter&& fieldL_) {
    fieldL = std::forward<T_struct3_fieldL_struct_setter>(fieldL_);
    __isset.fieldL = true;
    return fieldL;
  }
  const ::std::set<int32_t>& get_fieldM() const&;
  ::std::set<int32_t> get_fieldM() &&;

  template <typename T_struct3_fieldM_struct_setter = ::std::set<int32_t>>
  ::std::set<int32_t>& set_fieldM(T_struct3_fieldM_struct_setter&& fieldM_) {
    fieldM = std::forward<T_struct3_fieldM_struct_setter>(fieldM_);
    __isset.fieldM = true;
    return fieldM;
  }
  const ::std::set<::std::string>& get_fieldN() const&;
  ::std::set<::std::string> get_fieldN() &&;

  template <typename T_struct3_fieldN_struct_setter = ::std::set<::std::string>>
  ::std::set<::std::string>& set_fieldN(T_struct3_fieldN_struct_setter&& fieldN_) {
    fieldN = std::forward<T_struct3_fieldN_struct_setter>(fieldN_);
    __isset.fieldN = true;
    return fieldN;
  }
  const ::std::set<::std::string>& get_fieldO() const&;
  ::std::set<::std::string> get_fieldO() &&;

  template <typename T_struct3_fieldO_struct_setter = ::std::set<::std::string>>
  ::std::set<::std::string>& set_fieldO(T_struct3_fieldO_struct_setter&& fieldO_) {
    fieldO = std::forward<T_struct3_fieldO_struct_setter>(fieldO_);
    __isset.fieldO = true;
    return fieldO;
  }
  const ::std::set< ::test_cpp2::cpp_reflection::structB>& get_fieldP() const&;
  ::std::set< ::test_cpp2::cpp_reflection::structB> get_fieldP() &&;

  template <typename T_struct3_fieldP_struct_setter = ::std::set< ::test_cpp2::cpp_reflection::structB>>
  ::std::set< ::test_cpp2::cpp_reflection::structB>& set_fieldP(T_struct3_fieldP_struct_setter&& fieldP_) {
    fieldP = std::forward<T_struct3_fieldP_struct_setter>(fieldP_);
    __isset.fieldP = true;
    return fieldP;
  }
  const ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structA>& get_fieldQ() const&;
  ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structA> get_fieldQ() &&;

  template <typename T_struct3_fieldQ_struct_setter = ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structA>>
  ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structA>& set_fieldQ(T_struct3_fieldQ_struct_setter&& fieldQ_) {
    fieldQ = std::forward<T_struct3_fieldQ_struct_setter>(fieldQ_);
    __isset.fieldQ = true;
    return fieldQ;
  }
  const ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB>& get_fieldR() const&;
  ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB> get_fieldR() &&;

  template <typename T_struct3_fieldR_struct_setter = ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB>>
  ::std::map<::std::string,  ::test_cpp2::cpp_reflection::structB>& set_fieldR(T_struct3_fieldR_struct_setter&& fieldR_) {
    fieldR = std::forward<T_struct3_fieldR_struct_setter>(fieldR_);
    __isset.fieldR = true;
    return fieldR;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< struct3 >;
};

void swap(struct3& a, struct3& b);

template <class Protocol_>
uint32_t struct3::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class struct4 final : private apache::thrift::detail::st::ComparisonOperators<struct4> {
 public:

  struct4() :
      field0(0),
      field2( ::test_cpp2::cpp_reflection::enum1::field0),
      field3(std::make_unique< ::test_cpp2::cpp_reflection::structA>()) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  struct4(apache::thrift::FragileConstructor, int32_t field0__arg, ::std::string field1__arg,  ::test_cpp2::cpp_reflection::enum1 field2__arg, std::unique_ptr< ::test_cpp2::cpp_reflection::structA> field3__arg);

  struct4(struct4&&) = default;
  struct4(const struct4& src);

  struct4& operator=(struct4&&) = default;
  struct4& operator=(const struct4& src);
  void __clear();
  int32_t field0;
  ::std::string field1;
   ::test_cpp2::cpp_reflection::enum1 field2;
  std::unique_ptr< ::test_cpp2::cpp_reflection::structA> field3;

  struct __isset {
    bool field1;
    bool field2;
  } __isset = {};
  bool operator==(const struct4& rhs) const;
  bool operator<(const struct4& rhs) const;

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const ::std::string&> field1_ref() const& {
    return {field1, __isset.field1};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const ::std::string&&> field1_ref() const&& {
    return {std::move(field1), __isset.field1};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<::std::string&> field1_ref() & {
    return {field1, __isset.field1};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<::std::string&&> field1_ref() && {
    return {std::move(field1), __isset.field1};
  }

  int32_t get_field0() const {
    return field0;
  }

  int32_t& set_field0(int32_t field0_) {
    field0 = field0_;
    return field0;
  }

  const ::std::string* get_field1() const& {
    return __isset.field1 ? std::addressof(field1) : nullptr;
  }

  ::std::string* get_field1() & {
    return __isset.field1 ? std::addressof(field1) : nullptr;
  }
  ::std::string* get_field1() && = delete;

  template <typename T_struct4_field1_struct_setter = ::std::string>
  ::std::string& set_field1(T_struct4_field1_struct_setter&& field1_) {
    field1 = std::forward<T_struct4_field1_struct_setter>(field1_);
    __isset.field1 = true;
    return field1;
  }

   ::test_cpp2::cpp_reflection::enum1 get_field2() const {
    return field2;
  }

   ::test_cpp2::cpp_reflection::enum1& set_field2( ::test_cpp2::cpp_reflection::enum1 field2_) {
    field2 = field2_;
    __isset.field2 = true;
    return field2;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< struct4 >;
};

void swap(struct4& a, struct4& b);

template <class Protocol_>
uint32_t struct4::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class struct5 final : private apache::thrift::detail::st::ComparisonOperators<struct5> {
 public:

  struct5();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  struct5(apache::thrift::FragileConstructor, int32_t field0__arg, ::std::string field1__arg,  ::test_cpp2::cpp_reflection::enum1 field2__arg,  ::test_cpp2::cpp_reflection::structA field3__arg,  ::test_cpp2::cpp_reflection::structB field4__arg);

  struct5(struct5&&) = default;

  struct5(const struct5&) = default;

  struct5& operator=(struct5&&) = default;

  struct5& operator=(const struct5&) = default;
  void __clear();

  ~struct5();

  int32_t field0;
  ::std::string field1;
   ::test_cpp2::cpp_reflection::enum1 field2;
   ::test_cpp2::cpp_reflection::structA field3;
   ::test_cpp2::cpp_reflection::structB field4;

  struct __isset {
    bool field1;
    bool field2;
    bool field3;
    bool field4;
  } __isset = {};
  bool operator==(const struct5& rhs) const;
  bool operator<(const struct5& rhs) const;

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const ::std::string&> field1_ref() const& {
    return {field1, __isset.field1};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const ::std::string&&> field1_ref() const&& {
    return {std::move(field1), __isset.field1};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<::std::string&> field1_ref() & {
    return {field1, __isset.field1};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<::std::string&&> field1_ref() && {
    return {std::move(field1), __isset.field1};
  }

  int32_t get_field0() const {
    return field0;
  }

  int32_t& set_field0(int32_t field0_) {
    field0 = field0_;
    return field0;
  }

  const ::std::string* get_field1() const& {
    return __isset.field1 ? std::addressof(field1) : nullptr;
  }

  ::std::string* get_field1() & {
    return __isset.field1 ? std::addressof(field1) : nullptr;
  }
  ::std::string* get_field1() && = delete;

  template <typename T_struct5_field1_struct_setter = ::std::string>
  ::std::string& set_field1(T_struct5_field1_struct_setter&& field1_) {
    field1 = std::forward<T_struct5_field1_struct_setter>(field1_);
    __isset.field1 = true;
    return field1;
  }

   ::test_cpp2::cpp_reflection::enum1 get_field2() const {
    return field2;
  }

   ::test_cpp2::cpp_reflection::enum1& set_field2( ::test_cpp2::cpp_reflection::enum1 field2_) {
    field2 = field2_;
    __isset.field2 = true;
    return field2;
  }
  const  ::test_cpp2::cpp_reflection::structA& get_field3() const&;
   ::test_cpp2::cpp_reflection::structA get_field3() &&;

  template <typename T_struct5_field3_struct_setter =  ::test_cpp2::cpp_reflection::structA>
   ::test_cpp2::cpp_reflection::structA& set_field3(T_struct5_field3_struct_setter&& field3_) {
    field3 = std::forward<T_struct5_field3_struct_setter>(field3_);
    __isset.field3 = true;
    return field3;
  }
  const  ::test_cpp2::cpp_reflection::structB& get_field4() const&;
   ::test_cpp2::cpp_reflection::structB get_field4() &&;

  template <typename T_struct5_field4_struct_setter =  ::test_cpp2::cpp_reflection::structB>
   ::test_cpp2::cpp_reflection::structB& set_field4(T_struct5_field4_struct_setter&& field4_) {
    field4 = std::forward<T_struct5_field4_struct_setter>(field4_);
    __isset.field4 = true;
    return field4;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< struct5 >;
};

void swap(struct5& a, struct5& b);

template <class Protocol_>
uint32_t struct5::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class struct_binary final : private apache::thrift::detail::st::ComparisonOperators<struct_binary> {
 public:

  struct_binary() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  struct_binary(apache::thrift::FragileConstructor, ::std::string bi__arg);

  struct_binary(struct_binary&&) = default;

  struct_binary(const struct_binary&) = default;

  struct_binary& operator=(struct_binary&&) = default;

  struct_binary& operator=(const struct_binary&) = default;
  void __clear();
  ::std::string bi;

  struct __isset {
    bool bi;
  } __isset = {};
  bool operator==(const struct_binary& rhs) const;
  bool operator<(const struct_binary& rhs) const;

  const ::std::string& get_bi() const& {
    return bi;
  }

  ::std::string get_bi() && {
    return std::move(bi);
  }

  template <typename T_struct_binary_bi_struct_setter = ::std::string>
  ::std::string& set_bi(T_struct_binary_bi_struct_setter&& bi_) {
    bi = std::forward<T_struct_binary_bi_struct_setter>(bi_);
    __isset.bi = true;
    return bi;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< struct_binary >;
};

void swap(struct_binary& a, struct_binary& b);

template <class Protocol_>
uint32_t struct_binary::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class dep_A_struct final : private apache::thrift::detail::st::ComparisonOperators<dep_A_struct> {
 public:

  dep_A_struct() :
      i_a(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  dep_A_struct(apache::thrift::FragileConstructor,  ::test_cpp2::cpp_reflection::dep_B_struct b__arg,  ::test_cpp2::cpp_reflection::dep_C_struct c__arg, int32_t i_a__arg);

  dep_A_struct(dep_A_struct&&) = default;

  dep_A_struct(const dep_A_struct&) = default;

  dep_A_struct& operator=(dep_A_struct&&) = default;

  dep_A_struct& operator=(const dep_A_struct&) = default;
  void __clear();
   ::test_cpp2::cpp_reflection::dep_B_struct b;
   ::test_cpp2::cpp_reflection::dep_C_struct c;
  int32_t i_a;

  struct __isset {
    bool b;
    bool c;
    bool i_a;
  } __isset = {};
  bool operator==(const dep_A_struct& rhs) const;
  bool operator<(const dep_A_struct& rhs) const;
  const  ::test_cpp2::cpp_reflection::dep_B_struct& get_b() const&;
   ::test_cpp2::cpp_reflection::dep_B_struct get_b() &&;

  template <typename T_dep_A_struct_b_struct_setter =  ::test_cpp2::cpp_reflection::dep_B_struct>
   ::test_cpp2::cpp_reflection::dep_B_struct& set_b(T_dep_A_struct_b_struct_setter&& b_) {
    b = std::forward<T_dep_A_struct_b_struct_setter>(b_);
    __isset.b = true;
    return b;
  }
  const  ::test_cpp2::cpp_reflection::dep_C_struct& get_c() const&;
   ::test_cpp2::cpp_reflection::dep_C_struct get_c() &&;

  template <typename T_dep_A_struct_c_struct_setter =  ::test_cpp2::cpp_reflection::dep_C_struct>
   ::test_cpp2::cpp_reflection::dep_C_struct& set_c(T_dep_A_struct_c_struct_setter&& c_) {
    c = std::forward<T_dep_A_struct_c_struct_setter>(c_);
    __isset.c = true;
    return c;
  }

  int32_t get_i_a() const {
    return i_a;
  }

  int32_t& set_i_a(int32_t i_a_) {
    i_a = i_a_;
    __isset.i_a = true;
    return i_a;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< dep_A_struct >;
};

void swap(dep_A_struct& a, dep_A_struct& b);

template <class Protocol_>
uint32_t dep_A_struct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class dep_B_struct final : private apache::thrift::detail::st::ComparisonOperators<dep_B_struct> {
 public:

  dep_B_struct() :
      i_a(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  dep_B_struct(apache::thrift::FragileConstructor,  ::test_cpp2::cpp_reflection::dep_B_struct b__arg,  ::test_cpp2::cpp_reflection::dep_C_struct c__arg, int32_t i_a__arg);

  dep_B_struct(dep_B_struct&&) = default;

  dep_B_struct(const dep_B_struct&) = default;

  dep_B_struct& operator=(dep_B_struct&&) = default;

  dep_B_struct& operator=(const dep_B_struct&) = default;
  void __clear();
   ::test_cpp2::cpp_reflection::dep_B_struct b;
   ::test_cpp2::cpp_reflection::dep_C_struct c;
  int32_t i_a;

  struct __isset {
    bool b;
    bool c;
    bool i_a;
  } __isset = {};
  bool operator==(const dep_B_struct& rhs) const;
  bool operator<(const dep_B_struct& rhs) const;
  const  ::test_cpp2::cpp_reflection::dep_B_struct& get_b() const&;
   ::test_cpp2::cpp_reflection::dep_B_struct get_b() &&;

  template <typename T_dep_B_struct_b_struct_setter =  ::test_cpp2::cpp_reflection::dep_B_struct>
   ::test_cpp2::cpp_reflection::dep_B_struct& set_b(T_dep_B_struct_b_struct_setter&& b_) {
    b = std::forward<T_dep_B_struct_b_struct_setter>(b_);
    __isset.b = true;
    return b;
  }
  const  ::test_cpp2::cpp_reflection::dep_C_struct& get_c() const&;
   ::test_cpp2::cpp_reflection::dep_C_struct get_c() &&;

  template <typename T_dep_B_struct_c_struct_setter =  ::test_cpp2::cpp_reflection::dep_C_struct>
   ::test_cpp2::cpp_reflection::dep_C_struct& set_c(T_dep_B_struct_c_struct_setter&& c_) {
    c = std::forward<T_dep_B_struct_c_struct_setter>(c_);
    __isset.c = true;
    return c;
  }

  int32_t get_i_a() const {
    return i_a;
  }

  int32_t& set_i_a(int32_t i_a_) {
    i_a = i_a_;
    __isset.i_a = true;
    return i_a;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< dep_B_struct >;
};

void swap(dep_B_struct& a, dep_B_struct& b);

template <class Protocol_>
uint32_t dep_B_struct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class annotated final : private apache::thrift::detail::st::ComparisonOperators<annotated> {
 public:

  annotated() :
      a(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  annotated(apache::thrift::FragileConstructor, int32_t a__arg);

  annotated(annotated&&) = default;

  annotated(const annotated&) = default;

  annotated& operator=(annotated&&) = default;

  annotated& operator=(const annotated&) = default;
  void __clear();
  int32_t a;

  struct __isset {
    bool a;
  } __isset = {};
  bool operator==(const annotated& rhs) const;
  bool operator<(const annotated& rhs) const;

  int32_t get_a() const {
    return a;
  }

  int32_t& set_a(int32_t a_) {
    a = a_;
    __isset.a = true;
    return a;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< annotated >;
};

void swap(annotated& a, annotated& b);

template <class Protocol_>
uint32_t annotated::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class union_with_special_names final : private apache::thrift::detail::st::ComparisonOperators<union_with_special_names> {
 public:
  enum Type {
    __EMPTY__ = 0,
    get = 1,
    getter = 2,
    lists = 3,
    maps = 4,
    name = 5,
    name_to_value = 6,
    names = 7,
    prefix_tree = 8,
    sets = 9,
    setter = 10,
    str = 11,
    strings = 12,
    type = 13,
    value = 14,
    value_to_name = 15,
    values = 16,
    id = 17,
    ids = 18,
    descriptor = 19,
    descriptors = 20,
    key = 21,
    keys = 22,
    annotation = 23,
    annotations = 24,
    member = 25,
    members = 26,
    field = 27,
    fields = 28,
  } ;

  union_with_special_names()
      : type_(Type::__EMPTY__) {}

  union_with_special_names(union_with_special_names&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::get:
      {
        set_get(std::move(rhs.value_.get));
        break;
      }
      case Type::getter:
      {
        set_getter(std::move(rhs.value_.getter));
        break;
      }
      case Type::lists:
      {
        set_lists(std::move(rhs.value_.lists));
        break;
      }
      case Type::maps:
      {
        set_maps(std::move(rhs.value_.maps));
        break;
      }
      case Type::name:
      {
        set_name(std::move(rhs.value_.name));
        break;
      }
      case Type::name_to_value:
      {
        set_name_to_value(std::move(rhs.value_.name_to_value));
        break;
      }
      case Type::names:
      {
        set_names(std::move(rhs.value_.names));
        break;
      }
      case Type::prefix_tree:
      {
        set_prefix_tree(std::move(rhs.value_.prefix_tree));
        break;
      }
      case Type::sets:
      {
        set_sets(std::move(rhs.value_.sets));
        break;
      }
      case Type::setter:
      {
        set_setter(std::move(rhs.value_.setter));
        break;
      }
      case Type::str:
      {
        set_str(std::move(rhs.value_.str));
        break;
      }
      case Type::strings:
      {
        set_strings(std::move(rhs.value_.strings));
        break;
      }
      case Type::type:
      {
        set_type(std::move(rhs.value_.type));
        break;
      }
      case Type::value:
      {
        set_value(std::move(rhs.value_.value));
        break;
      }
      case Type::value_to_name:
      {
        set_value_to_name(std::move(rhs.value_.value_to_name));
        break;
      }
      case Type::values:
      {
        set_values(std::move(rhs.value_.values));
        break;
      }
      case Type::id:
      {
        set_id(std::move(rhs.value_.id));
        break;
      }
      case Type::ids:
      {
        set_ids(std::move(rhs.value_.ids));
        break;
      }
      case Type::descriptor:
      {
        set_descriptor(std::move(rhs.value_.descriptor));
        break;
      }
      case Type::descriptors:
      {
        set_descriptors(std::move(rhs.value_.descriptors));
        break;
      }
      case Type::key:
      {
        set_key(std::move(rhs.value_.key));
        break;
      }
      case Type::keys:
      {
        set_keys(std::move(rhs.value_.keys));
        break;
      }
      case Type::annotation:
      {
        set_annotation(std::move(rhs.value_.annotation));
        break;
      }
      case Type::annotations:
      {
        set_annotations(std::move(rhs.value_.annotations));
        break;
      }
      case Type::member:
      {
        set_member(std::move(rhs.value_.member));
        break;
      }
      case Type::members:
      {
        set_members(std::move(rhs.value_.members));
        break;
      }
      case Type::field:
      {
        set_field(std::move(rhs.value_.field));
        break;
      }
      case Type::fields:
      {
        set_fields(std::move(rhs.value_.fields));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  union_with_special_names(const union_with_special_names& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::get:
      {
        set_get(rhs.value_.get);
        break;
      }
      case Type::getter:
      {
        set_getter(rhs.value_.getter);
        break;
      }
      case Type::lists:
      {
        set_lists(rhs.value_.lists);
        break;
      }
      case Type::maps:
      {
        set_maps(rhs.value_.maps);
        break;
      }
      case Type::name:
      {
        set_name(rhs.value_.name);
        break;
      }
      case Type::name_to_value:
      {
        set_name_to_value(rhs.value_.name_to_value);
        break;
      }
      case Type::names:
      {
        set_names(rhs.value_.names);
        break;
      }
      case Type::prefix_tree:
      {
        set_prefix_tree(rhs.value_.prefix_tree);
        break;
      }
      case Type::sets:
      {
        set_sets(rhs.value_.sets);
        break;
      }
      case Type::setter:
      {
        set_setter(rhs.value_.setter);
        break;
      }
      case Type::str:
      {
        set_str(rhs.value_.str);
        break;
      }
      case Type::strings:
      {
        set_strings(rhs.value_.strings);
        break;
      }
      case Type::type:
      {
        set_type(rhs.value_.type);
        break;
      }
      case Type::value:
      {
        set_value(rhs.value_.value);
        break;
      }
      case Type::value_to_name:
      {
        set_value_to_name(rhs.value_.value_to_name);
        break;
      }
      case Type::values:
      {
        set_values(rhs.value_.values);
        break;
      }
      case Type::id:
      {
        set_id(rhs.value_.id);
        break;
      }
      case Type::ids:
      {
        set_ids(rhs.value_.ids);
        break;
      }
      case Type::descriptor:
      {
        set_descriptor(rhs.value_.descriptor);
        break;
      }
      case Type::descriptors:
      {
        set_descriptors(rhs.value_.descriptors);
        break;
      }
      case Type::key:
      {
        set_key(rhs.value_.key);
        break;
      }
      case Type::keys:
      {
        set_keys(rhs.value_.keys);
        break;
      }
      case Type::annotation:
      {
        set_annotation(rhs.value_.annotation);
        break;
      }
      case Type::annotations:
      {
        set_annotations(rhs.value_.annotations);
        break;
      }
      case Type::member:
      {
        set_member(rhs.value_.member);
        break;
      }
      case Type::members:
      {
        set_members(rhs.value_.members);
        break;
      }
      case Type::field:
      {
        set_field(rhs.value_.field);
        break;
      }
      case Type::fields:
      {
        set_fields(rhs.value_.fields);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  union_with_special_names& operator=(union_with_special_names&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::get:
      {
        set_get(std::move(rhs.value_.get));
        break;
      }
      case Type::getter:
      {
        set_getter(std::move(rhs.value_.getter));
        break;
      }
      case Type::lists:
      {
        set_lists(std::move(rhs.value_.lists));
        break;
      }
      case Type::maps:
      {
        set_maps(std::move(rhs.value_.maps));
        break;
      }
      case Type::name:
      {
        set_name(std::move(rhs.value_.name));
        break;
      }
      case Type::name_to_value:
      {
        set_name_to_value(std::move(rhs.value_.name_to_value));
        break;
      }
      case Type::names:
      {
        set_names(std::move(rhs.value_.names));
        break;
      }
      case Type::prefix_tree:
      {
        set_prefix_tree(std::move(rhs.value_.prefix_tree));
        break;
      }
      case Type::sets:
      {
        set_sets(std::move(rhs.value_.sets));
        break;
      }
      case Type::setter:
      {
        set_setter(std::move(rhs.value_.setter));
        break;
      }
      case Type::str:
      {
        set_str(std::move(rhs.value_.str));
        break;
      }
      case Type::strings:
      {
        set_strings(std::move(rhs.value_.strings));
        break;
      }
      case Type::type:
      {
        set_type(std::move(rhs.value_.type));
        break;
      }
      case Type::value:
      {
        set_value(std::move(rhs.value_.value));
        break;
      }
      case Type::value_to_name:
      {
        set_value_to_name(std::move(rhs.value_.value_to_name));
        break;
      }
      case Type::values:
      {
        set_values(std::move(rhs.value_.values));
        break;
      }
      case Type::id:
      {
        set_id(std::move(rhs.value_.id));
        break;
      }
      case Type::ids:
      {
        set_ids(std::move(rhs.value_.ids));
        break;
      }
      case Type::descriptor:
      {
        set_descriptor(std::move(rhs.value_.descriptor));
        break;
      }
      case Type::descriptors:
      {
        set_descriptors(std::move(rhs.value_.descriptors));
        break;
      }
      case Type::key:
      {
        set_key(std::move(rhs.value_.key));
        break;
      }
      case Type::keys:
      {
        set_keys(std::move(rhs.value_.keys));
        break;
      }
      case Type::annotation:
      {
        set_annotation(std::move(rhs.value_.annotation));
        break;
      }
      case Type::annotations:
      {
        set_annotations(std::move(rhs.value_.annotations));
        break;
      }
      case Type::member:
      {
        set_member(std::move(rhs.value_.member));
        break;
      }
      case Type::members:
      {
        set_members(std::move(rhs.value_.members));
        break;
      }
      case Type::field:
      {
        set_field(std::move(rhs.value_.field));
        break;
      }
      case Type::fields:
      {
        set_fields(std::move(rhs.value_.fields));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  union_with_special_names& operator=(const union_with_special_names& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::get:
      {
        set_get(rhs.value_.get);
        break;
      }
      case Type::getter:
      {
        set_getter(rhs.value_.getter);
        break;
      }
      case Type::lists:
      {
        set_lists(rhs.value_.lists);
        break;
      }
      case Type::maps:
      {
        set_maps(rhs.value_.maps);
        break;
      }
      case Type::name:
      {
        set_name(rhs.value_.name);
        break;
      }
      case Type::name_to_value:
      {
        set_name_to_value(rhs.value_.name_to_value);
        break;
      }
      case Type::names:
      {
        set_names(rhs.value_.names);
        break;
      }
      case Type::prefix_tree:
      {
        set_prefix_tree(rhs.value_.prefix_tree);
        break;
      }
      case Type::sets:
      {
        set_sets(rhs.value_.sets);
        break;
      }
      case Type::setter:
      {
        set_setter(rhs.value_.setter);
        break;
      }
      case Type::str:
      {
        set_str(rhs.value_.str);
        break;
      }
      case Type::strings:
      {
        set_strings(rhs.value_.strings);
        break;
      }
      case Type::type:
      {
        set_type(rhs.value_.type);
        break;
      }
      case Type::value:
      {
        set_value(rhs.value_.value);
        break;
      }
      case Type::value_to_name:
      {
        set_value_to_name(rhs.value_.value_to_name);
        break;
      }
      case Type::values:
      {
        set_values(rhs.value_.values);
        break;
      }
      case Type::id:
      {
        set_id(rhs.value_.id);
        break;
      }
      case Type::ids:
      {
        set_ids(rhs.value_.ids);
        break;
      }
      case Type::descriptor:
      {
        set_descriptor(rhs.value_.descriptor);
        break;
      }
      case Type::descriptors:
      {
        set_descriptors(rhs.value_.descriptors);
        break;
      }
      case Type::key:
      {
        set_key(rhs.value_.key);
        break;
      }
      case Type::keys:
      {
        set_keys(rhs.value_.keys);
        break;
      }
      case Type::annotation:
      {
        set_annotation(rhs.value_.annotation);
        break;
      }
      case Type::annotations:
      {
        set_annotations(rhs.value_.annotations);
        break;
      }
      case Type::member:
      {
        set_member(rhs.value_.member);
        break;
      }
      case Type::members:
      {
        set_members(rhs.value_.members);
        break;
      }
      case Type::field:
      {
        set_field(rhs.value_.field);
        break;
      }
      case Type::fields:
      {
        set_fields(rhs.value_.fields);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~union_with_special_names() {
    __clear();
  }
  union storage_type {
    int32_t get;
    int32_t getter;
    int32_t lists;
    int32_t maps;
    int32_t name;
    int32_t name_to_value;
    int32_t names;
    int32_t prefix_tree;
    int32_t sets;
    int32_t setter;
    int32_t str;
    int32_t strings;
    int32_t type;
    int32_t value;
    int32_t value_to_name;
    int32_t values;
    int32_t id;
    int32_t ids;
    int32_t descriptor;
    int32_t descriptors;
    int32_t key;
    int32_t keys;
    int32_t annotation;
    int32_t annotations;
    int32_t member;
    int32_t members;
    int32_t field;
    int32_t fields;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const union_with_special_names& rhs) const;
  bool operator<(const union_with_special_names& rhs) const;

  int32_t& set_get(int32_t t = int32_t()) {
    __clear();
    type_ = Type::get;
    ::new (std::addressof(value_.get)) int32_t(t);
    return value_.get;
  }

  int32_t& set_getter(int32_t t = int32_t()) {
    __clear();
    type_ = Type::getter;
    ::new (std::addressof(value_.getter)) int32_t(t);
    return value_.getter;
  }

  int32_t& set_lists(int32_t t = int32_t()) {
    __clear();
    type_ = Type::lists;
    ::new (std::addressof(value_.lists)) int32_t(t);
    return value_.lists;
  }

  int32_t& set_maps(int32_t t = int32_t()) {
    __clear();
    type_ = Type::maps;
    ::new (std::addressof(value_.maps)) int32_t(t);
    return value_.maps;
  }

  int32_t& set_name(int32_t t = int32_t()) {
    __clear();
    type_ = Type::name;
    ::new (std::addressof(value_.name)) int32_t(t);
    return value_.name;
  }

  int32_t& set_name_to_value(int32_t t = int32_t()) {
    __clear();
    type_ = Type::name_to_value;
    ::new (std::addressof(value_.name_to_value)) int32_t(t);
    return value_.name_to_value;
  }

  int32_t& set_names(int32_t t = int32_t()) {
    __clear();
    type_ = Type::names;
    ::new (std::addressof(value_.names)) int32_t(t);
    return value_.names;
  }

  int32_t& set_prefix_tree(int32_t t = int32_t()) {
    __clear();
    type_ = Type::prefix_tree;
    ::new (std::addressof(value_.prefix_tree)) int32_t(t);
    return value_.prefix_tree;
  }

  int32_t& set_sets(int32_t t = int32_t()) {
    __clear();
    type_ = Type::sets;
    ::new (std::addressof(value_.sets)) int32_t(t);
    return value_.sets;
  }

  int32_t& set_setter(int32_t t = int32_t()) {
    __clear();
    type_ = Type::setter;
    ::new (std::addressof(value_.setter)) int32_t(t);
    return value_.setter;
  }

  int32_t& set_str(int32_t t = int32_t()) {
    __clear();
    type_ = Type::str;
    ::new (std::addressof(value_.str)) int32_t(t);
    return value_.str;
  }

  int32_t& set_strings(int32_t t = int32_t()) {
    __clear();
    type_ = Type::strings;
    ::new (std::addressof(value_.strings)) int32_t(t);
    return value_.strings;
  }

  int32_t& set_type(int32_t t = int32_t()) {
    __clear();
    type_ = Type::type;
    ::new (std::addressof(value_.type)) int32_t(t);
    return value_.type;
  }

  int32_t& set_value(int32_t t = int32_t()) {
    __clear();
    type_ = Type::value;
    ::new (std::addressof(value_.value)) int32_t(t);
    return value_.value;
  }

  int32_t& set_value_to_name(int32_t t = int32_t()) {
    __clear();
    type_ = Type::value_to_name;
    ::new (std::addressof(value_.value_to_name)) int32_t(t);
    return value_.value_to_name;
  }

  int32_t& set_values(int32_t t = int32_t()) {
    __clear();
    type_ = Type::values;
    ::new (std::addressof(value_.values)) int32_t(t);
    return value_.values;
  }

  int32_t& set_id(int32_t t = int32_t()) {
    __clear();
    type_ = Type::id;
    ::new (std::addressof(value_.id)) int32_t(t);
    return value_.id;
  }

  int32_t& set_ids(int32_t t = int32_t()) {
    __clear();
    type_ = Type::ids;
    ::new (std::addressof(value_.ids)) int32_t(t);
    return value_.ids;
  }

  int32_t& set_descriptor(int32_t t = int32_t()) {
    __clear();
    type_ = Type::descriptor;
    ::new (std::addressof(value_.descriptor)) int32_t(t);
    return value_.descriptor;
  }

  int32_t& set_descriptors(int32_t t = int32_t()) {
    __clear();
    type_ = Type::descriptors;
    ::new (std::addressof(value_.descriptors)) int32_t(t);
    return value_.descriptors;
  }

  int32_t& set_key(int32_t t = int32_t()) {
    __clear();
    type_ = Type::key;
    ::new (std::addressof(value_.key)) int32_t(t);
    return value_.key;
  }

  int32_t& set_keys(int32_t t = int32_t()) {
    __clear();
    type_ = Type::keys;
    ::new (std::addressof(value_.keys)) int32_t(t);
    return value_.keys;
  }

  int32_t& set_annotation(int32_t t = int32_t()) {
    __clear();
    type_ = Type::annotation;
    ::new (std::addressof(value_.annotation)) int32_t(t);
    return value_.annotation;
  }

  int32_t& set_annotations(int32_t t = int32_t()) {
    __clear();
    type_ = Type::annotations;
    ::new (std::addressof(value_.annotations)) int32_t(t);
    return value_.annotations;
  }

  int32_t& set_member(int32_t t = int32_t()) {
    __clear();
    type_ = Type::member;
    ::new (std::addressof(value_.member)) int32_t(t);
    return value_.member;
  }

  int32_t& set_members(int32_t t = int32_t()) {
    __clear();
    type_ = Type::members;
    ::new (std::addressof(value_.members)) int32_t(t);
    return value_.members;
  }

  int32_t& set_field(int32_t t = int32_t()) {
    __clear();
    type_ = Type::field;
    ::new (std::addressof(value_.field)) int32_t(t);
    return value_.field;
  }

  int32_t& set_fields(int32_t t = int32_t()) {
    __clear();
    type_ = Type::fields;
    ::new (std::addressof(value_.fields)) int32_t(t);
    return value_.fields;
  }

  int32_t const & get_get() const {
    assert(type_ == Type::get);
    return value_.get;
  }

  int32_t const & get_getter() const {
    assert(type_ == Type::getter);
    return value_.getter;
  }

  int32_t const & get_lists() const {
    assert(type_ == Type::lists);
    return value_.lists;
  }

  int32_t const & get_maps() const {
    assert(type_ == Type::maps);
    return value_.maps;
  }

  int32_t const & get_name() const {
    assert(type_ == Type::name);
    return value_.name;
  }

  int32_t const & get_name_to_value() const {
    assert(type_ == Type::name_to_value);
    return value_.name_to_value;
  }

  int32_t const & get_names() const {
    assert(type_ == Type::names);
    return value_.names;
  }

  int32_t const & get_prefix_tree() const {
    assert(type_ == Type::prefix_tree);
    return value_.prefix_tree;
  }

  int32_t const & get_sets() const {
    assert(type_ == Type::sets);
    return value_.sets;
  }

  int32_t const & get_setter() const {
    assert(type_ == Type::setter);
    return value_.setter;
  }

  int32_t const & get_str() const {
    assert(type_ == Type::str);
    return value_.str;
  }

  int32_t const & get_strings() const {
    assert(type_ == Type::strings);
    return value_.strings;
  }

  int32_t const & get_type() const {
    assert(type_ == Type::type);
    return value_.type;
  }

  int32_t const & get_value() const {
    assert(type_ == Type::value);
    return value_.value;
  }

  int32_t const & get_value_to_name() const {
    assert(type_ == Type::value_to_name);
    return value_.value_to_name;
  }

  int32_t const & get_values() const {
    assert(type_ == Type::values);
    return value_.values;
  }

  int32_t const & get_id() const {
    assert(type_ == Type::id);
    return value_.id;
  }

  int32_t const & get_ids() const {
    assert(type_ == Type::ids);
    return value_.ids;
  }

  int32_t const & get_descriptor() const {
    assert(type_ == Type::descriptor);
    return value_.descriptor;
  }

  int32_t const & get_descriptors() const {
    assert(type_ == Type::descriptors);
    return value_.descriptors;
  }

  int32_t const & get_key() const {
    assert(type_ == Type::key);
    return value_.key;
  }

  int32_t const & get_keys() const {
    assert(type_ == Type::keys);
    return value_.keys;
  }

  int32_t const & get_annotation() const {
    assert(type_ == Type::annotation);
    return value_.annotation;
  }

  int32_t const & get_annotations() const {
    assert(type_ == Type::annotations);
    return value_.annotations;
  }

  int32_t const & get_member() const {
    assert(type_ == Type::member);
    return value_.member;
  }

  int32_t const & get_members() const {
    assert(type_ == Type::members);
    return value_.members;
  }

  int32_t const & get_field() const {
    assert(type_ == Type::field);
    return value_.field;
  }

  int32_t const & get_fields() const {
    assert(type_ == Type::fields);
    return value_.fields;
  }

  int32_t & mutable_get() {
    assert(type_ == Type::get);
    return value_.get;
  }

  int32_t & mutable_getter() {
    assert(type_ == Type::getter);
    return value_.getter;
  }

  int32_t & mutable_lists() {
    assert(type_ == Type::lists);
    return value_.lists;
  }

  int32_t & mutable_maps() {
    assert(type_ == Type::maps);
    return value_.maps;
  }

  int32_t & mutable_name() {
    assert(type_ == Type::name);
    return value_.name;
  }

  int32_t & mutable_name_to_value() {
    assert(type_ == Type::name_to_value);
    return value_.name_to_value;
  }

  int32_t & mutable_names() {
    assert(type_ == Type::names);
    return value_.names;
  }

  int32_t & mutable_prefix_tree() {
    assert(type_ == Type::prefix_tree);
    return value_.prefix_tree;
  }

  int32_t & mutable_sets() {
    assert(type_ == Type::sets);
    return value_.sets;
  }

  int32_t & mutable_setter() {
    assert(type_ == Type::setter);
    return value_.setter;
  }

  int32_t & mutable_str() {
    assert(type_ == Type::str);
    return value_.str;
  }

  int32_t & mutable_strings() {
    assert(type_ == Type::strings);
    return value_.strings;
  }

  int32_t & mutable_type() {
    assert(type_ == Type::type);
    return value_.type;
  }

  int32_t & mutable_value() {
    assert(type_ == Type::value);
    return value_.value;
  }

  int32_t & mutable_value_to_name() {
    assert(type_ == Type::value_to_name);
    return value_.value_to_name;
  }

  int32_t & mutable_values() {
    assert(type_ == Type::values);
    return value_.values;
  }

  int32_t & mutable_id() {
    assert(type_ == Type::id);
    return value_.id;
  }

  int32_t & mutable_ids() {
    assert(type_ == Type::ids);
    return value_.ids;
  }

  int32_t & mutable_descriptor() {
    assert(type_ == Type::descriptor);
    return value_.descriptor;
  }

  int32_t & mutable_descriptors() {
    assert(type_ == Type::descriptors);
    return value_.descriptors;
  }

  int32_t & mutable_key() {
    assert(type_ == Type::key);
    return value_.key;
  }

  int32_t & mutable_keys() {
    assert(type_ == Type::keys);
    return value_.keys;
  }

  int32_t & mutable_annotation() {
    assert(type_ == Type::annotation);
    return value_.annotation;
  }

  int32_t & mutable_annotations() {
    assert(type_ == Type::annotations);
    return value_.annotations;
  }

  int32_t & mutable_member() {
    assert(type_ == Type::member);
    return value_.member;
  }

  int32_t & mutable_members() {
    assert(type_ == Type::members);
    return value_.members;
  }

  int32_t & mutable_field() {
    assert(type_ == Type::field);
    return value_.field;
  }

  int32_t & mutable_fields() {
    assert(type_ == Type::fields);
    return value_.fields;
  }

  int32_t move_get() {
    assert(type_ == Type::get);
    return std::move(value_.get);
  }

  int32_t move_getter() {
    assert(type_ == Type::getter);
    return std::move(value_.getter);
  }

  int32_t move_lists() {
    assert(type_ == Type::lists);
    return std::move(value_.lists);
  }

  int32_t move_maps() {
    assert(type_ == Type::maps);
    return std::move(value_.maps);
  }

  int32_t move_name() {
    assert(type_ == Type::name);
    return std::move(value_.name);
  }

  int32_t move_name_to_value() {
    assert(type_ == Type::name_to_value);
    return std::move(value_.name_to_value);
  }

  int32_t move_names() {
    assert(type_ == Type::names);
    return std::move(value_.names);
  }

  int32_t move_prefix_tree() {
    assert(type_ == Type::prefix_tree);
    return std::move(value_.prefix_tree);
  }

  int32_t move_sets() {
    assert(type_ == Type::sets);
    return std::move(value_.sets);
  }

  int32_t move_setter() {
    assert(type_ == Type::setter);
    return std::move(value_.setter);
  }

  int32_t move_str() {
    assert(type_ == Type::str);
    return std::move(value_.str);
  }

  int32_t move_strings() {
    assert(type_ == Type::strings);
    return std::move(value_.strings);
  }

  int32_t move_type() {
    assert(type_ == Type::type);
    return std::move(value_.type);
  }

  int32_t move_value() {
    assert(type_ == Type::value);
    return std::move(value_.value);
  }

  int32_t move_value_to_name() {
    assert(type_ == Type::value_to_name);
    return std::move(value_.value_to_name);
  }

  int32_t move_values() {
    assert(type_ == Type::values);
    return std::move(value_.values);
  }

  int32_t move_id() {
    assert(type_ == Type::id);
    return std::move(value_.id);
  }

  int32_t move_ids() {
    assert(type_ == Type::ids);
    return std::move(value_.ids);
  }

  int32_t move_descriptor() {
    assert(type_ == Type::descriptor);
    return std::move(value_.descriptor);
  }

  int32_t move_descriptors() {
    assert(type_ == Type::descriptors);
    return std::move(value_.descriptors);
  }

  int32_t move_key() {
    assert(type_ == Type::key);
    return std::move(value_.key);
  }

  int32_t move_keys() {
    assert(type_ == Type::keys);
    return std::move(value_.keys);
  }

  int32_t move_annotation() {
    assert(type_ == Type::annotation);
    return std::move(value_.annotation);
  }

  int32_t move_annotations() {
    assert(type_ == Type::annotations);
    return std::move(value_.annotations);
  }

  int32_t move_member() {
    assert(type_ == Type::member);
    return std::move(value_.member);
  }

  int32_t move_members() {
    assert(type_ == Type::members);
    return std::move(value_.members);
  }

  int32_t move_field() {
    assert(type_ == Type::field);
    return std::move(value_.field);
  }

  int32_t move_fields() {
    assert(type_ == Type::fields);
    return std::move(value_.fields);
  }

  Type getType() const { return type_; }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  Type type_;
  storage_type value_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< union_with_special_names >;
};

void swap(union_with_special_names& a, union_with_special_names& b);

template <class Protocol_>
uint32_t union_with_special_names::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class struct_with_special_names final : private apache::thrift::detail::st::ComparisonOperators<struct_with_special_names> {
 public:

  struct_with_special_names() :
      get(0),
      getter(0),
      lists(0),
      maps(0),
      name(0),
      name_to_value(0),
      names(0),
      prefix_tree(0),
      sets(0),
      setter(0),
      str(0),
      strings(0),
      type(0),
      value(0),
      value_to_name(0),
      values(0),
      id(0),
      ids(0),
      descriptor(0),
      descriptors(0),
      key(0),
      keys(0),
      annotation(0),
      annotations(0),
      member(0),
      members(0),
      field(0),
      fields(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  struct_with_special_names(apache::thrift::FragileConstructor, int32_t get__arg, int32_t getter__arg, int32_t lists__arg, int32_t maps__arg, int32_t name__arg, int32_t name_to_value__arg, int32_t names__arg, int32_t prefix_tree__arg, int32_t sets__arg, int32_t setter__arg, int32_t str__arg, int32_t strings__arg, int32_t type__arg, int32_t value__arg, int32_t value_to_name__arg, int32_t values__arg, int32_t id__arg, int32_t ids__arg, int32_t descriptor__arg, int32_t descriptors__arg, int32_t key__arg, int32_t keys__arg, int32_t annotation__arg, int32_t annotations__arg, int32_t member__arg, int32_t members__arg, int32_t field__arg, int32_t fields__arg);

  struct_with_special_names(struct_with_special_names&&) = default;

  struct_with_special_names(const struct_with_special_names&) = default;

  struct_with_special_names& operator=(struct_with_special_names&&) = default;

  struct_with_special_names& operator=(const struct_with_special_names&) = default;
  void __clear();
  int32_t get;
  int32_t getter;
  int32_t lists;
  int32_t maps;
  int32_t name;
  int32_t name_to_value;
  int32_t names;
  int32_t prefix_tree;
  int32_t sets;
  int32_t setter;
  int32_t str;
  int32_t strings;
  int32_t type;
  int32_t value;
  int32_t value_to_name;
  int32_t values;
  int32_t id;
  int32_t ids;
  int32_t descriptor;
  int32_t descriptors;
  int32_t key;
  int32_t keys;
  int32_t annotation;
  int32_t annotations;
  int32_t member;
  int32_t members;
  int32_t field;
  int32_t fields;

  struct __isset {
    bool get;
    bool getter;
    bool lists;
    bool maps;
    bool name;
    bool name_to_value;
    bool names;
    bool prefix_tree;
    bool sets;
    bool setter;
    bool str;
    bool strings;
    bool type;
    bool value;
    bool value_to_name;
    bool values;
    bool id;
    bool ids;
    bool descriptor;
    bool descriptors;
    bool key;
    bool keys;
    bool annotation;
    bool annotations;
    bool member;
    bool members;
    bool field;
    bool fields;
  } __isset = {};
  bool operator==(const struct_with_special_names& rhs) const;
  bool operator<(const struct_with_special_names& rhs) const;

  int32_t get_get() const {
    return get;
  }

  int32_t& set_get(int32_t get_) {
    get = get_;
    __isset.get = true;
    return get;
  }

  int32_t get_getter() const {
    return getter;
  }

  int32_t& set_getter(int32_t getter_) {
    getter = getter_;
    __isset.getter = true;
    return getter;
  }

  int32_t get_lists() const {
    return lists;
  }

  int32_t& set_lists(int32_t lists_) {
    lists = lists_;
    __isset.lists = true;
    return lists;
  }

  int32_t get_maps() const {
    return maps;
  }

  int32_t& set_maps(int32_t maps_) {
    maps = maps_;
    __isset.maps = true;
    return maps;
  }

  int32_t get_name() const {
    return name;
  }

  int32_t& set_name(int32_t name_) {
    name = name_;
    __isset.name = true;
    return name;
  }

  int32_t get_name_to_value() const {
    return name_to_value;
  }

  int32_t& set_name_to_value(int32_t name_to_value_) {
    name_to_value = name_to_value_;
    __isset.name_to_value = true;
    return name_to_value;
  }

  int32_t get_names() const {
    return names;
  }

  int32_t& set_names(int32_t names_) {
    names = names_;
    __isset.names = true;
    return names;
  }

  int32_t get_prefix_tree() const {
    return prefix_tree;
  }

  int32_t& set_prefix_tree(int32_t prefix_tree_) {
    prefix_tree = prefix_tree_;
    __isset.prefix_tree = true;
    return prefix_tree;
  }

  int32_t get_sets() const {
    return sets;
  }

  int32_t& set_sets(int32_t sets_) {
    sets = sets_;
    __isset.sets = true;
    return sets;
  }

  int32_t get_setter() const {
    return setter;
  }

  int32_t& set_setter(int32_t setter_) {
    setter = setter_;
    __isset.setter = true;
    return setter;
  }

  int32_t get_str() const {
    return str;
  }

  int32_t& set_str(int32_t str_) {
    str = str_;
    __isset.str = true;
    return str;
  }

  int32_t get_strings() const {
    return strings;
  }

  int32_t& set_strings(int32_t strings_) {
    strings = strings_;
    __isset.strings = true;
    return strings;
  }

  int32_t get_type() const {
    return type;
  }

  int32_t& set_type(int32_t type_) {
    type = type_;
    __isset.type = true;
    return type;
  }

  int32_t get_value() const {
    return value;
  }

  int32_t& set_value(int32_t value_) {
    value = value_;
    __isset.value = true;
    return value;
  }

  int32_t get_value_to_name() const {
    return value_to_name;
  }

  int32_t& set_value_to_name(int32_t value_to_name_) {
    value_to_name = value_to_name_;
    __isset.value_to_name = true;
    return value_to_name;
  }

  int32_t get_values() const {
    return values;
  }

  int32_t& set_values(int32_t values_) {
    values = values_;
    __isset.values = true;
    return values;
  }

  int32_t get_id() const {
    return id;
  }

  int32_t& set_id(int32_t id_) {
    id = id_;
    __isset.id = true;
    return id;
  }

  int32_t get_ids() const {
    return ids;
  }

  int32_t& set_ids(int32_t ids_) {
    ids = ids_;
    __isset.ids = true;
    return ids;
  }

  int32_t get_descriptor() const {
    return descriptor;
  }

  int32_t& set_descriptor(int32_t descriptor_) {
    descriptor = descriptor_;
    __isset.descriptor = true;
    return descriptor;
  }

  int32_t get_descriptors() const {
    return descriptors;
  }

  int32_t& set_descriptors(int32_t descriptors_) {
    descriptors = descriptors_;
    __isset.descriptors = true;
    return descriptors;
  }

  int32_t get_key() const {
    return key;
  }

  int32_t& set_key(int32_t key_) {
    key = key_;
    __isset.key = true;
    return key;
  }

  int32_t get_keys() const {
    return keys;
  }

  int32_t& set_keys(int32_t keys_) {
    keys = keys_;
    __isset.keys = true;
    return keys;
  }

  int32_t get_annotation() const {
    return annotation;
  }

  int32_t& set_annotation(int32_t annotation_) {
    annotation = annotation_;
    __isset.annotation = true;
    return annotation;
  }

  int32_t get_annotations() const {
    return annotations;
  }

  int32_t& set_annotations(int32_t annotations_) {
    annotations = annotations_;
    __isset.annotations = true;
    return annotations;
  }

  int32_t get_member() const {
    return member;
  }

  int32_t& set_member(int32_t member_) {
    member = member_;
    __isset.member = true;
    return member;
  }

  int32_t get_members() const {
    return members;
  }

  int32_t& set_members(int32_t members_) {
    members = members_;
    __isset.members = true;
    return members;
  }

  int32_t get_field() const {
    return field;
  }

  int32_t& set_field(int32_t field_) {
    field = field_;
    __isset.field = true;
    return field;
  }

  int32_t get_fields() const {
    return fields;
  }

  int32_t& set_fields(int32_t fields_) {
    fields = fields_;
    __isset.fields = true;
    return fields;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< struct_with_special_names >;
};

void swap(struct_with_special_names& a, struct_with_special_names& b);

template <class Protocol_>
uint32_t struct_with_special_names::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
namespace test_cpp2 { namespace cpp_reflection {
class struct_with_indirections final : private apache::thrift::detail::st::ComparisonOperators<struct_with_indirections> {
 public:

  struct_with_indirections();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  struct_with_indirections(apache::thrift::FragileConstructor, int32_t real__arg,  ::test_cpp2::cpp_reflection::FakeI32 fake__arg,  ::test_cpp2::cpp_reflection::HasANumber number__arg,  ::test_cpp2::cpp_reflection::HasAResult result__arg,  ::test_cpp2::cpp_reflection::HasAPhrase phrase__arg);

  struct_with_indirections(struct_with_indirections&&) = default;

  struct_with_indirections(const struct_with_indirections&) = default;

  struct_with_indirections& operator=(struct_with_indirections&&) = default;

  struct_with_indirections& operator=(const struct_with_indirections&) = default;
  void __clear();

  ~struct_with_indirections();

  int32_t real;
   ::test_cpp2::cpp_reflection::FakeI32 fake;
   ::test_cpp2::cpp_reflection::HasANumber number;
   ::test_cpp2::cpp_reflection::HasAResult result;
   ::test_cpp2::cpp_reflection::HasAPhrase phrase;

  struct __isset {
    bool real;
    bool fake;
    bool number;
    bool result;
    bool phrase;
  } __isset = {};
  bool operator==(const struct_with_indirections& rhs) const;
  bool operator<(const struct_with_indirections& rhs) const;

  int32_t get_real() const {
    return real;
  }

  int32_t& set_real(int32_t real_) {
    real = real_;
    __isset.real = true;
    return real;
  }

   ::test_cpp2::cpp_reflection::FakeI32 get_fake() const {
    return fake;
  }

   ::test_cpp2::cpp_reflection::FakeI32& set_fake( ::test_cpp2::cpp_reflection::FakeI32 fake_) {
    fake = fake_;
    __isset.fake = true;
    return fake;
  }

   ::test_cpp2::cpp_reflection::HasANumber get_number() const {
    return number;
  }

   ::test_cpp2::cpp_reflection::HasANumber& set_number( ::test_cpp2::cpp_reflection::HasANumber number_) {
    number = number_;
    __isset.number = true;
    return number;
  }

   ::test_cpp2::cpp_reflection::HasAResult get_result() const {
    return result;
  }

   ::test_cpp2::cpp_reflection::HasAResult& set_result( ::test_cpp2::cpp_reflection::HasAResult result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const  ::test_cpp2::cpp_reflection::HasAPhrase& get_phrase() const& {
    return phrase;
  }

   ::test_cpp2::cpp_reflection::HasAPhrase get_phrase() && {
    return std::move(phrase);
  }

  template <typename T_struct_with_indirections_phrase_struct_setter =  ::test_cpp2::cpp_reflection::HasAPhrase>
   ::test_cpp2::cpp_reflection::HasAPhrase& set_phrase(T_struct_with_indirections_phrase_struct_setter&& phrase_) {
    phrase = std::forward<T_struct_with_indirections_phrase_struct_setter>(phrase_);
    __isset.phrase = true;
    return phrase;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< struct_with_indirections >;
};

void swap(struct_with_indirections& a, struct_with_indirections& b);

template <class Protocol_>
uint32_t struct_with_indirections::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // test_cpp2::cpp_reflection
