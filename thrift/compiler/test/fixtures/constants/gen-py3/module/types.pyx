#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer cimport IOBuf
from thrift.py3.serializer import Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize

import sys
from collections.abc import Sequence, Set, Mapping, Iterable
from enum import Enum


class EmptyEnum(Enum):

cdef cEmptyEnum EmptyEnum_to_cpp(value):
class City(Enum):
    NYC = <int> (City__NYC)
    MPK = <int> (City__MPK)
    SEA = <int> (City__SEA)
    LON = <int> (City__LON)

cdef cCity City_to_cpp(value):
    if value == City.NYC:
        return City__NYC
    elif value == City.MPK:
        return City__MPK
    elif value == City.SEA:
        return City__SEA
    elif value == City.LON:
        return City__LON
class Company(Enum):
    FACEBOOK = <int> (Company__FACEBOOK)
    WHATSAPP = <int> (Company__WHATSAPP)
    OCULUS = <int> (Company__OCULUS)
    INSTAGRAM = <int> (Company__INSTAGRAM)

cdef cCompany Company_to_cpp(value):
    if value == Company.FACEBOOK:
        return Company__FACEBOOK
    elif value == Company.WHATSAPP:
        return Company__WHATSAPP
    elif value == Company.OCULUS:
        return Company__OCULUS
    elif value == Company.INSTAGRAM:
        return Company__INSTAGRAM


cdef class Internship(thrift.py3.types.Struct):

    def __init__(
        Internship self,
        weeks=None,
        title=None,
        employer=None
    ):
        self._cpp_obj = make_shared[cInternship]()

        inst = self
        if weeks is not None:
            deref(inst._cpp_obj).weeks = weeks
        if title is not None:
            deref(inst._cpp_obj).title = title.encode('UTF-8')
            deref(inst._cpp_obj).__isset.title = True

        if employer is not None:
            deref(inst._cpp_obj).employer = Company_to_cpp(employer)
            deref(inst._cpp_obj).__isset.employer = True


    cdef bytes _serialize(Internship self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cInternship](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cInternship](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cInternship](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(Internship self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cInternship](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cInternship](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cInternship](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (Internship, serialize(self)))

    def __call__(
        Internship self,
        weeks=NOTSET,
        title=NOTSET,
        employer=NOTSET
    ):
        changes = any((
            weeks is not NOTSET,

            title is not NOTSET,

            employer is not NOTSET,
        ))

        if not changes:
            return self

        inst = <Internship>Internship.__new__(Internship)
        inst._cpp_obj = make_shared[cInternship](deref(self._cpp_obj))
        cdef Internship defaults = Internship_defaults

        # Convert None's to default value.
        if weeks is None:
            deref(inst._cpp_obj).weeks = deref(defaults._cpp_obj).weeks
        if weeks is NOTSET:
            weeks = None
        if title is None:
            deref(inst._cpp_obj).title = deref(defaults._cpp_obj).title
            deref(inst._cpp_obj).__isset.title = False
        if title is NOTSET:
            title = None
        if employer is None:
            deref(inst._cpp_obj).employer = deref(defaults._cpp_obj).employer
            deref(inst._cpp_obj).__isset.employer = False
        if employer is NOTSET:
            employer = None

        if weeks is not None:
            deref(inst._cpp_obj).weeks = weeks
        if title is not None:
            deref(inst._cpp_obj).title = title.encode('UTF-8')
            deref(inst._cpp_obj).__isset.title = True

        if employer is not None:
            deref(inst._cpp_obj).employer = Company_to_cpp(employer)
            deref(inst._cpp_obj).__isset.employer = True

        return inst

    def __iter__(self):
        yield 'weeks', self.weeks
        yield 'title', self.title
        yield 'employer', self.employer

    def __bool__(self):
        return True or deref(self._cpp_obj).__isset.title or deref(self._cpp_obj).__isset.employer

    @staticmethod
    cdef create(shared_ptr[cInternship] cpp_obj):
        inst = <Internship>Internship.__new__(Internship)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def weeks(self):

        return self._cpp_obj.get().weeks

    @property
    def title(self):
        if not deref(self._cpp_obj).__isset.title:
            return None

        return self._cpp_obj.get().title.decode('UTF-8')

    @property
    def employer(self):
        if not deref(self._cpp_obj).__isset.employer:
            return None

        cdef int value = <int> deref(self._cpp_obj).employer
        try:
            return Company(value)
        except ValueError:
            return thrift.py3.types.BadEnum(Company, value)
        


    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, Internship) and
                isinstance(other, Internship)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cInternship cself = deref((<Internship>self)._cpp_obj)
        cdef cInternship cother = deref((<Internship>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    def __hash__(Internship self):
        if not self.__hash:
            self.__hash = hash((
            self.weeks,
            self.title,
            self.employer,
            ))
        return self.__hash

    def __repr__(Internship self):
        return f'Internship(weeks={repr(self.weeks)}, title={repr(self.title)}, employer={repr(self.employer)})'


Internship_defaults = Internship()


cdef class UnEnumStruct(thrift.py3.types.Struct):

    def __init__(
        UnEnumStruct self,
        city=None
    ):
        self._cpp_obj = make_shared[cUnEnumStruct]()

        inst = self
        if city is not None:
            deref(inst._cpp_obj).city = City_to_cpp(city)
            deref(inst._cpp_obj).__isset.city = True


    cdef bytes _serialize(UnEnumStruct self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cUnEnumStruct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cUnEnumStruct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cUnEnumStruct](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(UnEnumStruct self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cUnEnumStruct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cUnEnumStruct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cUnEnumStruct](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (UnEnumStruct, serialize(self)))

    def __call__(
        UnEnumStruct self,
        city=NOTSET
    ):
        changes = any((
            city is not NOTSET,
        ))

        if not changes:
            return self

        inst = <UnEnumStruct>UnEnumStruct.__new__(UnEnumStruct)
        inst._cpp_obj = make_shared[cUnEnumStruct](deref(self._cpp_obj))
        cdef UnEnumStruct defaults = UnEnumStruct_defaults

        # Convert None's to default value.
        if city is None:
            deref(inst._cpp_obj).city = deref(defaults._cpp_obj).city
            deref(inst._cpp_obj).__isset.city = False
        if city is NOTSET:
            city = None

        if city is not None:
            deref(inst._cpp_obj).city = City_to_cpp(city)
            deref(inst._cpp_obj).__isset.city = True

        return inst

    def __iter__(self):
        yield 'city', self.city

    def __bool__(self):
        return deref(self._cpp_obj).__isset.city

    @staticmethod
    cdef create(shared_ptr[cUnEnumStruct] cpp_obj):
        inst = <UnEnumStruct>UnEnumStruct.__new__(UnEnumStruct)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def city(self):

        cdef int value = <int> deref(self._cpp_obj).city
        try:
            return City(value)
        except ValueError:
            return thrift.py3.types.BadEnum(City, value)
        


    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, UnEnumStruct) and
                isinstance(other, UnEnumStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cUnEnumStruct cself = deref((<UnEnumStruct>self)._cpp_obj)
        cdef cUnEnumStruct cother = deref((<UnEnumStruct>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    def __hash__(UnEnumStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.city,
            ))
        return self.__hash

    def __repr__(UnEnumStruct self):
        return f'UnEnumStruct(city={repr(self.city)})'


UnEnumStruct_defaults = UnEnumStruct()


cdef class Range(thrift.py3.types.Struct):

    def __init__(
        Range self,
        min=None,
        max=None
    ):
        self._cpp_obj = make_shared[cRange]()

        inst = self
        if min is not None:
            deref(inst._cpp_obj).min = min
        if max is not None:
            deref(inst._cpp_obj).max = max

    cdef bytes _serialize(Range self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cRange](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cRange](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cRange](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(Range self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cRange](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cRange](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cRange](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (Range, serialize(self)))

    def __call__(
        Range self,
        min=NOTSET,
        max=NOTSET
    ):
        changes = any((
            min is not NOTSET,

            max is not NOTSET,
        ))

        if not changes:
            return self

        inst = <Range>Range.__new__(Range)
        inst._cpp_obj = make_shared[cRange](deref(self._cpp_obj))
        cdef Range defaults = Range_defaults

        # Convert None's to default value.
        if min is None:
            deref(inst._cpp_obj).min = deref(defaults._cpp_obj).min
        if min is NOTSET:
            min = None
        if max is None:
            deref(inst._cpp_obj).max = deref(defaults._cpp_obj).max
        if max is NOTSET:
            max = None

        if min is not None:
            deref(inst._cpp_obj).min = min
        if max is not None:
            deref(inst._cpp_obj).max = max
        return inst

    def __iter__(self):
        yield 'min', self.min
        yield 'max', self.max

    def __bool__(self):
        return True or True

    @staticmethod
    cdef create(shared_ptr[cRange] cpp_obj):
        inst = <Range>Range.__new__(Range)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def min(self):

        return self._cpp_obj.get().min

    @property
    def max(self):

        return self._cpp_obj.get().max


    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, Range) and
                isinstance(other, Range)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cRange cself = deref((<Range>self)._cpp_obj)
        cdef cRange cother = deref((<Range>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    def __hash__(Range self):
        if not self.__hash:
            self.__hash = hash((
            self.min,
            self.max,
            ))
        return self.__hash

    def __repr__(Range self):
        return f'Range(min={repr(self.min)}, max={repr(self.max)})'


Range_defaults = Range()


cdef class Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__string_i32):
            self._cpp_obj = (<Map__string_i32> items)._cpp_obj
        else:
          self._cpp_obj = make_shared[cmap[string,int32_t]]()
          if items:
              for key, item in items.items():
                  deref(self._cpp_obj).insert(
                      cpair[string,int32_t](
                          key.encode('UTF-8'),
                          item))

    @staticmethod
    cdef create(shared_ptr[cmap[string,int32_t]] c_items):
        inst = <Map__string_i32>Map__string_i32.__new__(Map__string_i32)
        inst._cpp_obj = c_items
        return inst

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int32_t].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef int32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{i[0]}: {i[1]}", self.items()))}}}'



    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,int32_t].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef int32_t citem = deref(iter).second
        return citem

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), citem)



Mapping.register(Map__string_i32)

cdef class List__Map__string_i32:
    def __init__(self, items=None):
        if isinstance(items, List__Map__string_i32):
            self._cpp_obj = (<List__Map__string_i32> items)._cpp_obj
        else:
          self._cpp_obj = make_shared[vector[cmap[string,int32_t]]]()
          if items:
              for item in items:
                  deref(self._cpp_obj).push_back(cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get())))

    @staticmethod
    cdef create(
            shared_ptr[vector[cmap[string,int32_t]]] c_items):
        inst = <List__Map__string_i32>List__Map__string_i32.__new__(List__Map__string_i32)
        inst._cpp_obj = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef cmap[string,int32_t] citem = (
            deref(self._cpp_obj.get())[index])
        return Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cmap[string,int32_t] citem = cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get()))
        cdef vector[cmap[string,int32_t]] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cmap[string,int32_t] citem
        for citem in deref(self._cpp_obj):
            yield Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cmap[string,int32_t] citem
        cdef vector[cmap[string,int32_t]] vec = deref(
            self._cpp_obj.get())
        cdef vector[cmap[string,int32_t]].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Map__string_i32.create(
    make_shared[cmap[string,int32_t]](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cmap[string,int32_t] citem = cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get()))
        cdef vector[cmap[string,int32_t]] vec = deref(self._cpp_obj.get())
        cdef vector[cmap[string,int32_t]].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cmap[string,int32_t] citem = cmap[string,int32_t](deref(Map__string_i32(item)._cpp_obj.get()))
        cdef vector[cmap[string,int32_t]] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Map__string_i32)

cdef class List__Range:
    def __init__(self, items=None):
        if isinstance(items, List__Range):
            self._cpp_obj = (<List__Range> items)._cpp_obj
        else:
          self._cpp_obj = make_shared[vector[cRange]]()
          if items:
              for item in items:
                  deref(self._cpp_obj).push_back(deref((<Range> item)._cpp_obj))

    @staticmethod
    cdef create(
            shared_ptr[vector[cRange]] c_items):
        inst = <List__Range>List__Range.__new__(List__Range)
        inst._cpp_obj = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef cRange citem = (
            deref(self._cpp_obj.get())[index])
        return Range.create(make_shared[cRange](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cRange citem = deref((<Range> item)._cpp_obj)
        cdef vector[cRange] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cRange citem
        for citem in deref(self._cpp_obj):
            yield Range.create(make_shared[cRange](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cRange citem
        cdef vector[cRange] vec = deref(
            self._cpp_obj.get())
        cdef vector[cRange].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Range.create(make_shared[cRange](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cRange citem = deref((<Range> item)._cpp_obj)
        cdef vector[cRange] vec = deref(self._cpp_obj.get())
        cdef vector[cRange].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cRange citem = deref((<Range> item)._cpp_obj)
        cdef vector[cRange] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Range)

cdef class List__Internship:
    def __init__(self, items=None):
        if isinstance(items, List__Internship):
            self._cpp_obj = (<List__Internship> items)._cpp_obj
        else:
          self._cpp_obj = make_shared[vector[cInternship]]()
          if items:
              for item in items:
                  deref(self._cpp_obj).push_back(deref((<Internship> item)._cpp_obj))

    @staticmethod
    cdef create(
            shared_ptr[vector[cInternship]] c_items):
        inst = <List__Internship>List__Internship.__new__(List__Internship)
        inst._cpp_obj = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef cInternship citem = (
            deref(self._cpp_obj.get())[index])
        return Internship.create(make_shared[cInternship](citem))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef cInternship citem = deref((<Internship> item)._cpp_obj)
        cdef vector[cInternship] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef cInternship citem
        for citem in deref(self._cpp_obj):
            yield Internship.create(make_shared[cInternship](citem))

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef cInternship citem
        cdef vector[cInternship] vec = deref(
            self._cpp_obj.get())
        cdef vector[cInternship].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield Internship.create(make_shared[cInternship](citem))
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef cInternship citem = deref((<Internship> item)._cpp_obj)
        cdef vector[cInternship] vec = deref(self._cpp_obj.get())
        cdef vector[cInternship].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef cInternship citem = deref((<Internship> item)._cpp_obj)
        cdef vector[cInternship] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__Internship)

cdef class List__string:
    def __init__(self, items=None):
        if isinstance(items, List__string):
            self._cpp_obj = (<List__string> items)._cpp_obj
        else:
          self._cpp_obj = make_shared[vector[string]]()
          if items:
              for item in items:
                  deref(self._cpp_obj).push_back(item.encode('UTF-8'))

    @staticmethod
    cdef create(
            shared_ptr[vector[string]] c_items):
        inst = <List__string>List__string.__new__(List__string)
        inst._cpp_obj = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef string citem = (
            deref(self._cpp_obj.get())[index])
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for citem in deref(self._cpp_obj):
            yield bytes(citem).decode('UTF-8')

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef string citem
        cdef vector[string] vec = deref(
            self._cpp_obj.get())
        cdef vector[string].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield bytes(citem).decode('UTF-8')
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(self._cpp_obj.get())
        cdef vector[string].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef string citem = item.encode('UTF-8')
        cdef vector[string] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__string)

cdef class List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
          self._cpp_obj = make_shared[vector[int32_t]]()
          if items:
              for item in items:
                  deref(self._cpp_obj).push_back(item)

    @staticmethod
    cdef create(
            shared_ptr[vector[int32_t]] c_items):
        inst = <List__i32>List__i32.__new__(List__i32)
        inst._cpp_obj = c_items
        return inst

    def __getitem__(self, int index):
        size = len(self)
        # Convert a negative index
        if index < 0:
            index = size - index
        if index >= size:
            raise IndexError('list index out of range')
        # Support negative indexes
        if index < 0:
            index = size - index
        cdef int32_t citem = (
            deref(self._cpp_obj.get())[index])
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef vector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        cdef vector[int32_t].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i32)

cdef class Set__i32:
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._cpp_obj = (<Set__i32> items)._cpp_obj
        else:
          self._cpp_obj = make_shared[cset[int32_t]]()
          if items:
              for item in items:
                  deref(self._cpp_obj).insert(item)

    @staticmethod
    cdef create(shared_ptr[cset[int32_t]] c_items):
        inst = <Set__i32>Set__i32.__new__(Set__i32)
        inst._cpp_obj = c_items
        return inst

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._cpp_obj).count(item))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[int32_t] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__i32) and
                isinstance(other, Set__i32)):
            cself = deref((<Set__i32> self)._cpp_obj)
            cother = deref((<Set__i32> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__i32):
            self = Set__i32(self)
        if not isinstance(other, Set__i32):
            other = Set__i32(other)

        cdef shared_ptr[cset[int32_t]] shretval = \
            make_shared[cset[int32_t]]()
        for citem in deref((<Set__i32> self)._cpp_obj):
            if deref((<Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__i32> other)._cpp_obj):
            if deref((<Set__i32> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__i32.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__i32)

cdef class Set__string:
    def __init__(self, items=None):
        if isinstance(items, Set__string):
            self._cpp_obj = (<Set__string> items)._cpp_obj
        else:
          self._cpp_obj = make_shared[cset[string]]()
          if items:
              for item in items:
                  deref(self._cpp_obj).insert(item.encode('UTF-8'))

    @staticmethod
    cdef create(shared_ptr[cset[string]] c_items):
        inst = <Set__string>Set__string.__new__(Set__string)
        inst._cpp_obj = c_items
        return inst

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._cpp_obj).count(item.encode('UTF-8')))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield bytes(citem).decode('UTF-8')

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef cset[string] cself, cother
        cdef cbool retval
        if (isinstance(self, Set__string) and
                isinstance(other, Set__string)):
            cself = deref((<Set__string> self)._cpp_obj)
            cother = deref((<Set__string> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __or__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._cpp_obj):
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, Set__string):
            self = Set__string(self)
        if not isinstance(other, Set__string):
            other = Set__string(other)

        cdef shared_ptr[cset[string]] shretval = \
            make_shared[cset[string]]()
        for citem in deref((<Set__string> self)._cpp_obj):
            if deref((<Set__string> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<Set__string> other)._cpp_obj):
            if deref((<Set__string> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return Set__string.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__string)

cdef class Map__i32_i32:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_i32):
            self._cpp_obj = (<Map__i32_i32> items)._cpp_obj
        else:
          self._cpp_obj = make_shared[cmap[int32_t,int32_t]]()
          if items:
              for key, item in items.items():
                  deref(self._cpp_obj).insert(
                      cpair[int32_t,int32_t](
                          key,
                          item))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,int32_t]] c_items):
        inst = <Map__i32_i32>Map__i32_i32.__new__(Map__i32_i32)
        inst._cpp_obj = c_items
        return inst

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef int32_t ckey = key
        cdef cmap[int32_t,int32_t].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef int32_t citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{i[0]}: {i[1]}", self.items()))}}}'



    def __contains__(self, key):
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef int32_t ckey = key
        cdef cmap[int32_t,int32_t].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef int32_t citem = deref(iter).second
        return citem

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield citem

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, citem)



Mapping.register(Map__i32_i32)

cdef class Map__i32_string:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_string):
            self._cpp_obj = (<Map__i32_string> items)._cpp_obj
        else:
          self._cpp_obj = make_shared[cmap[int32_t,string]]()
          if items:
              for key, item in items.items():
                  deref(self._cpp_obj).insert(
                      cpair[int32_t,string](
                          key,
                          item.encode('UTF-8')))

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,string]] c_items):
        inst = <Map__i32_string>Map__i32_string.__new__(Map__i32_string)
        inst._cpp_obj = c_items
        return inst

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef int32_t ckey = key
        cdef cmap[int32_t,string].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{i[0]}: {i[1]}", self.items()))}}}'



    def __contains__(self, key):
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef int32_t ckey = key
        cdef cmap[int32_t,string].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef string citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, bytes(citem).decode('UTF-8'))



Mapping.register(Map__i32_string)

cdef class Map__string_string:
    def __init__(self, items=None):
        if isinstance(items, Map__string_string):
            self._cpp_obj = (<Map__string_string> items)._cpp_obj
        else:
          self._cpp_obj = make_shared[cmap[string,string]]()
          if items:
              for key, item in items.items():
                  deref(self._cpp_obj).insert(
                      cpair[string,string](
                          key.encode('UTF-8'),
                          item.encode('UTF-8')))

    @staticmethod
    cdef create(shared_ptr[cmap[string,string]] c_items):
        inst = <Map__string_string>Map__string_string.__new__(Map__string_string)
        inst._cpp_obj = c_items
        return inst

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,string].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield bytes(citem).decode('UTF-8')

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{i[0]}: {i[1]}", self.items()))}}}'



    def __contains__(self, key):
        cdef string ckey = key.encode('UTF-8')
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef string ckey = key.encode('UTF-8')
        cdef cmap[string,string].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef string ckey
        cdef string citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey.decode('UTF-8'), bytes(citem).decode('UTF-8'))



Mapping.register(Map__string_string)

myInt = 1337
name = cname().decode('UTF-8')
states = List__Map__string_i32.create(make_shared[vector[cmap[string,int32_t]]](cstates()))
x = 1.0
y = 1000000.0
z = 1000000000.0
instagram = Internship.create(
    make_shared[cInternship](cinstagram()))
kRanges = List__Range.create(make_shared[vector[cRange]](ckRanges()))
internList = List__Internship.create(make_shared[vector[cInternship]](cinternList()))
apostrophe = capostrophe().decode('UTF-8')
tripleApostrophe = ctripleApostrophe().decode('UTF-8')
quotationMark = cquotationMark().decode('UTF-8')
backslash = cbackslash().decode('UTF-8')
escaped_a = cescaped_a().decode('UTF-8')
char2ascii = Map__string_i32.create(make_shared[cmap[string,int32_t]](cchar2ascii()))
escaped_strings = List__string.create(make_shared[vector[string]](cescaped_strings()))
false_c = False
true_c = True
zero_byte = 0
zero16 = 0
zero32 = 0
zero64 = 0
zero_dot_zero = 0.0
empty_string = cempty_string().decode('UTF-8')
empty_int_list = List__i32.create(make_shared[vector[int32_t]](cempty_int_list()))
empty_string_list = List__string.create(make_shared[vector[string]](cempty_string_list()))
empty_int_set = Set__i32.create(make_shared[cset[int32_t]](cempty_int_set()))
empty_string_set = Set__string.create(make_shared[cset[string]](cempty_string_set()))
empty_int_int_map = Map__i32_i32.create(make_shared[cmap[int32_t,int32_t]](cempty_int_int_map()))
empty_int_string_map = Map__i32_string.create(make_shared[cmap[int32_t,string]](cempty_int_string_map()))
empty_string_int_map = Map__string_i32.create(make_shared[cmap[string,int32_t]](cempty_string_int_map()))
empty_string_string_map = Map__string_string.create(make_shared[cmap[string,string]](cempty_string_string_map()))
