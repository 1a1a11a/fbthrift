<?hh
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

interface MyServiceIf {
  /**
   * Original thrift definition:-
   * void
   *   ping();
   */
  public function ping(): void;

  /**
   * Original thrift definition:-
   * string
   *   getRandomData();
   */
  public function getRandomData(): string;

  /**
   * Original thrift definition:-
   * bool
   *   hasDataById(1: i64 id);
   */
  public function hasDataById(int $id): bool;

  /**
   * Original thrift definition:-
   * string
   *   getDataById(1: i64 id);
   */
  public function getDataById(int $id): string;

  /**
   * Original thrift definition:-
   * void
   *   putDataById(1: i64 id,
   *               2: string data);
   */
  public function putDataById(int $id, string $data): void;

  /**
   * Original thrift definition:-
   * oneway void
   *   lobDataById(1: i64 id,
   *               2: string data);
   */
  public function lobDataById(int $id, string $data): void;
}

<<__ConsistentConstruct>>
class MyServiceClient implements MyServiceIf, IThriftClient {
  protected TProtocol $input_;
  protected TProtocol $output_;
  protected TClientAsyncHandler $asyncHandler_;
  protected TClientEventHandler $eventHandler_;

  protected int $seqid_ = 0;

  final public static function factory(): (string, (function (TProtocol, ?TProtocol): this)) {
    return tuple(get_called_class(), function(TProtocol $input, ?TProtocol $output) {
      return new static($input, $output);
    });
  }

  public function __construct(TProtocol $input, ?TProtocol $output = null) {
    $this->input_ = $input;
    $this->output_ = $output ?: $input;
    $this->asyncHandler_ = new TClientAsyncHandler();
    $this->eventHandler_ = new TClientEventHandler();
  }

  public function setEventHandler(TClientEventHandler $event_handler): this {
    $this->eventHandler_ = $event_handler;
    return $this;
  }

  public function getEventHandler(): TClientEventHandler {
    return $this->eventHandler_;
  }

  public function setAsyncHandler(TClientAsyncHandler $async_handler): this {
    $this->asyncHandler_ = $async_handler;
    return $this;
  }

  public function getAsyncHandler(): TClientAsyncHandler {
    return $this->asyncHandler_;
  }

  private function getsequenceid(): int {
    $currentseqid = $this->seqid_;
    if ($this->seqid_ >= 0x7fffffff) {
       $this->seqid_ = 0;
    } else {
       $this->seqid_++;
    }
    return $currentseqid;
  }

  /**
   * Original thrift definition:-
   * void
   *   ping();
   */
  public function ping(): void {
    $currentseqid = $this->send_ping();
    $this->recv_ping($currentseqid);
  }

  public async function gen_ping(): Awaitable<void> {
    $currentseqid = $this->send_ping();
    await $this->asyncHandler_->genWait($currentseqid);
    $this->recv_ping($currentseqid);
  }

  public function send_ping(): int {
    $currentseqid = $this->getsequenceid();
    $args = new MyService_ping_args();
    try {
      $this->eventHandler_->preSend('ping', $args, $currentseqid);
      if ($this->output_ instanceof TBinaryProtocolAccelerated)
      {
        thrift_protocol_write_binary($this->output_, 'ping', TMessageType::CALL, $args, $currentseqid, $this->output_->isStrictWrite(), false);
      }
      else if ($this->output_ instanceof TCompactProtocolAccelerated)
      {
        thrift_protocol_write_compact($this->output_, 'ping', TMessageType::CALL, $args, $currentseqid, false);
      }
      else
      {
        $this->output_->writeMessageBegin('ping', TMessageType::CALL, $currentseqid);
        $args->write($this->output_);
        $this->output_->writeMessageEnd();
        $this->output_->getTransport()->flush();
      }
    } catch (THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case THandlerShortCircuitException::R_EXPECTED_EX:
        case THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->sendError('ping', $args, $currentseqid, $ex->result);
          throw $ex->result;
        case THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postSend('ping', $args, $currentseqid);
          return $currentseqid;
      }
    } catch (Exception $ex) {
      $this->eventHandler_->sendError('ping', $args, $currentseqid, $ex);
      throw $ex;
    }
    $this->eventHandler_->postSend('ping', $args, $currentseqid);
    return $currentseqid;
  }

  public function recv_ping(?int $expectedsequenceid = null): void {
    try {
      $this->eventHandler_->preRecv('ping', $expectedsequenceid);
      if ($this->input_ instanceof TBinaryProtocolAccelerated) {
        $result = thrift_protocol_read_binary($this->input_, 'MyService_ping_result', $this->input_->isStrictRead());
      } else if ($this->input_ instanceof TCompactProtocolAccelerated)
      {
        $result = thrift_protocol_read_compact($this->input_, 'MyService_ping_result');
      }
      else
      {
        $rseqid = 0;
        $fname = '';
        $mtype = 0;

        $this->input_->readMessageBegin($fname, $mtype, $rseqid);
        if ($mtype == TMessageType::EXCEPTION) {
          $x = new TApplicationException();
          $x->read($this->input_);
          $this->input_->readMessageEnd();
          throw $x;
        }
        $result = new MyService_ping_result();
        $result->read($this->input_);
        $this->input_->readMessageEnd();
        if ($expectedsequenceid !== null && ($rseqid != $expectedsequenceid)) {
          throw new TProtocolException("ping failed: sequence id is out of order");
        }
      }
    } catch (THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case THandlerShortCircuitException::R_EXPECTED_EX:
          $this->eventHandler_->recvException('ping', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->recvError('ping', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postRecv('ping', $expectedsequenceid, $ex->result);
          return;
      }
    } catch (Exception $ex) {
      $this->eventHandler_->recvError('ping', $expectedsequenceid, $ex);
      throw $ex;
    }
          $this->eventHandler_->postRecv('ping', $expectedsequenceid, null);
return;
  }

  /**
   * Original thrift definition:-
   * string
   *   getRandomData();
   */
  public function getRandomData(): string {
    $currentseqid = $this->send_getRandomData();
    return $this->recv_getRandomData($currentseqid);
  }

  public async function gen_getRandomData(): Awaitable<string> {
    $currentseqid = $this->send_getRandomData();
    await $this->asyncHandler_->genWait($currentseqid);
    return $this->recv_getRandomData($currentseqid);
  }

  public function send_getRandomData(): int {
    $currentseqid = $this->getsequenceid();
    $args = new MyService_getRandomData_args();
    try {
      $this->eventHandler_->preSend('getRandomData', $args, $currentseqid);
      if ($this->output_ instanceof TBinaryProtocolAccelerated)
      {
        thrift_protocol_write_binary($this->output_, 'getRandomData', TMessageType::CALL, $args, $currentseqid, $this->output_->isStrictWrite(), false);
      }
      else if ($this->output_ instanceof TCompactProtocolAccelerated)
      {
        thrift_protocol_write_compact($this->output_, 'getRandomData', TMessageType::CALL, $args, $currentseqid, false);
      }
      else
      {
        $this->output_->writeMessageBegin('getRandomData', TMessageType::CALL, $currentseqid);
        $args->write($this->output_);
        $this->output_->writeMessageEnd();
        $this->output_->getTransport()->flush();
      }
    } catch (THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case THandlerShortCircuitException::R_EXPECTED_EX:
        case THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->sendError('getRandomData', $args, $currentseqid, $ex->result);
          throw $ex->result;
        case THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postSend('getRandomData', $args, $currentseqid);
          return $currentseqid;
      }
    } catch (Exception $ex) {
      $this->eventHandler_->sendError('getRandomData', $args, $currentseqid, $ex);
      throw $ex;
    }
    $this->eventHandler_->postSend('getRandomData', $args, $currentseqid);
    return $currentseqid;
  }

  public function recv_getRandomData(?int $expectedsequenceid = null): string {
    try {
      $this->eventHandler_->preRecv('getRandomData', $expectedsequenceid);
      if ($this->input_ instanceof TBinaryProtocolAccelerated) {
        $result = thrift_protocol_read_binary($this->input_, 'MyService_getRandomData_result', $this->input_->isStrictRead());
      } else if ($this->input_ instanceof TCompactProtocolAccelerated)
      {
        $result = thrift_protocol_read_compact($this->input_, 'MyService_getRandomData_result');
      }
      else
      {
        $rseqid = 0;
        $fname = '';
        $mtype = 0;

        $this->input_->readMessageBegin($fname, $mtype, $rseqid);
        if ($mtype == TMessageType::EXCEPTION) {
          $x = new TApplicationException();
          $x->read($this->input_);
          $this->input_->readMessageEnd();
          throw $x;
        }
        $result = new MyService_getRandomData_result();
        $result->read($this->input_);
        $this->input_->readMessageEnd();
        if ($expectedsequenceid !== null && ($rseqid != $expectedsequenceid)) {
          throw new TProtocolException("getRandomData failed: sequence id is out of order");
        }
      }
    } catch (THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case THandlerShortCircuitException::R_EXPECTED_EX:
          $this->eventHandler_->recvException('getRandomData', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->recvError('getRandomData', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postRecv('getRandomData', $expectedsequenceid, $ex->result);
          return $ex->result;
      }
    } catch (Exception $ex) {
      $this->eventHandler_->recvError('getRandomData', $expectedsequenceid, $ex);
      throw $ex;
    }
    if ($result->success !== null) {
      $success = $result->success;
      $this->eventHandler_->postRecv('getRandomData', $expectedsequenceid, $success);
      return $success;
    }
    $x = new TApplicationException("getRandomData failed: unknown result", TApplicationException::MISSING_RESULT);
    $this->eventHandler_->recvError('getRandomData', $expectedsequenceid, $x);
    throw $x;
  }

  /**
   * Original thrift definition:-
   * bool
   *   hasDataById(1: i64 id);
   */
  public function hasDataById(int $id): bool {
    $currentseqid = $this->send_hasDataById($id);
    return $this->recv_hasDataById($currentseqid);
  }

  public async function gen_hasDataById(int $id): Awaitable<bool> {
    $currentseqid = $this->send_hasDataById($id);
    await $this->asyncHandler_->genWait($currentseqid);
    return $this->recv_hasDataById($currentseqid);
  }

  public function send_hasDataById(int $id): int {
    $currentseqid = $this->getsequenceid();
    $args = new MyService_hasDataById_args();
    $args->id = $id;
    try {
      $this->eventHandler_->preSend('hasDataById', $args, $currentseqid);
      if ($this->output_ instanceof TBinaryProtocolAccelerated)
      {
        thrift_protocol_write_binary($this->output_, 'hasDataById', TMessageType::CALL, $args, $currentseqid, $this->output_->isStrictWrite(), false);
      }
      else if ($this->output_ instanceof TCompactProtocolAccelerated)
      {
        thrift_protocol_write_compact($this->output_, 'hasDataById', TMessageType::CALL, $args, $currentseqid, false);
      }
      else
      {
        $this->output_->writeMessageBegin('hasDataById', TMessageType::CALL, $currentseqid);
        $args->write($this->output_);
        $this->output_->writeMessageEnd();
        $this->output_->getTransport()->flush();
      }
    } catch (THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case THandlerShortCircuitException::R_EXPECTED_EX:
        case THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->sendError('hasDataById', $args, $currentseqid, $ex->result);
          throw $ex->result;
        case THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postSend('hasDataById', $args, $currentseqid);
          return $currentseqid;
      }
    } catch (Exception $ex) {
      $this->eventHandler_->sendError('hasDataById', $args, $currentseqid, $ex);
      throw $ex;
    }
    $this->eventHandler_->postSend('hasDataById', $args, $currentseqid);
    return $currentseqid;
  }

  public function recv_hasDataById(?int $expectedsequenceid = null): bool {
    try {
      $this->eventHandler_->preRecv('hasDataById', $expectedsequenceid);
      if ($this->input_ instanceof TBinaryProtocolAccelerated) {
        $result = thrift_protocol_read_binary($this->input_, 'MyService_hasDataById_result', $this->input_->isStrictRead());
      } else if ($this->input_ instanceof TCompactProtocolAccelerated)
      {
        $result = thrift_protocol_read_compact($this->input_, 'MyService_hasDataById_result');
      }
      else
      {
        $rseqid = 0;
        $fname = '';
        $mtype = 0;

        $this->input_->readMessageBegin($fname, $mtype, $rseqid);
        if ($mtype == TMessageType::EXCEPTION) {
          $x = new TApplicationException();
          $x->read($this->input_);
          $this->input_->readMessageEnd();
          throw $x;
        }
        $result = new MyService_hasDataById_result();
        $result->read($this->input_);
        $this->input_->readMessageEnd();
        if ($expectedsequenceid !== null && ($rseqid != $expectedsequenceid)) {
          throw new TProtocolException("hasDataById failed: sequence id is out of order");
        }
      }
    } catch (THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case THandlerShortCircuitException::R_EXPECTED_EX:
          $this->eventHandler_->recvException('hasDataById', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->recvError('hasDataById', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postRecv('hasDataById', $expectedsequenceid, $ex->result);
          return $ex->result;
      }
    } catch (Exception $ex) {
      $this->eventHandler_->recvError('hasDataById', $expectedsequenceid, $ex);
      throw $ex;
    }
    if ($result->success !== null) {
      $success = $result->success;
      $this->eventHandler_->postRecv('hasDataById', $expectedsequenceid, $success);
      return $success;
    }
    $x = new TApplicationException("hasDataById failed: unknown result", TApplicationException::MISSING_RESULT);
    $this->eventHandler_->recvError('hasDataById', $expectedsequenceid, $x);
    throw $x;
  }

  /**
   * Original thrift definition:-
   * string
   *   getDataById(1: i64 id);
   */
  public function getDataById(int $id): string {
    $currentseqid = $this->send_getDataById($id);
    return $this->recv_getDataById($currentseqid);
  }

  public async function gen_getDataById(int $id): Awaitable<string> {
    $currentseqid = $this->send_getDataById($id);
    await $this->asyncHandler_->genWait($currentseqid);
    return $this->recv_getDataById($currentseqid);
  }

  public function send_getDataById(int $id): int {
    $currentseqid = $this->getsequenceid();
    $args = new MyService_getDataById_args();
    $args->id = $id;
    try {
      $this->eventHandler_->preSend('getDataById', $args, $currentseqid);
      if ($this->output_ instanceof TBinaryProtocolAccelerated)
      {
        thrift_protocol_write_binary($this->output_, 'getDataById', TMessageType::CALL, $args, $currentseqid, $this->output_->isStrictWrite(), false);
      }
      else if ($this->output_ instanceof TCompactProtocolAccelerated)
      {
        thrift_protocol_write_compact($this->output_, 'getDataById', TMessageType::CALL, $args, $currentseqid, false);
      }
      else
      {
        $this->output_->writeMessageBegin('getDataById', TMessageType::CALL, $currentseqid);
        $args->write($this->output_);
        $this->output_->writeMessageEnd();
        $this->output_->getTransport()->flush();
      }
    } catch (THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case THandlerShortCircuitException::R_EXPECTED_EX:
        case THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->sendError('getDataById', $args, $currentseqid, $ex->result);
          throw $ex->result;
        case THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postSend('getDataById', $args, $currentseqid);
          return $currentseqid;
      }
    } catch (Exception $ex) {
      $this->eventHandler_->sendError('getDataById', $args, $currentseqid, $ex);
      throw $ex;
    }
    $this->eventHandler_->postSend('getDataById', $args, $currentseqid);
    return $currentseqid;
  }

  public function recv_getDataById(?int $expectedsequenceid = null): string {
    try {
      $this->eventHandler_->preRecv('getDataById', $expectedsequenceid);
      if ($this->input_ instanceof TBinaryProtocolAccelerated) {
        $result = thrift_protocol_read_binary($this->input_, 'MyService_getDataById_result', $this->input_->isStrictRead());
      } else if ($this->input_ instanceof TCompactProtocolAccelerated)
      {
        $result = thrift_protocol_read_compact($this->input_, 'MyService_getDataById_result');
      }
      else
      {
        $rseqid = 0;
        $fname = '';
        $mtype = 0;

        $this->input_->readMessageBegin($fname, $mtype, $rseqid);
        if ($mtype == TMessageType::EXCEPTION) {
          $x = new TApplicationException();
          $x->read($this->input_);
          $this->input_->readMessageEnd();
          throw $x;
        }
        $result = new MyService_getDataById_result();
        $result->read($this->input_);
        $this->input_->readMessageEnd();
        if ($expectedsequenceid !== null && ($rseqid != $expectedsequenceid)) {
          throw new TProtocolException("getDataById failed: sequence id is out of order");
        }
      }
    } catch (THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case THandlerShortCircuitException::R_EXPECTED_EX:
          $this->eventHandler_->recvException('getDataById', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->recvError('getDataById', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postRecv('getDataById', $expectedsequenceid, $ex->result);
          return $ex->result;
      }
    } catch (Exception $ex) {
      $this->eventHandler_->recvError('getDataById', $expectedsequenceid, $ex);
      throw $ex;
    }
    if ($result->success !== null) {
      $success = $result->success;
      $this->eventHandler_->postRecv('getDataById', $expectedsequenceid, $success);
      return $success;
    }
    $x = new TApplicationException("getDataById failed: unknown result", TApplicationException::MISSING_RESULT);
    $this->eventHandler_->recvError('getDataById', $expectedsequenceid, $x);
    throw $x;
  }

  /**
   * Original thrift definition:-
   * void
   *   putDataById(1: i64 id,
   *               2: string data);
   */
  public function putDataById(int $id, string $data): void {
    $currentseqid = $this->send_putDataById($id, $data);
    $this->recv_putDataById($currentseqid);
  }

  public async function gen_putDataById(int $id, string $data): Awaitable<void> {
    $currentseqid = $this->send_putDataById($id, $data);
    await $this->asyncHandler_->genWait($currentseqid);
    $this->recv_putDataById($currentseqid);
  }

  public function send_putDataById(int $id, string $data): int {
    $currentseqid = $this->getsequenceid();
    $args = new MyService_putDataById_args();
    $args->id = $id;
    $args->data = $data;
    try {
      $this->eventHandler_->preSend('putDataById', $args, $currentseqid);
      if ($this->output_ instanceof TBinaryProtocolAccelerated)
      {
        thrift_protocol_write_binary($this->output_, 'putDataById', TMessageType::CALL, $args, $currentseqid, $this->output_->isStrictWrite(), false);
      }
      else if ($this->output_ instanceof TCompactProtocolAccelerated)
      {
        thrift_protocol_write_compact($this->output_, 'putDataById', TMessageType::CALL, $args, $currentseqid, false);
      }
      else
      {
        $this->output_->writeMessageBegin('putDataById', TMessageType::CALL, $currentseqid);
        $args->write($this->output_);
        $this->output_->writeMessageEnd();
        $this->output_->getTransport()->flush();
      }
    } catch (THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case THandlerShortCircuitException::R_EXPECTED_EX:
        case THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->sendError('putDataById', $args, $currentseqid, $ex->result);
          throw $ex->result;
        case THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postSend('putDataById', $args, $currentseqid);
          return $currentseqid;
      }
    } catch (Exception $ex) {
      $this->eventHandler_->sendError('putDataById', $args, $currentseqid, $ex);
      throw $ex;
    }
    $this->eventHandler_->postSend('putDataById', $args, $currentseqid);
    return $currentseqid;
  }

  public function recv_putDataById(?int $expectedsequenceid = null): void {
    try {
      $this->eventHandler_->preRecv('putDataById', $expectedsequenceid);
      if ($this->input_ instanceof TBinaryProtocolAccelerated) {
        $result = thrift_protocol_read_binary($this->input_, 'MyService_putDataById_result', $this->input_->isStrictRead());
      } else if ($this->input_ instanceof TCompactProtocolAccelerated)
      {
        $result = thrift_protocol_read_compact($this->input_, 'MyService_putDataById_result');
      }
      else
      {
        $rseqid = 0;
        $fname = '';
        $mtype = 0;

        $this->input_->readMessageBegin($fname, $mtype, $rseqid);
        if ($mtype == TMessageType::EXCEPTION) {
          $x = new TApplicationException();
          $x->read($this->input_);
          $this->input_->readMessageEnd();
          throw $x;
        }
        $result = new MyService_putDataById_result();
        $result->read($this->input_);
        $this->input_->readMessageEnd();
        if ($expectedsequenceid !== null && ($rseqid != $expectedsequenceid)) {
          throw new TProtocolException("putDataById failed: sequence id is out of order");
        }
      }
    } catch (THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case THandlerShortCircuitException::R_EXPECTED_EX:
          $this->eventHandler_->recvException('putDataById', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->recvError('putDataById', $expectedsequenceid, $ex->result);
          throw $ex->result;
        case THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postRecv('putDataById', $expectedsequenceid, $ex->result);
          return;
      }
    } catch (Exception $ex) {
      $this->eventHandler_->recvError('putDataById', $expectedsequenceid, $ex);
      throw $ex;
    }
          $this->eventHandler_->postRecv('putDataById', $expectedsequenceid, null);
return;
  }

  /**
   * Original thrift definition:-
   * oneway void
   *   lobDataById(1: i64 id,
   *               2: string data);
   */
  public function lobDataById(int $id, string $data): void {
    $currentseqid = $this->send_lobDataById($id, $data);
  }

  public async function gen_lobDataById(int $id, string $data): Awaitable<void> {
    $currentseqid = $this->send_lobDataById($id, $data);
  }

  public function send_lobDataById(int $id, string $data): int {
    $currentseqid = $this->getsequenceid();
    $args = new MyService_lobDataById_args();
    $args->id = $id;
    $args->data = $data;
    try {
      $this->eventHandler_->preSend('lobDataById', $args, $currentseqid);
      if ($this->output_ instanceof TBinaryProtocolAccelerated)
      {
        thrift_protocol_write_binary($this->output_, 'lobDataById', TMessageType::CALL, $args, $currentseqid, $this->output_->isStrictWrite(), true);
      }
      else if ($this->output_ instanceof TCompactProtocolAccelerated)
      {
        thrift_protocol_write_compact($this->output_, 'lobDataById', TMessageType::CALL, $args, $currentseqid, true);
      }
      else
      {
        $this->output_->writeMessageBegin('lobDataById', TMessageType::CALL, $currentseqid);
        $args->write($this->output_);
        $this->output_->writeMessageEnd();
        $this->output_->getTransport()->onewayFlush();
      }
    } catch (THandlerShortCircuitException $ex) {
      switch ($ex->resultType) {
        case THandlerShortCircuitException::R_EXPECTED_EX:
        case THandlerShortCircuitException::R_UNEXPECTED_EX:
          $this->eventHandler_->sendError('lobDataById', $args, $currentseqid, $ex->result);
          throw $ex->result;
        case THandlerShortCircuitException::R_SUCCESS:
        default:
          $this->eventHandler_->postSend('lobDataById', $args, $currentseqid);
          return $currentseqid;
      }
    } catch (Exception $ex) {
      $this->eventHandler_->sendError('lobDataById', $args, $currentseqid, $ex);
      throw $ex;
    }
    $this->eventHandler_->postSend('lobDataById', $args, $currentseqid);
    return $currentseqid;
  }
}

class MyServiceProcessor implements IThriftProcessor {
  protected TProcessorEventHandler $eventHandler_;

  // This exists so subclasses still using php can still access the handler
  // Once the migration to hack is complete, this field can be removed safely
  protected $handler_;

  private MyServiceIf $_handler;
  public function __construct(MyServiceIf $handler) {
    $this->eventHandler_ = new TProcessorEventHandler();
    $this->handler_ = $handler;
    $this->_handler = $handler;
  }

  public function setEventHandler(TProcessorEventHandler $event_handler): this {
    $this->eventHandler_ = $event_handler;
    return $this;
  }

  public function getEventHandler(): TProcessorEventHandler {
    return $this->eventHandler_;
  }

  public function process(TProtocol $input, TProtocol $output): bool {
    $rseqid = 0;
    $fname = '';
    $mtype = 0;

    $input->readMessageBegin($fname, $mtype, $rseqid);
    $methodname = 'process_'.$fname;
    if (!method_exists($this, $methodname)) {
      $handler_ctx = $this->eventHandler_->getHandlerContext($methodname);
      $this->eventHandler_->preRead($handler_ctx, $methodname, array());
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      $this->eventHandler_->postRead($handler_ctx, $methodname, array());
      $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $this->eventHandler_->handlerError($handler_ctx, $methodname, $x);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return true;
    }
    $this->$methodname($rseqid, $input, $output);
    return true;
  }

  protected function process_ping(int $seqid, TProtocol $input, TProtocol $output): void {
    $handler_ctx = $this->eventHandler_->getHandlerContext('ping');
    $reply_type = TMessageType::REPLY;

    $this->eventHandler_->preRead($handler_ctx, 'ping', array());

    if ($input instanceof TBinaryProtocolAccelerated) {
      $args = thrift_protocol_read_binary_struct($input, 'MyService_ping_args');
    } else if ($input instanceof TCompactProtocolAccelerated) {
      $args = thrift_protocol_read_compact_struct($input, 'MyService_ping_args');
    } else {
      $args = new MyService_ping_args();
      $args->read($input);
    }
    $input->readMessageEnd();
    $this->eventHandler_->postRead($handler_ctx, 'ping', $args);
    $result = new MyService_ping_result();
    try {
      $this->eventHandler_->preExec($handler_ctx, 'ping', $args);
      $this->_handler->ping();
      $this->eventHandler_->postExec($handler_ctx, 'ping', $result);
    } catch (Exception $ex) {
      $reply_type = TMessageType::EXCEPTION;
      $this->eventHandler_->handlerError($handler_ctx, 'ping', $ex);
      $result = new TApplicationException($ex->getMessage()."\n".$ex->getTraceAsString());
    }
    $this->eventHandler_->preWrite($handler_ctx, 'ping', $result);
    if ($output instanceof TBinaryProtocolAccelerated)
    {
      thrift_protocol_write_binary($output, 'ping', $reply_type, $result, $seqid, $output->isStrictWrite());
    }
    else if ($output instanceof TCompactProtocolAccelerated)
    {
      thrift_protocol_write_compact($output, 'ping', $reply_type, $result, $seqid);
    }
    else
    {
      $output->writeMessageBegin("ping", $reply_type, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
    }
    $this->eventHandler_->postWrite($handler_ctx, 'ping', $result);
  }
  protected function process_getRandomData(int $seqid, TProtocol $input, TProtocol $output): void {
    $handler_ctx = $this->eventHandler_->getHandlerContext('getRandomData');
    $reply_type = TMessageType::REPLY;

    $this->eventHandler_->preRead($handler_ctx, 'getRandomData', array());

    if ($input instanceof TBinaryProtocolAccelerated) {
      $args = thrift_protocol_read_binary_struct($input, 'MyService_getRandomData_args');
    } else if ($input instanceof TCompactProtocolAccelerated) {
      $args = thrift_protocol_read_compact_struct($input, 'MyService_getRandomData_args');
    } else {
      $args = new MyService_getRandomData_args();
      $args->read($input);
    }
    $input->readMessageEnd();
    $this->eventHandler_->postRead($handler_ctx, 'getRandomData', $args);
    $result = new MyService_getRandomData_result();
    try {
      $this->eventHandler_->preExec($handler_ctx, 'getRandomData', $args);
      $result->success = $this->_handler->getRandomData();
      $this->eventHandler_->postExec($handler_ctx, 'getRandomData', $result);
    } catch (Exception $ex) {
      $reply_type = TMessageType::EXCEPTION;
      $this->eventHandler_->handlerError($handler_ctx, 'getRandomData', $ex);
      $result = new TApplicationException($ex->getMessage()."\n".$ex->getTraceAsString());
    }
    $this->eventHandler_->preWrite($handler_ctx, 'getRandomData', $result);
    if ($output instanceof TBinaryProtocolAccelerated)
    {
      thrift_protocol_write_binary($output, 'getRandomData', $reply_type, $result, $seqid, $output->isStrictWrite());
    }
    else if ($output instanceof TCompactProtocolAccelerated)
    {
      thrift_protocol_write_compact($output, 'getRandomData', $reply_type, $result, $seqid);
    }
    else
    {
      $output->writeMessageBegin("getRandomData", $reply_type, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
    }
    $this->eventHandler_->postWrite($handler_ctx, 'getRandomData', $result);
  }
  protected function process_hasDataById(int $seqid, TProtocol $input, TProtocol $output): void {
    $handler_ctx = $this->eventHandler_->getHandlerContext('hasDataById');
    $reply_type = TMessageType::REPLY;

    $this->eventHandler_->preRead($handler_ctx, 'hasDataById', array());

    if ($input instanceof TBinaryProtocolAccelerated) {
      $args = thrift_protocol_read_binary_struct($input, 'MyService_hasDataById_args');
    } else if ($input instanceof TCompactProtocolAccelerated) {
      $args = thrift_protocol_read_compact_struct($input, 'MyService_hasDataById_args');
    } else {
      $args = new MyService_hasDataById_args();
      $args->read($input);
    }
    $input->readMessageEnd();
    $this->eventHandler_->postRead($handler_ctx, 'hasDataById', $args);
    $result = new MyService_hasDataById_result();
    try {
      $this->eventHandler_->preExec($handler_ctx, 'hasDataById', $args);
      $result->success = $this->_handler->hasDataById($args->id);
      $this->eventHandler_->postExec($handler_ctx, 'hasDataById', $result);
    } catch (Exception $ex) {
      $reply_type = TMessageType::EXCEPTION;
      $this->eventHandler_->handlerError($handler_ctx, 'hasDataById', $ex);
      $result = new TApplicationException($ex->getMessage()."\n".$ex->getTraceAsString());
    }
    $this->eventHandler_->preWrite($handler_ctx, 'hasDataById', $result);
    if ($output instanceof TBinaryProtocolAccelerated)
    {
      thrift_protocol_write_binary($output, 'hasDataById', $reply_type, $result, $seqid, $output->isStrictWrite());
    }
    else if ($output instanceof TCompactProtocolAccelerated)
    {
      thrift_protocol_write_compact($output, 'hasDataById', $reply_type, $result, $seqid);
    }
    else
    {
      $output->writeMessageBegin("hasDataById", $reply_type, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
    }
    $this->eventHandler_->postWrite($handler_ctx, 'hasDataById', $result);
  }
  protected function process_getDataById(int $seqid, TProtocol $input, TProtocol $output): void {
    $handler_ctx = $this->eventHandler_->getHandlerContext('getDataById');
    $reply_type = TMessageType::REPLY;

    $this->eventHandler_->preRead($handler_ctx, 'getDataById', array());

    if ($input instanceof TBinaryProtocolAccelerated) {
      $args = thrift_protocol_read_binary_struct($input, 'MyService_getDataById_args');
    } else if ($input instanceof TCompactProtocolAccelerated) {
      $args = thrift_protocol_read_compact_struct($input, 'MyService_getDataById_args');
    } else {
      $args = new MyService_getDataById_args();
      $args->read($input);
    }
    $input->readMessageEnd();
    $this->eventHandler_->postRead($handler_ctx, 'getDataById', $args);
    $result = new MyService_getDataById_result();
    try {
      $this->eventHandler_->preExec($handler_ctx, 'getDataById', $args);
      $result->success = $this->_handler->getDataById($args->id);
      $this->eventHandler_->postExec($handler_ctx, 'getDataById', $result);
    } catch (Exception $ex) {
      $reply_type = TMessageType::EXCEPTION;
      $this->eventHandler_->handlerError($handler_ctx, 'getDataById', $ex);
      $result = new TApplicationException($ex->getMessage()."\n".$ex->getTraceAsString());
    }
    $this->eventHandler_->preWrite($handler_ctx, 'getDataById', $result);
    if ($output instanceof TBinaryProtocolAccelerated)
    {
      thrift_protocol_write_binary($output, 'getDataById', $reply_type, $result, $seqid, $output->isStrictWrite());
    }
    else if ($output instanceof TCompactProtocolAccelerated)
    {
      thrift_protocol_write_compact($output, 'getDataById', $reply_type, $result, $seqid);
    }
    else
    {
      $output->writeMessageBegin("getDataById", $reply_type, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
    }
    $this->eventHandler_->postWrite($handler_ctx, 'getDataById', $result);
  }
  protected function process_putDataById(int $seqid, TProtocol $input, TProtocol $output): void {
    $handler_ctx = $this->eventHandler_->getHandlerContext('putDataById');
    $reply_type = TMessageType::REPLY;

    $this->eventHandler_->preRead($handler_ctx, 'putDataById', array());

    if ($input instanceof TBinaryProtocolAccelerated) {
      $args = thrift_protocol_read_binary_struct($input, 'MyService_putDataById_args');
    } else if ($input instanceof TCompactProtocolAccelerated) {
      $args = thrift_protocol_read_compact_struct($input, 'MyService_putDataById_args');
    } else {
      $args = new MyService_putDataById_args();
      $args->read($input);
    }
    $input->readMessageEnd();
    $this->eventHandler_->postRead($handler_ctx, 'putDataById', $args);
    $result = new MyService_putDataById_result();
    try {
      $this->eventHandler_->preExec($handler_ctx, 'putDataById', $args);
      $this->_handler->putDataById($args->id, $args->data);
      $this->eventHandler_->postExec($handler_ctx, 'putDataById', $result);
    } catch (Exception $ex) {
      $reply_type = TMessageType::EXCEPTION;
      $this->eventHandler_->handlerError($handler_ctx, 'putDataById', $ex);
      $result = new TApplicationException($ex->getMessage()."\n".$ex->getTraceAsString());
    }
    $this->eventHandler_->preWrite($handler_ctx, 'putDataById', $result);
    if ($output instanceof TBinaryProtocolAccelerated)
    {
      thrift_protocol_write_binary($output, 'putDataById', $reply_type, $result, $seqid, $output->isStrictWrite());
    }
    else if ($output instanceof TCompactProtocolAccelerated)
    {
      thrift_protocol_write_compact($output, 'putDataById', $reply_type, $result, $seqid);
    }
    else
    {
      $output->writeMessageBegin("putDataById", $reply_type, $seqid);
      $result->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
    }
    $this->eventHandler_->postWrite($handler_ctx, 'putDataById', $result);
  }
  protected function process_lobDataById(int $seqid, TProtocol $input, TProtocol $output): void {
    $handler_ctx = $this->eventHandler_->getHandlerContext('lobDataById');
    $reply_type = TMessageType::REPLY;

    $this->eventHandler_->preRead($handler_ctx, 'lobDataById', array());

    if ($input instanceof TBinaryProtocolAccelerated) {
      $args = thrift_protocol_read_binary_struct($input, 'MyService_lobDataById_args');
    } else if ($input instanceof TCompactProtocolAccelerated) {
      $args = thrift_protocol_read_compact_struct($input, 'MyService_lobDataById_args');
    } else {
      $args = new MyService_lobDataById_args();
      $args->read($input);
    }
    $input->readMessageEnd();
    $this->eventHandler_->postRead($handler_ctx, 'lobDataById', $args);
    try {
      $this->eventHandler_->preExec($handler_ctx, 'lobDataById', $args);
      $this->_handler->lobDataById($args->id, $args->data);
    } catch (Exception $ex) {
      $reply_type = TMessageType::EXCEPTION;
      $this->eventHandler_->handlerError($handler_ctx, 'lobDataById', $ex);
      $result = new TApplicationException($ex->getMessage()."\n".$ex->getTraceAsString());
    }
    return;
  }
}
// HELPER FUNCTIONS AND STRUCTURES

class MyService_ping_args implements IThriftStruct {
  public static array $_TSPEC = array(
    );
  public static Map<string, int> $_TFIELDMAP = Map {
  };
  const int STRUCTURAL_ID = 957977401221134810;

  public function __construct(  ) {
  }

  public function getName(): string {
    return 'MyService_ping_args';
  }

  public function read(TProtocol $input): int {
    $xfer = 0;
    $fname = '';
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        $fid = (int) self::$_TFIELDMAP->get($fname);
        if ($fid !== 0) {
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write(TProtocol $output): int {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MyService_ping_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MyService_ping_result implements IThriftStruct {
  public static array $_TSPEC = array(
    );
  public static Map<string, int> $_TFIELDMAP = Map {
  };
  const int STRUCTURAL_ID = 957977401221134810;

  public function __construct(  ) {
  }

  public function getName(): string {
    return 'MyService_ping_result';
  }

  public function read(TProtocol $input): int {
    $xfer = 0;
    $fname = '';
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        $fid = (int) self::$_TFIELDMAP->get($fname);
        if ($fid !== 0) {
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write(TProtocol $output): int {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MyService_ping_result');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MyService_getRandomData_args implements IThriftStruct {
  public static array $_TSPEC = array(
    );
  public static Map<string, int> $_TFIELDMAP = Map {
  };
  const int STRUCTURAL_ID = 957977401221134810;

  public function __construct(  ) {
  }

  public function getName(): string {
    return 'MyService_getRandomData_args';
  }

  public function read(TProtocol $input): int {
    $xfer = 0;
    $fname = '';
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        $fid = (int) self::$_TFIELDMAP->get($fname);
        if ($fid !== 0) {
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write(TProtocol $output): int {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MyService_getRandomData_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MyService_getRandomData_result implements IThriftStruct {
  public static array $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'type' => TType::STRING,
      ),
    );
  public static Map<string, int> $_TFIELDMAP = Map {
    'success' => 0,
  };
  const int STRUCTURAL_ID = 1365128170602685579;
  public ?string $success;

  public function __construct(?string $success = null  ) {
  }

  public function getName(): string {
    return 'MyService_getRandomData_result';
  }

  public function read(TProtocol $input): int {
    $xfer = 0;
    $fname = '';
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        $fid = (int) self::$_TFIELDMAP->get($fname);
        if ($fid !== 0) {
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write(TProtocol $output): int {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MyService_getRandomData_result');
    if ($this->success !== null) {
      $_val2 = $this->success;
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($_val2);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MyService_hasDataById_args implements IThriftStruct {
  public static array $_TSPEC = array(
    1 => array(
      'var' => 'id',
      'type' => TType::I64,
      ),
    );
  public static Map<string, int> $_TFIELDMAP = Map {
    'id' => 1,
  };
  const int STRUCTURAL_ID = 3807211151619655933;
  public int $id;

  public function __construct(?int $id = null  ) {
    if ($id === null) {
      $this->id = 0;
    } else {
      $this->id = $id;
    }
  }

  public function getName(): string {
    return 'MyService_hasDataById_args';
  }

  public function read(TProtocol $input): int {
    $xfer = 0;
    $fname = '';
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        $fid = (int) self::$_TFIELDMAP->get($fname);
        if ($fid !== 0) {
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write(TProtocol $output): int {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MyService_hasDataById_args');
    if ($this->id !== null) {
      $_val3 = $this->id;
      $xfer += $output->writeFieldBegin('id', TType::I64, 1);
      $xfer += $output->writeI64($_val3);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MyService_hasDataById_result implements IThriftStruct {
  public static array $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'type' => TType::BOOL,
      ),
    );
  public static Map<string, int> $_TFIELDMAP = Map {
    'success' => 0,
  };
  const int STRUCTURAL_ID = 8594383818423018844;
  public ?bool $success;

  public function __construct(?bool $success = null  ) {
  }

  public function getName(): string {
    return 'MyService_hasDataById_result';
  }

  public function read(TProtocol $input): int {
    $xfer = 0;
    $fname = '';
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        $fid = (int) self::$_TFIELDMAP->get($fname);
        if ($fid !== 0) {
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write(TProtocol $output): int {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MyService_hasDataById_result');
    if ($this->success !== null) {
      $_val4 = $this->success;
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($_val4);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MyService_getDataById_args implements IThriftStruct {
  public static array $_TSPEC = array(
    1 => array(
      'var' => 'id',
      'type' => TType::I64,
      ),
    );
  public static Map<string, int> $_TFIELDMAP = Map {
    'id' => 1,
  };
  const int STRUCTURAL_ID = 3807211151619655933;
  public int $id;

  public function __construct(?int $id = null  ) {
    if ($id === null) {
      $this->id = 0;
    } else {
      $this->id = $id;
    }
  }

  public function getName(): string {
    return 'MyService_getDataById_args';
  }

  public function read(TProtocol $input): int {
    $xfer = 0;
    $fname = '';
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        $fid = (int) self::$_TFIELDMAP->get($fname);
        if ($fid !== 0) {
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write(TProtocol $output): int {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MyService_getDataById_args');
    if ($this->id !== null) {
      $_val5 = $this->id;
      $xfer += $output->writeFieldBegin('id', TType::I64, 1);
      $xfer += $output->writeI64($_val5);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MyService_getDataById_result implements IThriftStruct {
  public static array $_TSPEC = array(
    0 => array(
      'var' => 'success',
      'type' => TType::STRING,
      ),
    );
  public static Map<string, int> $_TFIELDMAP = Map {
    'success' => 0,
  };
  const int STRUCTURAL_ID = 1365128170602685579;
  public ?string $success;

  public function __construct(?string $success = null  ) {
  }

  public function getName(): string {
    return 'MyService_getDataById_result';
  }

  public function read(TProtocol $input): int {
    $xfer = 0;
    $fname = '';
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        $fid = (int) self::$_TFIELDMAP->get($fname);
        if ($fid !== 0) {
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write(TProtocol $output): int {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MyService_getDataById_result');
    if ($this->success !== null) {
      $_val6 = $this->success;
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($_val6);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MyService_putDataById_args implements IThriftStruct {
  public static array $_TSPEC = array(
    1 => array(
      'var' => 'id',
      'type' => TType::I64,
      ),
    2 => array(
      'var' => 'data',
      'type' => TType::STRING,
      ),
    );
  public static Map<string, int> $_TFIELDMAP = Map {
    'id' => 1,
    'data' => 2,
  };
  const int STRUCTURAL_ID = 1055685087985327657;
  public int $id;
  public string $data;

  public function __construct(?int $id = null, ?string $data = null  ) {
    if ($id === null) {
      $this->id = 0;
    } else {
      $this->id = $id;
    }
    if ($data === null) {
      $this->data = '';
    } else {
      $this->data = $data;
    }
  }

  public function getName(): string {
    return 'MyService_putDataById_args';
  }

  public function read(TProtocol $input): int {
    $xfer = 0;
    $fname = '';
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        $fid = (int) self::$_TFIELDMAP->get($fname);
        if ($fid !== 0) {
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->data);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write(TProtocol $output): int {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MyService_putDataById_args');
    if ($this->id !== null) {
      $_val7 = $this->id;
      $xfer += $output->writeFieldBegin('id', TType::I64, 1);
      $xfer += $output->writeI64($_val7);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->data !== null) {
      $_val8 = $this->data;
      $xfer += $output->writeFieldBegin('data', TType::STRING, 2);
      $xfer += $output->writeString($_val8);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MyService_putDataById_result implements IThriftStruct {
  public static array $_TSPEC = array(
    );
  public static Map<string, int> $_TFIELDMAP = Map {
  };
  const int STRUCTURAL_ID = 957977401221134810;

  public function __construct(  ) {
  }

  public function getName(): string {
    return 'MyService_putDataById_result';
  }

  public function read(TProtocol $input): int {
    $xfer = 0;
    $fname = '';
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        $fid = (int) self::$_TFIELDMAP->get($fname);
        if ($fid !== 0) {
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write(TProtocol $output): int {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MyService_putDataById_result');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MyService_lobDataById_args implements IThriftStruct {
  public static array $_TSPEC = array(
    1 => array(
      'var' => 'id',
      'type' => TType::I64,
      ),
    2 => array(
      'var' => 'data',
      'type' => TType::STRING,
      ),
    );
  public static Map<string, int> $_TFIELDMAP = Map {
    'id' => 1,
    'data' => 2,
  };
  const int STRUCTURAL_ID = 1055685087985327657;
  public int $id;
  public string $data;

  public function __construct(?int $id = null, ?string $data = null  ) {
    if ($id === null) {
      $this->id = 0;
    } else {
      $this->id = $id;
    }
    if ($data === null) {
      $this->data = '';
    } else {
      $this->data = $data;
    }
  }

  public function getName(): string {
    return 'MyService_lobDataById_args';
  }

  public function read(TProtocol $input): int {
    $xfer = 0;
    $fname = '';
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        $fid = (int) self::$_TFIELDMAP->get($fname);
        if ($fid !== 0) {
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->data);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write(TProtocol $output): int {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MyService_lobDataById_args');
    if ($this->id !== null) {
      $_val9 = $this->id;
      $xfer += $output->writeFieldBegin('id', TType::I64, 1);
      $xfer += $output->writeI64($_val9);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->data !== null) {
      $_val10 = $this->data;
      $xfer += $output->writeFieldBegin('data', TType::STRING, 2);
      $xfer += $output->writeString($_val10);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

