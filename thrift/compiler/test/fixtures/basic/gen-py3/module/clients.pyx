#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t
from libcpp.vector cimport vector as vector
from libcpp.set cimport set as cset
from libcpp.map cimport map as cmap
from cython.operator cimport dereference as deref
from cpython.ref cimport PyObject
from thrift.py3.client cimport EventBase, make_py3_client, py3_get_exception
from thrift.py3.client import get_event_base
from thrift.py3.folly cimport cFollyEventBase, cFollyTry, cFollyUnit, c_unit

import asyncio
import sys
import traceback

cimport module.types
import module.types

from module.clients_wrapper cimport move

from module.clients_wrapper cimport cMyServiceAsyncClient, cMyServiceClientWrapper
from module.clients_wrapper cimport cMyServiceFastAsyncClient, cMyServiceFastClientWrapper
from module.clients_wrapper cimport cMyServiceEmptyAsyncClient, cMyServiceEmptyClientWrapper
from module.clients_wrapper cimport cMyServicePrioParentAsyncClient, cMyServicePrioParentClientWrapper
from module.clients_wrapper cimport cMyServicePrioChildAsyncClient, cMyServicePrioChildClientWrapper


cdef void MyService_ping_callback(
        PyObject* future,
        cFollyTry[cFollyUnit] result) with gil:
    cdef object pyfuture = <object> future
    cdef cFollyUnit citem
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        citem = c_unit;
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, None)

cdef void MyService_getRandomData_callback(
        PyObject* future,
        cFollyTry[string] result) with gil:
    cdef object pyfuture = <object> future
    cdef unique_ptr[string] citem
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        citem = make_unique[string](result.value());
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, (deref(citem.get())).decode('UTF-8'))

cdef void MyService_hasDataById_callback(
        PyObject* future,
        cFollyTry[cbool] result) with gil:
    cdef object pyfuture = <object> future
    cdef cbool citem
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        citem = result.value();
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, citem)

cdef void MyService_getDataById_callback(
        PyObject* future,
        cFollyTry[string] result) with gil:
    cdef object pyfuture = <object> future
    cdef unique_ptr[string] citem
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        citem = make_unique[string](result.value());
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, (deref(citem.get())).decode('UTF-8'))

cdef void MyService_putDataById_callback(
        PyObject* future,
        cFollyTry[cFollyUnit] result) with gil:
    cdef object pyfuture = <object> future
    cdef cFollyUnit citem
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        citem = c_unit;
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, None)

cdef void MyService_lobDataById_callback(
        PyObject* future,
        cFollyTry[cFollyUnit] result) with gil:
    cdef object pyfuture = <object> future
    cdef cFollyUnit citem
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        citem = c_unit;
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, None)

cdef void MyServiceFast_ping_callback(
        PyObject* future,
        cFollyTry[cFollyUnit] result) with gil:
    cdef object pyfuture = <object> future
    cdef cFollyUnit citem
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        citem = c_unit;
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, None)

cdef void MyServiceFast_getRandomData_callback(
        PyObject* future,
        cFollyTry[string] result) with gil:
    cdef object pyfuture = <object> future
    cdef unique_ptr[string] citem
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        citem = make_unique[string](result.value());
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, (deref(citem.get())).decode('UTF-8'))

cdef void MyServiceFast_hasDataById_callback(
        PyObject* future,
        cFollyTry[cbool] result) with gil:
    cdef object pyfuture = <object> future
    cdef cbool citem
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        citem = result.value();
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, citem)

cdef void MyServiceFast_getDataById_callback(
        PyObject* future,
        cFollyTry[string] result) with gil:
    cdef object pyfuture = <object> future
    cdef unique_ptr[string] citem
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        citem = make_unique[string](result.value());
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, (deref(citem.get())).decode('UTF-8'))

cdef void MyServiceFast_putDataById_callback(
        PyObject* future,
        cFollyTry[cFollyUnit] result) with gil:
    cdef object pyfuture = <object> future
    cdef cFollyUnit citem
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        citem = c_unit;
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, None)

cdef void MyServiceFast_lobDataById_callback(
        PyObject* future,
        cFollyTry[cFollyUnit] result) with gil:
    cdef object pyfuture = <object> future
    cdef cFollyUnit citem
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        citem = c_unit;
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, None)

cdef void MyServicePrioParent_ping_callback(
        PyObject* future,
        cFollyTry[cFollyUnit] result) with gil:
    cdef object pyfuture = <object> future
    cdef cFollyUnit citem
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        citem = c_unit;
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, None)

cdef void MyServicePrioParent_pong_callback(
        PyObject* future,
        cFollyTry[cFollyUnit] result) with gil:
    cdef object pyfuture = <object> future
    cdef cFollyUnit citem
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        citem = c_unit;
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, None)

cdef void MyServicePrioChild_pang_callback(
        PyObject* future,
        cFollyTry[cFollyUnit] result) with gil:
    cdef object pyfuture = <object> future
    cdef cFollyUnit citem
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        citem = c_unit;
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, None)


cdef class MyService:

    def __init__(self, *args, **kwds):
        raise TypeError('Use MyService.connect() instead.')

    def __cinit__(self, loop):
        self.loop = loop

    @staticmethod
    cdef _module_MyService_set_client(MyService inst, shared_ptr[cMyServiceClientWrapper] c_obj):
        """So the class hierarchy talks to the correct pointer type"""
        inst._module_MyService_client = c_obj

    @staticmethod
    async def connect(str host, int port, loop=None):
        loop = loop or asyncio.get_event_loop()
        future = loop.create_future()
        future.loop = loop
        eb = await get_event_base(loop)
        cdef string _host = host.encode('UTF-8')
        make_py3_client[cMyServiceAsyncClient, cMyServiceClientWrapper](
            (<EventBase> eb)._folly_event_base,
            _host,
            port,
            0,
            made_MyService_py3_client_callback,
            future)
        return await future

    def ping(
            self):
        future = self.loop.create_future()
        future.loop = self.loop

        deref(self._module_MyService_client).ping(
            MyService_ping_callback,
            future)
        return future

    def getRandomData(
            self):
        future = self.loop.create_future()
        future.loop = self.loop

        deref(self._module_MyService_client).getRandomData(
            MyService_getRandomData_callback,
            future)
        return future

    def hasDataById(
            self,
            arg_id):
        future = self.loop.create_future()
        future.loop = self.loop

        deref(self._module_MyService_client).hasDataById(
            arg_id,
            MyService_hasDataById_callback,
            future)
        return future

    def getDataById(
            self,
            arg_id):
        future = self.loop.create_future()
        future.loop = self.loop

        deref(self._module_MyService_client).getDataById(
            arg_id,
            MyService_getDataById_callback,
            future)
        return future

    def putDataById(
            self,
            arg_id,
            arg_data):
        future = self.loop.create_future()
        future.loop = self.loop

        deref(self._module_MyService_client).putDataById(
            arg_id,
            arg_data.encode('UTF-8'),
            MyService_putDataById_callback,
            future)
        return future

    def lobDataById(
            self,
            arg_id,
            arg_data):
        future = self.loop.create_future()
        future.loop = self.loop

        deref(self._module_MyService_client).lobDataById(
            arg_id,
            arg_data.encode('UTF-8'),
            MyService_lobDataById_callback,
            future)
        return future


cdef void made_MyService_py3_client_callback(
        PyObject* future,
        cFollyTry[shared_ptr[cMyServiceClientWrapper]] result) with gil:
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        pyclient = <MyService> MyService.__new__(MyService, pyfuture.loop)
        MyService._module_MyService_set_client(pyclient, result.value())
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, pyclient)

cdef class MyServiceFast:

    def __init__(self, *args, **kwds):
        raise TypeError('Use MyServiceFast.connect() instead.')

    def __cinit__(self, loop):
        self.loop = loop

    @staticmethod
    cdef _module_MyServiceFast_set_client(MyServiceFast inst, shared_ptr[cMyServiceFastClientWrapper] c_obj):
        """So the class hierarchy talks to the correct pointer type"""
        inst._module_MyServiceFast_client = c_obj

    @staticmethod
    async def connect(str host, int port, loop=None):
        loop = loop or asyncio.get_event_loop()
        future = loop.create_future()
        future.loop = loop
        eb = await get_event_base(loop)
        cdef string _host = host.encode('UTF-8')
        make_py3_client[cMyServiceFastAsyncClient, cMyServiceFastClientWrapper](
            (<EventBase> eb)._folly_event_base,
            _host,
            port,
            0,
            made_MyServiceFast_py3_client_callback,
            future)
        return await future

    def ping(
            self):
        future = self.loop.create_future()
        future.loop = self.loop

        deref(self._module_MyServiceFast_client).ping(
            MyServiceFast_ping_callback,
            future)
        return future

    def getRandomData(
            self):
        future = self.loop.create_future()
        future.loop = self.loop

        deref(self._module_MyServiceFast_client).getRandomData(
            MyServiceFast_getRandomData_callback,
            future)
        return future

    def hasDataById(
            self,
            arg_id):
        future = self.loop.create_future()
        future.loop = self.loop

        deref(self._module_MyServiceFast_client).hasDataById(
            arg_id,
            MyServiceFast_hasDataById_callback,
            future)
        return future

    def getDataById(
            self,
            arg_id):
        future = self.loop.create_future()
        future.loop = self.loop

        deref(self._module_MyServiceFast_client).getDataById(
            arg_id,
            MyServiceFast_getDataById_callback,
            future)
        return future

    def putDataById(
            self,
            arg_id,
            arg_data):
        future = self.loop.create_future()
        future.loop = self.loop

        deref(self._module_MyServiceFast_client).putDataById(
            arg_id,
            arg_data.encode('UTF-8'),
            MyServiceFast_putDataById_callback,
            future)
        return future

    def lobDataById(
            self,
            arg_id,
            arg_data):
        future = self.loop.create_future()
        future.loop = self.loop

        deref(self._module_MyServiceFast_client).lobDataById(
            arg_id,
            arg_data.encode('UTF-8'),
            MyServiceFast_lobDataById_callback,
            future)
        return future


cdef void made_MyServiceFast_py3_client_callback(
        PyObject* future,
        cFollyTry[shared_ptr[cMyServiceFastClientWrapper]] result) with gil:
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        pyclient = <MyServiceFast> MyServiceFast.__new__(MyServiceFast, pyfuture.loop)
        MyServiceFast._module_MyServiceFast_set_client(pyclient, result.value())
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, pyclient)

cdef class MyServiceEmpty:

    def __init__(self, *args, **kwds):
        raise TypeError('Use MyServiceEmpty.connect() instead.')

    def __cinit__(self, loop):
        self.loop = loop

    @staticmethod
    cdef _module_MyServiceEmpty_set_client(MyServiceEmpty inst, shared_ptr[cMyServiceEmptyClientWrapper] c_obj):
        """So the class hierarchy talks to the correct pointer type"""
        inst._module_MyServiceEmpty_client = c_obj

    @staticmethod
    async def connect(str host, int port, loop=None):
        loop = loop or asyncio.get_event_loop()
        future = loop.create_future()
        future.loop = loop
        eb = await get_event_base(loop)
        cdef string _host = host.encode('UTF-8')
        make_py3_client[cMyServiceEmptyAsyncClient, cMyServiceEmptyClientWrapper](
            (<EventBase> eb)._folly_event_base,
            _host,
            port,
            0,
            made_MyServiceEmpty_py3_client_callback,
            future)
        return await future


cdef void made_MyServiceEmpty_py3_client_callback(
        PyObject* future,
        cFollyTry[shared_ptr[cMyServiceEmptyClientWrapper]] result) with gil:
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        pyclient = <MyServiceEmpty> MyServiceEmpty.__new__(MyServiceEmpty, pyfuture.loop)
        MyServiceEmpty._module_MyServiceEmpty_set_client(pyclient, result.value())
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, pyclient)

cdef class MyServicePrioParent:

    def __init__(self, *args, **kwds):
        raise TypeError('Use MyServicePrioParent.connect() instead.')

    def __cinit__(self, loop):
        self.loop = loop

    @staticmethod
    cdef _module_MyServicePrioParent_set_client(MyServicePrioParent inst, shared_ptr[cMyServicePrioParentClientWrapper] c_obj):
        """So the class hierarchy talks to the correct pointer type"""
        inst._module_MyServicePrioParent_client = c_obj

    @staticmethod
    async def connect(str host, int port, loop=None):
        loop = loop or asyncio.get_event_loop()
        future = loop.create_future()
        future.loop = loop
        eb = await get_event_base(loop)
        cdef string _host = host.encode('UTF-8')
        make_py3_client[cMyServicePrioParentAsyncClient, cMyServicePrioParentClientWrapper](
            (<EventBase> eb)._folly_event_base,
            _host,
            port,
            0,
            made_MyServicePrioParent_py3_client_callback,
            future)
        return await future

    def ping(
            self):
        future = self.loop.create_future()
        future.loop = self.loop

        deref(self._module_MyServicePrioParent_client).ping(
            MyServicePrioParent_ping_callback,
            future)
        return future

    def pong(
            self):
        future = self.loop.create_future()
        future.loop = self.loop

        deref(self._module_MyServicePrioParent_client).pong(
            MyServicePrioParent_pong_callback,
            future)
        return future


cdef void made_MyServicePrioParent_py3_client_callback(
        PyObject* future,
        cFollyTry[shared_ptr[cMyServicePrioParentClientWrapper]] result) with gil:
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        pyclient = <MyServicePrioParent> MyServicePrioParent.__new__(MyServicePrioParent, pyfuture.loop)
        MyServicePrioParent._module_MyServicePrioParent_set_client(pyclient, result.value())
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, pyclient)

cdef class MyServicePrioChild(MyServicePrioParent):

    def __init__(self, *args, **kwds):
        raise TypeError('Use MyServicePrioChild.connect() instead.')

    def __cinit__(self, loop):
        self.loop = loop

    @staticmethod
    cdef _module_MyServicePrioChild_set_client(MyServicePrioChild inst, shared_ptr[cMyServicePrioChildClientWrapper] c_obj):
        """So the class hierarchy talks to the correct pointer type"""
        inst._module_MyServicePrioChild_client = c_obj
        MyServicePrioParent._module_MyServicePrioParent_set_client(inst, <shared_ptr[cMyServicePrioParentClientWrapper]>c_obj)

    @staticmethod
    async def connect(str host, int port, loop=None):
        loop = loop or asyncio.get_event_loop()
        future = loop.create_future()
        future.loop = loop
        eb = await get_event_base(loop)
        cdef string _host = host.encode('UTF-8')
        make_py3_client[cMyServicePrioChildAsyncClient, cMyServicePrioChildClientWrapper](
            (<EventBase> eb)._folly_event_base,
            _host,
            port,
            0,
            made_MyServicePrioChild_py3_client_callback,
            future)
        return await future

    def pang(
            self):
        future = self.loop.create_future()
        future.loop = self.loop

        deref(self._module_MyServicePrioChild_client).pang(
            MyServicePrioChild_pang_callback,
            future)
        return future


cdef void made_MyServicePrioChild_py3_client_callback(
        PyObject* future,
        cFollyTry[shared_ptr[cMyServicePrioChildClientWrapper]] result) with gil:
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        pyclient = <MyServicePrioChild> MyServicePrioChild.__new__(MyServicePrioChild, pyfuture.loop)
        MyServicePrioChild._module_MyServicePrioChild_set_client(pyclient, result.value())
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, pyclient)

