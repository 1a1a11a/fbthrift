/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/compiler/test/fixtures/forward_compatibility/gen-cpp/forward_compatibility_types.h"
#include "thrift/compiler/test/fixtures/forward_compatibility/gen-cpp/forward_compatibility_data.h"

#include "thrift/compiler/test/fixtures/forward_compatibility/gen-cpp/forward_compatibility_reflection.h"

#include <algorithm>
#include <string.h>

#include <folly/Indestructible.h>



const uint64_t OldStructure::_reflection_id;
void OldStructure::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::forward_compatibility_reflection_::reflectionInitializer_4131921941933986764(schema);
}

bool OldStructure::operator == (const OldStructure & rhs) const {
  if (!(this->features == rhs.features))
    return false;
  return true;
}

void OldStructure::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "features") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_MAP;
  }
};

uint32_t OldStructure::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::forward_compatibility_reflection_::reflectionInitializer_4131921941933986764(*schema);
    iprot->setNextStructType(OldStructure::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->features.clear();
            uint32_t _size1;
            bool _sizeUnknown2;
            apache::thrift::protocol::TType _ktype3 = apache::thrift::protocol::T_STOP;
            apache::thrift::protocol::TType _vtype4 = apache::thrift::protocol::T_STOP;
            xfer += iprot->readMapBegin(_ktype3, _vtype4, _size1, _sizeUnknown2);
            if (!_sizeUnknown2) {
              uint32_t _i7;
              for (_i7 = 0; _i7 < _size1; ++_i7)
              {
                int16_t _key8;
                xfer += iprot->readI16(_key8);
                double& _val9 = this->features[_key8];
                xfer += iprot->readDouble(_val9);
              }
            } else {
              while (iprot->peekMap())
              {
                int16_t _key10;
                xfer += iprot->readI16(_key10);
                double& _val11 = this->features[_key10];
                xfer += iprot->readDouble(_val11);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.features = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void OldStructure::__clear() {
  features.clear();
  __isset.__clear();
}
uint32_t OldStructure::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("OldStructure");
  xfer += oprot->writeFieldBegin("features", apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I16, apache::thrift::protocol::T_DOUBLE, this->features.size());
    std::map<int16_t, double> ::const_iterator _iter12;
    for (_iter12 = this->features.begin(); _iter12 != this->features.end(); ++_iter12)
    {
      xfer += oprot->writeI16(_iter12->first);
      xfer += oprot->writeDouble(_iter12->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OldStructure &a, OldStructure &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.features, b.features);
  swap(a.__isset, b.__isset);
}

void merge(const OldStructure& from, OldStructure& to) {
  using apache::thrift::merge;
  merge(from.features, to.features);
  to.__isset.features = to.__isset.features || from.__isset.features;
}

void merge(OldStructure&& from, OldStructure& to) {
  using apache::thrift::merge;
  merge(std::move(from.features), to.features);
  to.__isset.features = to.__isset.features || from.__isset.features;
}

const uint64_t NewStructure::_reflection_id;
void NewStructure::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::forward_compatibility_reflection_::reflectionInitializer_13282492778586199212(schema);
}

bool NewStructure::operator == (const NewStructure & rhs) const {
  if (!(this->features == rhs.features))
    return false;
  return true;
}

void NewStructure::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "features") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_MAP;
  }
};

uint32_t NewStructure::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::forward_compatibility_reflection_::reflectionInitializer_13282492778586199212(*schema);
    iprot->setNextStructType(NewStructure::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->features.clear();
            uint32_t _size14;
            bool _sizeUnknown15;
            apache::thrift::protocol::TType _ktype16 = apache::thrift::protocol::T_STOP;
            apache::thrift::protocol::TType _vtype17 = apache::thrift::protocol::T_STOP;
            xfer += iprot->readMapBegin(_ktype16, _vtype17, _size14, _sizeUnknown15);
            if (_ktype16 == apache::thrift::protocol::T_STOP) {_ktype16 = apache::thrift::protocol::T_I16;}
            if (_vtype17 == apache::thrift::protocol::T_STOP) {_vtype17 = apache::thrift::protocol::T_DOUBLE;}
            if (!_sizeUnknown15) {
              uint32_t _i20;
              for (_i20 = 0; _i20 < _size14; ++_i20)
              {
                int16_t _key21;
                xfer += readIntegral(*iprot, _ktype16, _key21);
                double& _val22 = this->features[_key21];
                xfer += readFloatingPoint(*iprot, _vtype17, _val22);
              }
            } else {
              while (iprot->peekMap())
              {
                int16_t _key23;
                xfer += readIntegral(*iprot, _ktype16, _key23);
                double& _val24 = this->features[_key23];
                xfer += readFloatingPoint(*iprot, _vtype17, _val24);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.features = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void NewStructure::__clear() {
  features.clear();
  __isset.__clear();
}
uint32_t NewStructure::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NewStructure");
  xfer += oprot->writeFieldBegin("features", apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I16, apache::thrift::protocol::T_DOUBLE, this->features.size());
    std::map<int16_t, double> ::const_iterator _iter25;
    for (_iter25 = this->features.begin(); _iter25 != this->features.end(); ++_iter25)
    {
      xfer += oprot->writeI16(_iter25->first);
      xfer += oprot->writeDouble(_iter25->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NewStructure &a, NewStructure &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.features, b.features);
  swap(a.__isset, b.__isset);
}

void merge(const NewStructure& from, NewStructure& to) {
  using apache::thrift::merge;
  merge(from.features, to.features);
  to.__isset.features = to.__isset.features || from.__isset.features;
}

void merge(NewStructure&& from, NewStructure& to) {
  using apache::thrift::merge;
  merge(std::move(from.features), to.features);
  to.__isset.features = to.__isset.features || from.__isset.features;
}

const uint64_t NewStructure2::_reflection_id;
void NewStructure2::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::forward_compatibility_reflection_::reflectionInitializer_8404079032344701484(schema);
}

bool NewStructure2::operator == (const NewStructure2 & rhs) const {
  if (!(this->features == rhs.features))
    return false;
  return true;
}

void NewStructure2::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
  if (false) {}
  else if (_fname == "features") {
    fid = 1;
    _ftype = apache::thrift::protocol::T_MAP;
  }
};

uint32_t NewStructure2::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string _fname;
  apache::thrift::protocol::TType _ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::forward_compatibility_reflection_::reflectionInitializer_8404079032344701484(*schema);
    iprot->setNextStructType(NewStructure2::_reflection_id);
  }
  xfer += iprot->readStructBegin(_fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(_fname, _ftype, fid);
    if (_ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (_ftype == apache::thrift::protocol::T_MAP) {
          {
            this->features.clear();
            uint32_t _size27;
            bool _sizeUnknown28;
            apache::thrift::protocol::TType _ktype29 = apache::thrift::protocol::T_STOP;
            apache::thrift::protocol::TType _vtype30 = apache::thrift::protocol::T_STOP;
            xfer += iprot->readMapBegin(_ktype29, _vtype30, _size27, _sizeUnknown28);
            if (_ktype29 == apache::thrift::protocol::T_STOP) {_ktype29 = apache::thrift::protocol::T_I16;}
            if (_vtype30 == apache::thrift::protocol::T_STOP) {_vtype30 = apache::thrift::protocol::T_FLOAT;}
            if (!_sizeUnknown28) {
              uint32_t _i33;
              for (_i33 = 0; _i33 < _size27; ++_i33)
              {
                int16_t _key34;
                xfer += readIntegral(*iprot, _ktype29, _key34);
                float& _val35 = this->features[_key34];
                xfer += readFloatingPoint(*iprot, _vtype30, _val35);
              }
            } else {
              while (iprot->peekMap())
              {
                int16_t _key36;
                xfer += readIntegral(*iprot, _ktype29, _key36);
                float& _val37 = this->features[_key36];
                xfer += readFloatingPoint(*iprot, _vtype30, _val37);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.features = true;
        } else {
          xfer += iprot->skip(_ftype);
        }
        break;
      default:
        xfer += iprot->skip(_ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void NewStructure2::__clear() {
  features.clear();
  __isset.__clear();
}
uint32_t NewStructure2::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NewStructure2");
  xfer += oprot->writeFieldBegin("features", apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I16, apache::thrift::protocol::T_FLOAT, this->features.size());
    std::map<int16_t, float> ::const_iterator _iter38;
    for (_iter38 = this->features.begin(); _iter38 != this->features.end(); ++_iter38)
    {
      xfer += oprot->writeI16(_iter38->first);
      xfer += oprot->writeFloat(_iter38->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NewStructure2 &a, NewStructure2 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.features, b.features);
  swap(a.__isset, b.__isset);
}

void merge(const NewStructure2& from, NewStructure2& to) {
  using apache::thrift::merge;
  merge(from.features, to.features);
  to.__isset.features = to.__isset.features || from.__isset.features;
}

void merge(NewStructure2&& from, NewStructure2& to) {
  using apache::thrift::merge;
  merge(std::move(from.features), to.features);
  to.__isset.features = to.__isset.features || from.__isset.features;
}


