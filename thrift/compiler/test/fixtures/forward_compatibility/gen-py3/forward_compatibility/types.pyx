#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

cimport cython as __cython
from cpython.object cimport PyTypeObject, Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT, Py_GE
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET as __NOTSET
from thrift.py3.types cimport (
    translate_cpp_enum_to_python,
    SetMetaClass as __SetMetaClass,
    constant_shared_ptr,
)
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer import Protocol as __Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize
import folly.iobuf as __iobuf
from folly.optional cimport cOptional

import sys
import itertools
from collections import Sequence, Set, Mapping, Iterable
import warnings
import builtins as _builtins


cdef cOldStructure _OldStructure_defaults = cOldStructure()

cdef class OldStructure(thrift.py3.types.Struct):

    def __init__(
        OldStructure self, *,
        features=None
    ):
        self._cpp_obj = move(OldStructure._make_instance(
          NULL,
          features,
        ))

    def __call__(
        OldStructure self,
        features=__NOTSET
    ):
        changes = any((
            features is not __NOTSET,
        ))

        if not changes:
            return self

        inst = <OldStructure>OldStructure.__new__(OldStructure)
        inst._cpp_obj = move(OldStructure._make_instance(
          self._cpp_obj.get(),
          features,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cOldStructure] _make_instance(
        cOldStructure* base_instance,
        object features
    ) except *:
        cdef unique_ptr[cOldStructure] c_inst
        if base_instance:
            c_inst = make_unique[cOldStructure](deref(base_instance))
        else:
            c_inst = make_unique[cOldStructure]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if features is None:
                deref(c_inst).features = _OldStructure_defaults.features
                deref(c_inst).__isset.features = False
                pass
            elif features is __NOTSET:
                features = None

        if features is not None:
            deref(c_inst).features = deref(Map__i16_double(features)._cpp_obj)
            deref(c_inst).__isset.features = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'features', self.features

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cOldStructure] cpp_obj):
        inst = <OldStructure>OldStructure.__new__(OldStructure)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def features(self):

        if self.__features is None:
            self.__features = Map__i16_double.create(reference_shared_ptr_features(self._cpp_obj, deref(self._cpp_obj).features))
        return self.__features


    def __hash__(OldStructure self):
        if not self.__hash:
            self.__hash = hash((
            self.features,
            ))
        return self.__hash

    def __repr__(OldStructure self):
        return f'OldStructure(features={repr(self.features)})'
    def __copy__(OldStructure self):
        cdef shared_ptr[cOldStructure] cpp_obj = make_shared[cOldStructure](
            deref(self._cpp_obj)
        )
        return OldStructure.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, OldStructure) and
                isinstance(other, OldStructure)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cOldStructure cself = deref((<OldStructure>self)._cpp_obj)
        cdef cOldStructure cother = deref((<OldStructure>other)._cpp_obj)
        if cop == Py_EQ:
            return cself == cother
        elif cop == Py_NE:
            return not (cself == cother)
        elif cop == Py_LT:
            return cself < cother
        elif cop == Py_LE:
            return cself <= cother
        elif cop == Py_GT:
            return cself > cother
        elif cop == Py_GE:
            return cself >= cother
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(OldStructure self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cOldStructure* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cOldStructure](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cOldStructure](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cOldStructure](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cOldStructure](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(OldStructure self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cOldStructure]()
        cdef cOldStructure* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cOldStructure](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cOldStructure](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cOldStructure](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cOldStructure](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (OldStructure, serialize(self)))


cdef cNewStructure _NewStructure_defaults = cNewStructure()

cdef class NewStructure(thrift.py3.types.Struct):

    def __init__(
        NewStructure self, *,
        features=None
    ):
        self._cpp_obj = move(NewStructure._make_instance(
          NULL,
          features,
        ))

    def __call__(
        NewStructure self,
        features=__NOTSET
    ):
        changes = any((
            features is not __NOTSET,
        ))

        if not changes:
            return self

        inst = <NewStructure>NewStructure.__new__(NewStructure)
        inst._cpp_obj = move(NewStructure._make_instance(
          self._cpp_obj.get(),
          features,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cNewStructure] _make_instance(
        cNewStructure* base_instance,
        object features
    ) except *:
        cdef unique_ptr[cNewStructure] c_inst
        if base_instance:
            c_inst = make_unique[cNewStructure](deref(base_instance))
        else:
            c_inst = make_unique[cNewStructure]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if features is None:
                deref(c_inst).features = _NewStructure_defaults.features
                deref(c_inst).__isset.features = False
                pass
            elif features is __NOTSET:
                features = None

        if features is not None:
            deref(c_inst).features = deref(Map__i16_double(features)._cpp_obj)
            deref(c_inst).__isset.features = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'features', self.features

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cNewStructure] cpp_obj):
        inst = <NewStructure>NewStructure.__new__(NewStructure)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def features(self):

        if self.__features is None:
            self.__features = Map__i16_double.create(reference_shared_ptr_features(self._cpp_obj, deref(self._cpp_obj).features))
        return self.__features


    def __hash__(NewStructure self):
        if not self.__hash:
            self.__hash = hash((
            self.features,
            ))
        return self.__hash

    def __repr__(NewStructure self):
        return f'NewStructure(features={repr(self.features)})'
    def __copy__(NewStructure self):
        cdef shared_ptr[cNewStructure] cpp_obj = make_shared[cNewStructure](
            deref(self._cpp_obj)
        )
        return NewStructure.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, NewStructure) and
                isinstance(other, NewStructure)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cNewStructure cself = deref((<NewStructure>self)._cpp_obj)
        cdef cNewStructure cother = deref((<NewStructure>other)._cpp_obj)
        if cop == Py_EQ:
            return cself == cother
        elif cop == Py_NE:
            return not (cself == cother)
        elif cop == Py_LT:
            return cself < cother
        elif cop == Py_LE:
            return cself <= cother
        elif cop == Py_GT:
            return cself > cother
        elif cop == Py_GE:
            return cself >= cother
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(NewStructure self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cNewStructure* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cNewStructure](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cNewStructure](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cNewStructure](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cNewStructure](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(NewStructure self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cNewStructure]()
        cdef cNewStructure* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cNewStructure](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cNewStructure](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cNewStructure](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cNewStructure](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (NewStructure, serialize(self)))


cdef cNewStructure2 _NewStructure2_defaults = cNewStructure2()

cdef class NewStructure2(thrift.py3.types.Struct):

    def __init__(
        NewStructure2 self, *,
        features=None
    ):
        self._cpp_obj = move(NewStructure2._make_instance(
          NULL,
          features,
        ))

    def __call__(
        NewStructure2 self,
        features=__NOTSET
    ):
        changes = any((
            features is not __NOTSET,
        ))

        if not changes:
            return self

        inst = <NewStructure2>NewStructure2.__new__(NewStructure2)
        inst._cpp_obj = move(NewStructure2._make_instance(
          self._cpp_obj.get(),
          features,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cNewStructure2] _make_instance(
        cNewStructure2* base_instance,
        object features
    ) except *:
        cdef unique_ptr[cNewStructure2] c_inst
        if base_instance:
            c_inst = make_unique[cNewStructure2](deref(base_instance))
        else:
            c_inst = make_unique[cNewStructure2]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if features is None:
                deref(c_inst).features = _NewStructure2_defaults.features
                deref(c_inst).__isset.features = False
                pass
            elif features is __NOTSET:
                features = None

        if features is not None:
            deref(c_inst).features = deref(Map__i16_float(features)._cpp_obj)
            deref(c_inst).__isset.features = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'features', self.features

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cNewStructure2] cpp_obj):
        inst = <NewStructure2>NewStructure2.__new__(NewStructure2)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def features(self):

        if self.__features is None:
            self.__features = Map__i16_float.create(reference_shared_ptr_features(self._cpp_obj, deref(self._cpp_obj).features))
        return self.__features


    def __hash__(NewStructure2 self):
        if not self.__hash:
            self.__hash = hash((
            self.features,
            ))
        return self.__hash

    def __repr__(NewStructure2 self):
        return f'NewStructure2(features={repr(self.features)})'
    def __copy__(NewStructure2 self):
        cdef shared_ptr[cNewStructure2] cpp_obj = make_shared[cNewStructure2](
            deref(self._cpp_obj)
        )
        return NewStructure2.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, NewStructure2) and
                isinstance(other, NewStructure2)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cNewStructure2 cself = deref((<NewStructure2>self)._cpp_obj)
        cdef cNewStructure2 cother = deref((<NewStructure2>other)._cpp_obj)
        if cop == Py_EQ:
            return cself == cother
        elif cop == Py_NE:
            return not (cself == cother)
        elif cop == Py_LT:
            return cself < cother
        elif cop == Py_LE:
            return cself <= cother
        elif cop == Py_GT:
            return cself > cother
        elif cop == Py_GE:
            return cself >= cother
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(NewStructure2 self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cNewStructure2* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cNewStructure2](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cNewStructure2](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cNewStructure2](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cNewStructure2](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(NewStructure2 self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cNewStructure2]()
        cdef cNewStructure2* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cNewStructure2](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cNewStructure2](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cNewStructure2](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cNewStructure2](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (NewStructure2, serialize(self)))


cdef cNewStructureNested _NewStructureNested_defaults = cNewStructureNested()

cdef class NewStructureNested(thrift.py3.types.Struct):

    def __init__(
        NewStructureNested self, *,
        lst=None,
        mp=None,
        s=None
    ):
        self._cpp_obj = move(NewStructureNested._make_instance(
          NULL,
          lst,
          mp,
          s,
        ))

    def __call__(
        NewStructureNested self,
        lst=__NOTSET,
        mp=__NOTSET,
        s=__NOTSET
    ):
        changes = any((
            lst is not __NOTSET,

            mp is not __NOTSET,

            s is not __NOTSET,
        ))

        if not changes:
            return self

        inst = <NewStructureNested>NewStructureNested.__new__(NewStructureNested)
        inst._cpp_obj = move(NewStructureNested._make_instance(
          self._cpp_obj.get(),
          lst,
          mp,
          s,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cNewStructureNested] _make_instance(
        cNewStructureNested* base_instance,
        object lst,
        object mp,
        object s
    ) except *:
        cdef unique_ptr[cNewStructureNested] c_inst
        if base_instance:
            c_inst = make_unique[cNewStructureNested](deref(base_instance))
        else:
            c_inst = make_unique[cNewStructureNested]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if lst is None:
                deref(c_inst).lst = _NewStructureNested_defaults.lst
                deref(c_inst).__isset.lst = False
                pass
            elif lst is __NOTSET:
                lst = None

            if mp is None:
                deref(c_inst).mp = _NewStructureNested_defaults.mp
                deref(c_inst).__isset.mp = False
                pass
            elif mp is __NOTSET:
                mp = None

            if s is None:
                deref(c_inst).s = _NewStructureNested_defaults.s
                deref(c_inst).__isset.s = False
                pass
            elif s is __NOTSET:
                s = None

        if lst is not None:
            deref(c_inst).lst = deref(List__Map__i16_float(lst)._cpp_obj)
            deref(c_inst).__isset.lst = True
        if mp is not None:
            deref(c_inst).mp = deref(Map__i16_Map__i16_float(mp)._cpp_obj)
            deref(c_inst).__isset.mp = True
        if s is not None:
            deref(c_inst).s = deref(Set__Map__i16_float(s)._cpp_obj)
            deref(c_inst).__isset.s = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'lst', self.lst
        yield 'mp', self.mp
        yield 's', self.s

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cNewStructureNested] cpp_obj):
        inst = <NewStructureNested>NewStructureNested.__new__(NewStructureNested)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def lst(self):

        if self.__lst is None:
            self.__lst = List__Map__i16_float.create(reference_shared_ptr_lst(self._cpp_obj, deref(self._cpp_obj).lst))
        return self.__lst

    @property
    def mp(self):

        if self.__mp is None:
            self.__mp = Map__i16_Map__i16_float.create(reference_shared_ptr_mp(self._cpp_obj, deref(self._cpp_obj).mp))
        return self.__mp

    @property
    def s(self):

        if self.__s is None:
            self.__s = Set__Map__i16_float.create(reference_shared_ptr_s(self._cpp_obj, deref(self._cpp_obj).s))
        return self.__s


    def __hash__(NewStructureNested self):
        if not self.__hash:
            self.__hash = hash((
            self.lst,
            self.mp,
            self.s,
            ))
        return self.__hash

    def __repr__(NewStructureNested self):
        return f'NewStructureNested(lst={repr(self.lst)}, mp={repr(self.mp)}, s={repr(self.s)})'
    def __copy__(NewStructureNested self):
        cdef shared_ptr[cNewStructureNested] cpp_obj = make_shared[cNewStructureNested](
            deref(self._cpp_obj)
        )
        return NewStructureNested.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, NewStructureNested) and
                isinstance(other, NewStructureNested)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cNewStructureNested cself = deref((<NewStructureNested>self)._cpp_obj)
        cdef cNewStructureNested cother = deref((<NewStructureNested>other)._cpp_obj)
        if cop == Py_EQ:
            return cself == cother
        elif cop == Py_NE:
            return not (cself == cother)
        elif cop == Py_LT:
            return cself < cother
        elif cop == Py_LE:
            return cself <= cother
        elif cop == Py_GT:
            return cself > cother
        elif cop == Py_GE:
            return cself >= cother
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(NewStructureNested self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cNewStructureNested* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cNewStructureNested](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cNewStructureNested](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cNewStructureNested](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cNewStructureNested](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(NewStructureNested self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cNewStructureNested]()
        cdef cNewStructureNested* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cNewStructureNested](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cNewStructureNested](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cNewStructureNested](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cNewStructureNested](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (NewStructureNested, serialize(self)))


cdef cNewStructureNestedField _NewStructureNestedField_defaults = cNewStructureNestedField()

cdef class NewStructureNestedField(thrift.py3.types.Struct):

    def __init__(
        NewStructureNestedField self, *,
        NewStructureNested f=None
    ):
        self._cpp_obj = move(NewStructureNestedField._make_instance(
          NULL,
          f,
        ))

    def __call__(
        NewStructureNestedField self,
        f=__NOTSET
    ):
        changes = any((
            f is not __NOTSET,
        ))

        if not changes:
            return self

        if None is not f is not __NOTSET:
            if not isinstance(f, NewStructureNested):
                raise TypeError(f'f is not a { NewStructureNested !r}.')

        inst = <NewStructureNestedField>NewStructureNestedField.__new__(NewStructureNestedField)
        inst._cpp_obj = move(NewStructureNestedField._make_instance(
          self._cpp_obj.get(),
          f,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cNewStructureNestedField] _make_instance(
        cNewStructureNestedField* base_instance,
        object f
    ) except *:
        cdef unique_ptr[cNewStructureNestedField] c_inst
        if base_instance:
            c_inst = make_unique[cNewStructureNestedField](deref(base_instance))
        else:
            c_inst = make_unique[cNewStructureNestedField]()

        if base_instance:
            # Convert None's to default value. (or unset)
            if f is None:
                deref(c_inst).f = _NewStructureNestedField_defaults.f
                deref(c_inst).__isset.f = False
                pass
            elif f is __NOTSET:
                f = None

        if f is not None:
            deref(c_inst).f = deref((<NewStructureNested?> f)._cpp_obj)
            deref(c_inst).__isset.f = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'f', self.f

    def __bool__(self):
        return True

    @staticmethod
    cdef create(shared_ptr[cNewStructureNestedField] cpp_obj):
        inst = <NewStructureNestedField>NewStructureNestedField.__new__(NewStructureNestedField)
        inst._cpp_obj = move_shared(cpp_obj)
        return inst

    @property
    def f(self):

        if self.__f is None:
            self.__f = NewStructureNested.create(reference_shared_ptr_f(self._cpp_obj, deref(self._cpp_obj).f))
        return self.__f


    def __hash__(NewStructureNestedField self):
        if not self.__hash:
            self.__hash = hash((
            self.f,
            ))
        return self.__hash

    def __repr__(NewStructureNestedField self):
        return f'NewStructureNestedField(f={repr(self.f)})'
    def __copy__(NewStructureNestedField self):
        cdef shared_ptr[cNewStructureNestedField] cpp_obj = make_shared[cNewStructureNestedField](
            deref(self._cpp_obj)
        )
        return NewStructureNestedField.create(move_shared(cpp_obj))

    def __richcmp__(self, other, op):
        cdef int cop = op
        if not (
                isinstance(self, NewStructureNestedField) and
                isinstance(other, NewStructureNestedField)):
            if cop == Py_EQ:  # different types are never equal
                return False
            elif cop == Py_NE:  # different types are always notequal
                return True
            else:
                return NotImplemented

        cdef cNewStructureNestedField cself = deref((<NewStructureNestedField>self)._cpp_obj)
        cdef cNewStructureNestedField cother = deref((<NewStructureNestedField>other)._cpp_obj)
        if cop == Py_EQ:
            return cself == cother
        elif cop == Py_NE:
            return not (cself == cother)
        elif cop == Py_LT:
            return cself < cother
        elif cop == Py_LE:
            return cself <= cother
        elif cop == Py_GT:
            return cself > cother
        elif cop == Py_GE:
            return cself >= cother
        else:
            return NotImplemented

    cdef __iobuf.IOBuf _serialize(NewStructureNestedField self, proto):
        cdef __iobuf.cIOBufQueue queue = __iobuf.cIOBufQueue(__iobuf.cacheChainLength())
        cdef cNewStructureNestedField* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                serializer.CompactSerialize[cNewStructureNestedField](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                serializer.BinarySerialize[cNewStructureNestedField](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                serializer.JSONSerialize[cNewStructureNestedField](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                serializer.CompactJSONSerialize[cNewStructureNestedField](deref(cpp_obj), &queue, serializer.SHARE_EXTERNAL_BUFFER)
        return __iobuf.from_unique_ptr(queue.move())

    cdef uint32_t _deserialize(NewStructureNestedField self, const __iobuf.cIOBuf* buf, proto) except? 0:
        cdef uint32_t needed
        self._cpp_obj = make_shared[cNewStructureNestedField]()
        cdef cNewStructureNestedField* cpp_obj = self._cpp_obj.get()
        if proto is __Protocol.COMPACT:
            with nogil:
                needed = serializer.CompactDeserialize[cNewStructureNestedField](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.BINARY:
            with nogil:
                needed = serializer.BinaryDeserialize[cNewStructureNestedField](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.JSON:
            with nogil:
                needed = serializer.JSONDeserialize[cNewStructureNestedField](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        elif proto is __Protocol.COMPACT_JSON:
            with nogil:
                needed = serializer.CompactJSONDeserialize[cNewStructureNestedField](buf, deref(cpp_obj), serializer.SHARE_EXTERNAL_BUFFER)
        return needed

    def __reduce__(self):
        return (deserialize, (NewStructureNestedField, serialize(self)))


cdef class Map__i16_double:
    def __init__(self, items=None):
        if isinstance(items, Map__i16_double):
            self._cpp_obj = (<Map__i16_double> items)._cpp_obj
        else:
            self._cpp_obj = Map__i16_double._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[int16_t,double]] c_items):
        inst = <Map__i16_double>Map__i16_double.__new__(Map__i16_double)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__i16_double self):
        cdef shared_ptr[cmap[int16_t,double]] cpp_obj = make_shared[cmap[int16_t,double]](
            deref(self._cpp_obj)
        )
        return Map__i16_double.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[int16_t,double]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[int16_t,double]] c_inst = make_shared[cmap[int16_t,double]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int16_t> key
                if not isinstance(item, (float, int)):
                    raise TypeError(f"{item!r} is not of type float")

                deref(c_inst)[key] = item
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err from None
        cdef cmap[int16_t,double].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef double citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int16_t citem
        cdef cmap[int16_t,double].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield citem
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int16_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef double citem
        cdef cmap[int16_t,double].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield citem
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef int16_t ckey
        cdef double citem
        cdef cmap[int16_t,double].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey, citem)
            inc(loc)



Mapping.register(Map__i16_double)

cdef class Map__i16_float:
    def __init__(self, items=None):
        if isinstance(items, Map__i16_float):
            self._cpp_obj = (<Map__i16_float> items)._cpp_obj
        else:
            self._cpp_obj = Map__i16_float._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[int16_t,float]] c_items):
        inst = <Map__i16_float>Map__i16_float.__new__(Map__i16_float)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__i16_float self):
        cdef shared_ptr[cmap[int16_t,float]] cpp_obj = make_shared[cmap[int16_t,float]](
            deref(self._cpp_obj)
        )
        return Map__i16_float.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[int16_t,float]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[int16_t,float]] c_inst = make_shared[cmap[int16_t,float]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int16_t> key
                if not isinstance(item, (float, int)):
                    raise TypeError(f"{item!r} is not of type float")

                deref(c_inst)[key] = item
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err from None
        cdef cmap[int16_t,float].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef float citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int16_t citem
        cdef cmap[int16_t,float].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield citem
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int16_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef float citem
        cdef cmap[int16_t,float].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield citem
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef int16_t ckey
        cdef float citem
        cdef cmap[int16_t,float].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey, citem)
            inc(loc)



Mapping.register(Map__i16_float)

cdef class List__Map__i16_float:
    def __init__(self, items=None):
        if isinstance(items, List__Map__i16_float):
            self._cpp_obj = (<List__Map__i16_float> items)._cpp_obj
        else:
            self._cpp_obj = List__Map__i16_float._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cmap[int16_t,float]]] c_items):
        inst = <List__Map__i16_float>List__Map__i16_float.__new__(List__Map__i16_float)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__Map__i16_float self):
        cdef shared_ptr[vector[cmap[int16_t,float]]] cpp_obj = make_shared[vector[cmap[int16_t,float]]](
            deref(self._cpp_obj)
        )
        return List__Map__i16_float.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[cmap[int16_t,float]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cmap[int16_t,float]]] c_inst = make_shared[vector[cmap[int16_t,float]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Mapping[int, float]")
                if not isinstance(item, Map__i16_float):
                    item = Map__i16_float(item)
                deref(c_inst).push_back(deref((<Map__i16_float>item)._cpp_obj))
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[cmap[int16_t,float]]] c_inst
        cdef shared_ptr[cmap[int16_t,float]] citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[cmap[int16_t,float]]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__Map__i16_float.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = reference_shared_ptr_List__Map__i16_float(self._cpp_obj, deref(self._cpp_obj)[index])
            return Map__i16_float.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Map__i16_float):
                item = Map__i16_float(item)
        except Exception:
            return False
        if not isinstance(item, Map__i16_float):
            return False
        return std_libcpp.find[vector[cmap[int16_t,float]].iterator, cmap[int16_t,float]](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Map__i16_float>item)._cpp_obj)) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[cmap[int16_t,float]] citem
        cdef vector[cmap[int16_t,float]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_List__Map__i16_float(self._cpp_obj, deref(loc))
            yield Map__i16_float.create(citem)
            inc(loc)


    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[cmap[int16_t,float]] citem
        cdef vector[cmap[int16_t,float]].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = reference_shared_ptr_List__Map__i16_float(self._cpp_obj, deref(loc))
            yield Map__i16_float.create(citem)
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        try:
            if not isinstance(item, Map__i16_float):
                item = Map__i16_float(item)
        except Exception:
            raise err from None
        if not isinstance(item, Map__i16_float):
            raise err
        cdef vector[cmap[int16_t,float]].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef vector[cmap[int16_t,float]].iterator loc = std_libcpp.find[vector[cmap[int16_t,float]].iterator, cmap[int16_t,float]](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            deref((<Map__i16_float>item)._cpp_obj)        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        try:
            if not isinstance(item, Map__i16_float):
                item = Map__i16_float(item)
        except Exception:
            return 0
        if not isinstance(item, Map__i16_float):
            return 0
        return <int64_t> std_libcpp.count[vector[cmap[int16_t,float]].iterator, cmap[int16_t,float]](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), deref((<Map__i16_float>item)._cpp_obj))


Sequence.register(List__Map__i16_float)

cdef class Map__i16_Map__i16_float:
    def __init__(self, items=None):
        if isinstance(items, Map__i16_Map__i16_float):
            self._cpp_obj = (<Map__i16_Map__i16_float> items)._cpp_obj
        else:
            self._cpp_obj = Map__i16_Map__i16_float._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[int16_t,cmap[int16_t,float]]] c_items):
        inst = <Map__i16_Map__i16_float>Map__i16_Map__i16_float.__new__(Map__i16_Map__i16_float)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__i16_Map__i16_float self):
        cdef shared_ptr[cmap[int16_t,cmap[int16_t,float]]] cpp_obj = make_shared[cmap[int16_t,cmap[int16_t,float]]](
            deref(self._cpp_obj)
        )
        return Map__i16_Map__i16_float.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[int16_t,cmap[int16_t,float]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[int16_t,cmap[int16_t,float]]] c_inst = make_shared[cmap[int16_t,cmap[int16_t,float]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int16_t> key
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[int, float]")
                if not isinstance(item, Map__i16_float):
                    item = Map__i16_float(item)

                deref(c_inst)[key] = deref((<Map__i16_float>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err from None
        cdef cmap[int16_t,cmap[int16_t,float]].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[cmap[int16_t,float]] citem = reference_shared_ptr_Map__i16_Map__i16_float(self._cpp_obj, deref(iter).second)
        return Map__i16_float.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int16_t citem
        cdef cmap[int16_t,cmap[int16_t,float]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield citem
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int16_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[cmap[int16_t,float]] citem
        cdef cmap[int16_t,cmap[int16_t,float]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__i16_Map__i16_float(self._cpp_obj, deref(loc).second)
            yield Map__i16_float.create(citem)
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef int16_t ckey
        cdef shared_ptr[cmap[int16_t,float]] citem
        cdef cmap[int16_t,cmap[int16_t,float]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__i16_Map__i16_float(self._cpp_obj, deref(loc).second)
            yield (ckey, Map__i16_float.create(citem))
            inc(loc)



Mapping.register(Map__i16_Map__i16_float)

cdef class Set__Map__i16_float:
    def __init__(self, items=None):
        if isinstance(items, Set__Map__i16_float):
            self._cpp_obj = (<Set__Map__i16_float> items)._cpp_obj
        else:
            self._cpp_obj = Set__Map__i16_float._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cset[cmap[int16_t,float]]] c_items):
        inst = <Set__Map__i16_float>Set__Map__i16_float.__new__(Set__Map__i16_float)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Set__Map__i16_float self):
        cdef shared_ptr[cset[cmap[int16_t,float]]] cpp_obj = make_shared[cset[cmap[int16_t,float]]](
            deref(self._cpp_obj)
        )
        return Set__Map__i16_float.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cset[cmap[int16_t,float]]] _make_instance(object items) except *:
        cdef shared_ptr[cset[cmap[int16_t,float]]] c_inst = make_shared[cset[cmap[int16_t,float]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[int, float]")
                if not isinstance(item, Map__i16_float):
                    item = Map__i16_float(item)
                deref(c_inst).insert(deref((<Map__i16_float>item)._cpp_obj))
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        try:
            if not isinstance(item, Map__i16_float):
                item = Map__i16_float(item)
        except Exception:
            return False
        if not isinstance(item, Map__i16_float):
            return False
        return pbool(deref(self._cpp_obj).count(deref((<Map__i16_float>item)._cpp_obj)))


    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[cmap[int16_t,float]] citem
        cdef cset[cmap[int16_t,float]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Set__Map__i16_float(self._cpp_obj, deref(loc))
            yield Map__i16_float.create(citem)
            inc(loc)

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef shared_ptr[cset[cmap[int16_t,float]]] cself, cother
        cdef cset[cmap[int16_t,float]].iterator loc
        if (isinstance(self, Set__Map__i16_float) and
                isinstance(other, Set__Map__i16_float)):
            cself = (<Set__Map__i16_float> self)._cpp_obj
            cother = (<Set__Map__i16_float> other)._cpp_obj
            # C level comparisons
            if cop == Py_LT:    # Less Than (strict subset)
                if not deref(cself).size() < deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_LE:  # Less Than or Equal To  (subset)
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_EQ:  # Equivalent
                if deref(cself).size() != deref(cother).size():
                    return False
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_NE:  # Not Equivalent
                loc = deref(cself).begin()
                while loc != deref(cself).end():
                    if not deref(cother).count(deref(loc)):
                        return True
                    inc(loc)
                return deref(cself).size() != deref(cother).size()
            elif cop == Py_GT:  # Greater Than (strict superset)
                if not deref(cself).size() > deref(cother).size():
                    return False
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True
            elif cop == Py_GE:  # Greater Than or Equal To (superset)
                loc = deref(cother).begin()
                while loc != deref(cother).end():
                    if not deref(cself).count(deref(loc)):
                        return False
                    inc(loc)
                return True

        # Python level comparisons
        if cop == Py_LT:
            return Set.__lt__(self, other)
        elif cop == Py_LE:
            return Set.__le__(self, other)
        elif cop == Py_EQ:
            return Set.__eq__(self, other)
        elif cop == Py_NE:
            return Set.__ne__(self, other)
        elif cop == Py_GT:
            return Set.__gt__(self, other)
        elif cop == Py_GE:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, Set__Map__i16_float):
            self = Set__Map__i16_float(self)
        if not isinstance(other, Set__Map__i16_float):
            other = Set__Map__i16_float(other)

        cdef shared_ptr[cset[cmap[int16_t,float]]] shretval = \
            make_shared[cset[cmap[int16_t,float]]]()

        cdef shared_ptr[cset[cmap[int16_t,float]]] cself = (<Set__Map__i16_float> self)._cpp_obj
        cdef shared_ptr[cset[cmap[int16_t,float]]] cother = (<Set__Map__i16_float> other)._cpp_obj

        cdef cset[cmap[int16_t,float]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) > 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Map__i16_float.create(move_shared(shretval))

    def __sub__(self, other):
        if not isinstance(self, Set__Map__i16_float):
            self = Set__Map__i16_float(self)
        if not isinstance(other, Set__Map__i16_float):
            other = Set__Map__i16_float(other)

        cdef shared_ptr[cset[cmap[int16_t,float]]] shretval = \
            make_shared[cset[cmap[int16_t,float]]]()

        cdef shared_ptr[cset[cmap[int16_t,float]]] cself = (<Set__Map__i16_float> self)._cpp_obj
        cdef shared_ptr[cset[cmap[int16_t,float]]] cother = (<Set__Map__i16_float> other)._cpp_obj

        cdef cset[cmap[int16_t,float]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Map__i16_float.create(move_shared(shretval))

    def __or__(self, other):
        if not isinstance(self, Set__Map__i16_float):
            self = Set__Map__i16_float(self)
        if not isinstance(other, Set__Map__i16_float):
            other = Set__Map__i16_float(other)

        cdef shared_ptr[cset[cmap[int16_t,float]]] shretval = \
            make_shared[cset[cmap[int16_t,float]]]()

        cdef shared_ptr[cset[cmap[int16_t,float]]] cself = (<Set__Map__i16_float> self)._cpp_obj
        cdef shared_ptr[cset[cmap[int16_t,float]]] cother = (<Set__Map__i16_float> other)._cpp_obj

        cdef cset[cmap[int16_t,float]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Map__i16_float.create(move_shared(shretval))

    def __xor__(self, other):
        if not isinstance(self, Set__Map__i16_float):
            self = Set__Map__i16_float(self)
        if not isinstance(other, Set__Map__i16_float):
            other = Set__Map__i16_float(other)

        cdef shared_ptr[cset[cmap[int16_t,float]]] shretval = \
            make_shared[cset[cmap[int16_t,float]]]()

        cdef shared_ptr[cset[cmap[int16_t,float]]] cself = (<Set__Map__i16_float> self)._cpp_obj
        cdef shared_ptr[cset[cmap[int16_t,float]]] cother = (<Set__Map__i16_float> other)._cpp_obj

        cdef cset[cmap[int16_t,float]].iterator loc = deref(cself).begin()
        while loc != deref(cself).end():
            if deref(cother).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        loc = deref(cother).begin()
        while loc != deref(cother).end():
            if deref(cself).count(deref(loc)) == 0:
                deref(shretval).insert(deref(loc))
            inc(loc)
        return Set__Map__i16_float.create(move_shared(shretval))

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(Set__Map__i16_float)

cdef class Map__i64_double:
    def __init__(self, items=None):
        if isinstance(items, Map__i64_double):
            self._cpp_obj = (<Map__i64_double> items)._cpp_obj
        else:
            self._cpp_obj = Map__i64_double._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[int64_t,double]] c_items):
        inst = <Map__i64_double>Map__i64_double.__new__(Map__i64_double)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__i64_double self):
        cdef shared_ptr[cmap[int64_t,double]] cpp_obj = make_shared[cmap[int64_t,double]](
            deref(self._cpp_obj)
        )
        return Map__i64_double.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[int64_t,double]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[int64_t,double]] c_inst = make_shared[cmap[int64_t,double]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int64_t> key
                if not isinstance(item, (float, int)):
                    raise TypeError(f"{item!r} is not of type float")

                deref(c_inst)[key] = item
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err from None
        cdef cmap[int64_t,double].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef double citem = deref(iter).second
        return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int64_t citem
        cdef cmap[int64_t,double].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield citem
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int64_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef double citem
        cdef cmap[int64_t,double].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).second
            yield citem
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef int64_t ckey
        cdef double citem
        cdef cmap[int64_t,double].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = deref(loc).second
            yield (ckey, citem)
            inc(loc)



Mapping.register(Map__i64_double)

cdef class Map__i16_Map__i64_double:
    def __init__(self, items=None):
        if isinstance(items, Map__i16_Map__i64_double):
            self._cpp_obj = (<Map__i16_Map__i64_double> items)._cpp_obj
        else:
            self._cpp_obj = Map__i16_Map__i64_double._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[int16_t,cmap[int64_t,double]]] c_items):
        inst = <Map__i16_Map__i64_double>Map__i16_Map__i64_double.__new__(Map__i16_Map__i64_double)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__i16_Map__i64_double self):
        cdef shared_ptr[cmap[int16_t,cmap[int64_t,double]]] cpp_obj = make_shared[cmap[int16_t,cmap[int64_t,double]]](
            deref(self._cpp_obj)
        )
        return Map__i16_Map__i64_double.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[int16_t,cmap[int64_t,double]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[int16_t,cmap[int64_t,double]]] c_inst = make_shared[cmap[int16_t,cmap[int64_t,double]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int16_t> key
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[int, float]")
                if not isinstance(item, Map__i64_double):
                    item = Map__i64_double(item)

                deref(c_inst)[key] = deref((<Map__i64_double>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err from None
        cdef cmap[int16_t,cmap[int64_t,double]].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[cmap[int64_t,double]] citem = reference_shared_ptr_Map__i16_Map__i64_double(self._cpp_obj, deref(iter).second)
        return Map__i64_double.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int16_t citem
        cdef cmap[int16_t,cmap[int64_t,double]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield citem
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int16_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[cmap[int64_t,double]] citem
        cdef cmap[int16_t,cmap[int64_t,double]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__i16_Map__i64_double(self._cpp_obj, deref(loc).second)
            yield Map__i64_double.create(citem)
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef int16_t ckey
        cdef shared_ptr[cmap[int64_t,double]] citem
        cdef cmap[int16_t,cmap[int64_t,double]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__i16_Map__i64_double(self._cpp_obj, deref(loc).second)
            yield (ckey, Map__i64_double.create(citem))
            inc(loc)



Mapping.register(Map__i16_Map__i64_double)

cdef class Map__i32_Map__i64_double:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_Map__i64_double):
            self._cpp_obj = (<Map__i32_Map__i64_double> items)._cpp_obj
        else:
            self._cpp_obj = Map__i32_Map__i64_double._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,cmap[int64_t,double]]] c_items):
        inst = <Map__i32_Map__i64_double>Map__i32_Map__i64_double.__new__(Map__i32_Map__i64_double)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__i32_Map__i64_double self):
        cdef shared_ptr[cmap[int32_t,cmap[int64_t,double]]] cpp_obj = make_shared[cmap[int32_t,cmap[int64_t,double]]](
            deref(self._cpp_obj)
        )
        return Map__i32_Map__i64_double.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[int32_t,cmap[int64_t,double]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[int32_t,cmap[int64_t,double]]] c_inst = make_shared[cmap[int32_t,cmap[int64_t,double]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int32_t> key
                if item is None:
                    raise TypeError("None is not of type _typing.Mapping[int, float]")
                if not isinstance(item, Map__i64_double):
                    item = Map__i64_double(item)

                deref(c_inst)[key] = deref((<Map__i64_double>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err from None
        cdef cmap[int32_t,cmap[int64_t,double]].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[cmap[int64_t,double]] citem = reference_shared_ptr_Map__i32_Map__i64_double(self._cpp_obj, deref(iter).second)
        return Map__i64_double.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef cmap[int32_t,cmap[int64_t,double]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield citem
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[cmap[int64_t,double]] citem
        cdef cmap[int32_t,cmap[int64_t,double]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__i32_Map__i64_double(self._cpp_obj, deref(loc).second)
            yield Map__i64_double.create(citem)
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef shared_ptr[cmap[int64_t,double]] citem
        cdef cmap[int32_t,cmap[int64_t,double]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__i32_Map__i64_double(self._cpp_obj, deref(loc).second)
            yield (ckey, Map__i64_double.create(citem))
            inc(loc)



Mapping.register(Map__i32_Map__i64_double)

cdef class List__float:
    def __init__(self, items=None):
        if isinstance(items, List__float):
            self._cpp_obj = (<List__float> items)._cpp_obj
        else:
            self._cpp_obj = List__float._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[float]] c_items):
        inst = <List__float>List__float.__new__(List__float)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(List__float self):
        cdef shared_ptr[vector[float]] cpp_obj = make_shared[vector[float]](
            deref(self._cpp_obj)
        )
        return List__float.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[vector[float]] _make_instance(object items) except *:
        cdef shared_ptr[vector[float]] c_inst = make_shared[vector[float]]()
        if items is not None:
            for item in items:
                if not isinstance(item, (float, int)):
                    raise TypeError(f"{item!r} is not of type float")
                deref(c_inst).push_back(item)
        return c_inst

    def __add__(object self, object other):
        return type(self)(itertools.chain(self, other))

    def __getitem__(self, object index_obj):
        cdef shared_ptr[vector[float]] c_inst
        cdef float citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[float]]()
            sz = deref(self._cpp_obj).size()
            for index in range(*index_obj.indices(sz)):
                deref(c_inst).push_back(deref(self._cpp_obj)[index])
            return List__float.create(move_shared(c_inst))
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size + index
            if index >= size or index < 0:
                raise IndexError('list index out of range')
            citem = deref(self._cpp_obj)[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __eq__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_EQ)

    def __ne__(self, other):
        return not thrift.py3.types.list_compare(self, other, Py_EQ)

    def __lt__(self, other):
        return thrift.py3.types.list_compare(self, other, Py_LT)

    def __gt__(self, other):
        return thrift.py3.types.list_compare(other, self, Py_LT)

    def __le__(self, other):
        result = thrift.py3.types.list_compare(other, self, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __ge__(self, other):
        result = thrift.py3.types.list_compare(self, other, Py_LT)
        return not result if result is not NotImplemented else NotImplemented

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, float):
            return False
        return std_libcpp.find[vector[float].iterator, float](deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item) != deref(self._cpp_obj).end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef float citem
        cdef vector[float].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc)
            yield citem
            inc(loc)


    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef float citem
        cdef vector[float].reverse_iterator loc = deref(self._cpp_obj).rbegin()
        while loc != deref(self._cpp_obj).rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item, start not None=__NOTSET, stop not None=__NOTSET):
        err = ValueError(f'{item} is not in list')
        if not self or item is None:
            raise err
        offset_begin = offset_end = 0
        if stop is not __NOTSET or start is not __NOTSET:
            # Like self[start:stop].index(item)
            size = len(self)
            stop = stop if stop is not __NOTSET else size
            start = start if start is not __NOTSET else 0
            # Convert stop to a negative position.
            if stop > 0:
                stop = min(stop - size, 0)
            if stop <= -size:
                raise err  # List would be empty
            offset_end = -stop
            # Convert start to always be positive
            if start < 0:
                start = max(size + start, 0)
            if start >= size:
                raise err  # past end of list
            offset_begin = start

        if not isinstance(item, float):
            raise err
        cdef vector[float].iterator end = std_libcpp.prev(deref(self._cpp_obj).end(), <int64_t>offset_end)
        cdef vector[float].iterator loc = std_libcpp.find[vector[float].iterator, float](
            std_libcpp.next(deref(self._cpp_obj).begin(), <int64_t>offset_begin),
            end,
            item        )
        if loc != end:
            return <int64_t> std_libcpp.distance(deref(self._cpp_obj).begin(), loc)
        raise err

    def count(self, item):
        if not self or item is None:
            return 0
        if not isinstance(item, float):
            return 0
        return <int64_t> std_libcpp.count[vector[float].iterator, float](
            deref(self._cpp_obj).begin(), deref(self._cpp_obj).end(), item)


Sequence.register(List__float)

cdef class Map__i16_List__float:
    def __init__(self, items=None):
        if isinstance(items, Map__i16_List__float):
            self._cpp_obj = (<Map__i16_List__float> items)._cpp_obj
        else:
            self._cpp_obj = Map__i16_List__float._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[int16_t,vector[float]]] c_items):
        inst = <Map__i16_List__float>Map__i16_List__float.__new__(Map__i16_List__float)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__i16_List__float self):
        cdef shared_ptr[cmap[int16_t,vector[float]]] cpp_obj = make_shared[cmap[int16_t,vector[float]]](
            deref(self._cpp_obj)
        )
        return Map__i16_List__float.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[int16_t,vector[float]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[int16_t,vector[float]]] c_inst = make_shared[cmap[int16_t,vector[float]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int16_t> key
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence[float]")
                if not isinstance(item, List__float):
                    item = List__float(item)

                deref(c_inst)[key] = deref((<List__float>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err from None
        cdef cmap[int16_t,vector[float]].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[vector[float]] citem = reference_shared_ptr_Map__i16_List__float(self._cpp_obj, deref(iter).second)
        return List__float.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int16_t citem
        cdef cmap[int16_t,vector[float]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield citem
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int16_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[vector[float]] citem
        cdef cmap[int16_t,vector[float]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__i16_List__float(self._cpp_obj, deref(loc).second)
            yield List__float.create(citem)
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef int16_t ckey
        cdef shared_ptr[vector[float]] citem
        cdef cmap[int16_t,vector[float]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__i16_List__float(self._cpp_obj, deref(loc).second)
            yield (ckey, List__float.create(citem))
            inc(loc)



Mapping.register(Map__i16_List__float)

cdef class Map__i32_List__float:
    def __init__(self, items=None):
        if isinstance(items, Map__i32_List__float):
            self._cpp_obj = (<Map__i32_List__float> items)._cpp_obj
        else:
            self._cpp_obj = Map__i32_List__float._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[int32_t,vector[float]]] c_items):
        inst = <Map__i32_List__float>Map__i32_List__float.__new__(Map__i32_List__float)
        inst._cpp_obj = move_shared(c_items)
        return inst

    def __copy__(Map__i32_List__float self):
        cdef shared_ptr[cmap[int32_t,vector[float]]] cpp_obj = make_shared[cmap[int32_t,vector[float]]](
            deref(self._cpp_obj)
        )
        return Map__i32_List__float.create(move_shared(cpp_obj))

    @staticmethod
    cdef shared_ptr[cmap[int32_t,vector[float]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[int32_t,vector[float]]] c_inst = make_shared[cmap[int32_t,vector[float]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <int32_t> key
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence[float]")
                if not isinstance(item, List__float):
                    item = List__float(item)

                deref(c_inst)[key] = deref((<List__float>item)._cpp_obj)
        return c_inst

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        if not self or key is None:
            raise err
        if not isinstance(key, int):
            raise err from None
        cdef cmap[int32_t,vector[float]].iterator iter = deref(
            self._cpp_obj).find(key)
        if iter == deref(self._cpp_obj).end():
            raise err
        cdef shared_ptr[vector[float]] citem = reference_shared_ptr_Map__i32_List__float(self._cpp_obj, deref(iter).second)
        return List__float.create(citem)

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef cmap[int32_t,vector[float]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = deref(loc).first
            yield citem
            inc(loc)

    def __eq__(self, other):
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return False
        if len(self) != len(other):
            return False

        for key in self:
            if key not in other:
                return False
            if other[key] != self[key]:
                return False

        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'

    def __contains__(self, key):
        if not self or key is None:
            return False
        if not isinstance(key, int):
            return False
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self or key is None:
            return default
        if not isinstance(key, int):
            return default
        if key not in self:
            return default
        return self[key]

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef shared_ptr[vector[float]] citem
        cdef cmap[int32_t,vector[float]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            citem = reference_shared_ptr_Map__i32_List__float(self._cpp_obj, deref(loc).second)
            yield List__float.create(citem)
            inc(loc)

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef shared_ptr[vector[float]] citem
        cdef cmap[int32_t,vector[float]].iterator loc = deref(self._cpp_obj).begin()
        while loc != deref(self._cpp_obj).end():
            ckey = deref(loc).first
            citem = reference_shared_ptr_Map__i32_List__float(self._cpp_obj, deref(loc).second)
            yield (ckey, List__float.create(citem))
            inc(loc)



Mapping.register(Map__i32_List__float)

FloatFeatures = Map__i16_float
DoubleMapType = Map__i64_double
OldMapMap = Map__i16_Map__i64_double
NewMapMap = Map__i32_Map__i64_double
OldMapList = Map__i16_List__float
NewMapList = Map__i32_List__float
