/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>



// BEGIN declare_enums

// END declare_enums
// BEGIN struct_indirection

// END struct_indirection
// BEGIN forward_declare
namespace cpp2 {
class OldStructure;
class NewStructure;
class NewStructure2;
class NewStructureNested;
class NewStructureNestedField;
} // cpp2
// END forward_declare
// BEGIN typedefs
namespace cpp2 {
typedef ::std::map<int16_t, float> FloatFeatures;
typedef ::std::map<int64_t, double> DoubleMapType;
typedef ::std::map<int16_t,  ::cpp2::DoubleMapType> OldMapMap;
typedef ::std::map<int32_t,  ::cpp2::DoubleMapType> NewMapMap;
typedef ::std::map<int16_t, ::std::vector<float>> OldMapList;
typedef ::std::map<int32_t, ::std::vector<float>> NewMapList;

} // cpp2
// END typedefs
// BEGIN hash_and_equal_to
// END hash_and_equal_to
namespace cpp2 {
class OldStructure final : private apache::thrift::detail::st::ComparisonOperators<OldStructure> {
 public:

  OldStructure() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  OldStructure(apache::thrift::FragileConstructor, ::std::map<int16_t, double> features__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    features = arg.extract();
    __isset.features = true;
  }

  OldStructure(OldStructure&&) = default;

  OldStructure(const OldStructure&) = default;

  OldStructure& operator=(OldStructure&&) = default;

  OldStructure& operator=(const OldStructure&) = default;
  void __clear();
  ::std::map<int16_t, double> features;

  struct __isset {
    bool features;
  } __isset = {};
  bool operator==(const OldStructure& rhs) const;
  bool operator<(const OldStructure& rhs) const;
  const ::std::map<int16_t, double>& get_features() const&;
  ::std::map<int16_t, double> get_features() &&;

  template <typename T_OldStructure_features_struct_setter = ::std::map<int16_t, double>>
  ::std::map<int16_t, double>& set_features(T_OldStructure_features_struct_setter&& features_) {
    features = std::forward<T_OldStructure_features_struct_setter>(features_);
    __isset.features = true;
    return features;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< OldStructure >;
};

void swap(OldStructure& a, OldStructure& b);

template <class Protocol_>
uint32_t OldStructure::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
class NewStructure final : private apache::thrift::detail::st::ComparisonOperators<NewStructure> {
 public:

  NewStructure() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  NewStructure(apache::thrift::FragileConstructor, ::std::map<int16_t, double> features__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    features = arg.extract();
    __isset.features = true;
  }

  NewStructure(NewStructure&&) = default;

  NewStructure(const NewStructure&) = default;

  NewStructure& operator=(NewStructure&&) = default;

  NewStructure& operator=(const NewStructure&) = default;
  void __clear();
  ::std::map<int16_t, double> features;

  struct __isset {
    bool features;
  } __isset = {};
  bool operator==(const NewStructure& rhs) const;
  bool operator<(const NewStructure& rhs) const;
  const ::std::map<int16_t, double>& get_features() const&;
  ::std::map<int16_t, double> get_features() &&;

  template <typename T_NewStructure_features_struct_setter = ::std::map<int16_t, double>>
  ::std::map<int16_t, double>& set_features(T_NewStructure_features_struct_setter&& features_) {
    features = std::forward<T_NewStructure_features_struct_setter>(features_);
    __isset.features = true;
    return features;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< NewStructure >;
};

void swap(NewStructure& a, NewStructure& b);

template <class Protocol_>
uint32_t NewStructure::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
class NewStructure2 final : private apache::thrift::detail::st::ComparisonOperators<NewStructure2> {
 public:

  NewStructure2() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  NewStructure2(apache::thrift::FragileConstructor,  ::cpp2::FloatFeatures features__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    features = arg.extract();
    __isset.features = true;
  }

  NewStructure2(NewStructure2&&) = default;

  NewStructure2(const NewStructure2&) = default;

  NewStructure2& operator=(NewStructure2&&) = default;

  NewStructure2& operator=(const NewStructure2&) = default;
  void __clear();
   ::cpp2::FloatFeatures features;

  struct __isset {
    bool features;
  } __isset = {};
  bool operator==(const NewStructure2& rhs) const;
  bool operator<(const NewStructure2& rhs) const;
  const  ::cpp2::FloatFeatures& get_features() const&;
   ::cpp2::FloatFeatures get_features() &&;

  template <typename T_NewStructure2_features_struct_setter =  ::cpp2::FloatFeatures>
   ::cpp2::FloatFeatures& set_features(T_NewStructure2_features_struct_setter&& features_) {
    features = std::forward<T_NewStructure2_features_struct_setter>(features_);
    __isset.features = true;
    return features;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< NewStructure2 >;
};

void swap(NewStructure2& a, NewStructure2& b);

template <class Protocol_>
uint32_t NewStructure2::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
class NewStructureNested final : private apache::thrift::detail::st::ComparisonOperators<NewStructureNested> {
 public:

  NewStructureNested() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  NewStructureNested(apache::thrift::FragileConstructor, ::std::vector< ::cpp2::FloatFeatures> lst__arg, ::std::map<int16_t,  ::cpp2::FloatFeatures> mp__arg, ::std::set< ::cpp2::FloatFeatures> s__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    lst = arg.extract();
    __isset.lst = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<2, _T> arg) {
    mp = arg.extract();
    __isset.mp = true;
  }
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<3, _T> arg) {
    s = arg.extract();
    __isset.s = true;
  }

  NewStructureNested(NewStructureNested&&) = default;

  NewStructureNested(const NewStructureNested&) = default;

  NewStructureNested& operator=(NewStructureNested&&) = default;

  NewStructureNested& operator=(const NewStructureNested&) = default;
  void __clear();
  ::std::vector< ::cpp2::FloatFeatures> lst;
  ::std::map<int16_t,  ::cpp2::FloatFeatures> mp;
  ::std::set< ::cpp2::FloatFeatures> s;

  struct __isset {
    bool lst;
    bool mp;
    bool s;
  } __isset = {};
  bool operator==(const NewStructureNested& rhs) const;
  bool operator<(const NewStructureNested& rhs) const;
  const ::std::vector< ::cpp2::FloatFeatures>& get_lst() const&;
  ::std::vector< ::cpp2::FloatFeatures> get_lst() &&;

  template <typename T_NewStructureNested_lst_struct_setter = ::std::vector< ::cpp2::FloatFeatures>>
  ::std::vector< ::cpp2::FloatFeatures>& set_lst(T_NewStructureNested_lst_struct_setter&& lst_) {
    lst = std::forward<T_NewStructureNested_lst_struct_setter>(lst_);
    __isset.lst = true;
    return lst;
  }
  const ::std::map<int16_t,  ::cpp2::FloatFeatures>& get_mp() const&;
  ::std::map<int16_t,  ::cpp2::FloatFeatures> get_mp() &&;

  template <typename T_NewStructureNested_mp_struct_setter = ::std::map<int16_t,  ::cpp2::FloatFeatures>>
  ::std::map<int16_t,  ::cpp2::FloatFeatures>& set_mp(T_NewStructureNested_mp_struct_setter&& mp_) {
    mp = std::forward<T_NewStructureNested_mp_struct_setter>(mp_);
    __isset.mp = true;
    return mp;
  }
  const ::std::set< ::cpp2::FloatFeatures>& get_s() const&;
  ::std::set< ::cpp2::FloatFeatures> get_s() &&;

  template <typename T_NewStructureNested_s_struct_setter = ::std::set< ::cpp2::FloatFeatures>>
  ::std::set< ::cpp2::FloatFeatures>& set_s(T_NewStructureNested_s_struct_setter&& s_) {
    s = std::forward<T_NewStructureNested_s_struct_setter>(s_);
    __isset.s = true;
    return s;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< NewStructureNested >;
};

void swap(NewStructureNested& a, NewStructureNested& b);

template <class Protocol_>
uint32_t NewStructureNested::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
class NewStructureNestedField final : private apache::thrift::detail::st::ComparisonOperators<NewStructureNestedField> {
 public:

  NewStructureNestedField() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  NewStructureNestedField(apache::thrift::FragileConstructor,  ::cpp2::NewStructureNested f__arg);
  template <typename _T>
  void __set_field(::apache::thrift::detail::argument_wrapper<1, _T> arg) {
    f = arg.extract();
    __isset.f = true;
  }

  NewStructureNestedField(NewStructureNestedField&&) = default;

  NewStructureNestedField(const NewStructureNestedField&) = default;

  NewStructureNestedField& operator=(NewStructureNestedField&&) = default;

  NewStructureNestedField& operator=(const NewStructureNestedField&) = default;
  void __clear();
   ::cpp2::NewStructureNested f;

  struct __isset {
    bool f;
  } __isset = {};
  bool operator==(const NewStructureNestedField& rhs) const;
  bool operator<(const NewStructureNestedField& rhs) const;
  const  ::cpp2::NewStructureNested& get_f() const&;
   ::cpp2::NewStructureNested get_f() &&;

  template <typename T_NewStructureNestedField_f_struct_setter =  ::cpp2::NewStructureNested>
   ::cpp2::NewStructureNested& set_f(T_NewStructureNestedField_f_struct_setter&& f_) {
    f = std::forward<T_NewStructureNestedField_f_struct_setter>(f_);
    __isset.f = true;
    return f;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< NewStructureNestedField >;
};

void swap(NewStructureNestedField& a, NewStructureNestedField& b);

template <class Protocol_>
uint32_t NewStructureNestedField::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
