#! /usr/bin/env python3
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from __future__ import print_function
from itertools import chain
from collections import namedtuple
import copy
import errno
import os
import re
import string

from thrift_compiler import frontend
# Easy access to the enum of t_base_type::t_base
from thrift_compiler.frontend import t_base
# Easy access to the enum of t_field::e_req
from thrift_compiler.frontend import e_req
# Easy access to the enum of t_const_value::t_const_value_type
from thrift_compiler.frontend import e_const_value_type as e_cv_type

from thrift_compiler.generate import t_generator

from thrift_compiler.generate.t_cpp_context import (
    CppOutputContext,
    CppPrimitiveFactory,
)
from thrift_compiler.generate.t_output_aggregator import get_global_scope
from thrift_compiler.generate.t_output_aggregator import out
from thrift_compiler.generate.t_output import IndentedOutput

# Same as map.get, but works for almost-dictionary-like types
# (like the ones generated by boost.python)
def _map_get(map, key, default=None):
    return map[key] if key in map else default


def _cpp_name(field):
    annotations = field.annotations
    return annotations['cpp.name'] if 'cpp.name' in annotations else field.name

# ---------------------------------------------------------------
# Generator
# ---------------------------------------------------------------

class CompilerError(RuntimeError):
    pass

class CppGenerator(t_generator.Generator):
    '''
    Plain ol' c++ generator
    Note: this is NOT legitimacy incarnate
    '''

    short_name = 'cpp2'
    long_name = 'C++ version 2'
    supported_flags = {
        'include_prefix': 'Use full include paths in generated files.',
    }
    _out_dir_base = 'gen-cpp2'

    _base_to_cpp_typename = {
        t_base.void: 'void',
        t_base.string: 'std::string',
        t_base.bool: 'bool',
        t_base.byte: 'int8_t',
        t_base.i16: 'int16_t',
        t_base.i32: 'int32_t',
        t_base.i64: 'int64_t',
        t_base.double: 'double',
        t_base.float: 'float',
    }

    def __init__(self, *args, **kwargs):
        # super constructor
        t_generator.Generator.__init__(self, *args, **kwargs)

        prefix = self._flags.get('include_prefix')
        if isinstance(prefix, (str, bytes)):
            self.program.include_prefix = prefix

    def _base_type_name(self, tbase):
        if tbase in self._base_to_cpp_typename:
            return self._base_to_cpp_typename[tbase]
        raise CompilerError('no C++ base type name for base type ' + tbase)

    def _cpp_annotation(self, type, key, default=None):
        t = _map_get(type.annotations, 'cpp2.' + key)
        if t:
            return t
        t = _map_get(type.annotations, 'cpp.' + key)
        if t:
            return t
        return default

    def _cpp_type_name(self, type, default=None):
        return self._cpp_annotation(type, 'type', default)

    def _type_name(self, ttype, in_typedef=False, scope=None):
        if ttype.is_base_type:
            # cast it
            btype = ttype.as_base_type
            bname = self._base_type_name(btype.base)
            return self._cpp_type_name(ttype, bname)
        # Check for a custom overloaded C++ name
        if ttype.is_container:
            tcontainer = ttype.as_container
            inner_types = None
            template = self._cpp_annotation(tcontainer, 'template')
            cname = self._cpp_type_name(tcontainer)
            if cname:
                pass
            elif ttype.is_map:
                tmap = ttype.as_map
                if template:
                    cname = template
                elif tmap.is_unordered:
                    cname = 'std::unordered_map'
                else:
                    cname = 'std::map'
                inner_types = [self._type_name(tmap.key_type, in_typedef,
                                               scope=scope),
                               self._type_name(tmap.value_type, in_typedef,
                                               scope=scope)]
                cname = cname + '<{0}, {1}>'
            elif ttype.is_set:
                tset = ttype.as_set
                if template:
                    cname = template
                elif tset.is_unordered:
                    cname = 'std::unordered_set'
                else:
                    cname = 'std::set'
                inner_types = [self._type_name(tset.elem_type, in_typedef,
                                               scope=scope)]
                cname = cname + "<{0}>"
            elif ttype.is_list:
                cname = 'std::vector'
                if template:
                    cname = template
                tlist = ttype.as_list
                inner_types = [self._type_name(tlist.elem_type, in_typedef,
                                               scope=scope)]
                cname = cname + "<{0}>"
            if inner_types:
                cname = cname.format(*inner_types)
            return cname

        if in_typedef and (ttype.is_struct or ttype.is_xception) and \
                ttype.program == self._program:
            scope('class ' + ttype.name + ';')

        tname = self._cpp_type_name(ttype)
        if not tname:
            # Check if it needs to be namespaced
            program = ttype.program
            if program is not None:
                tname = self._namespace_prefix(self._get_namespace(program)) + \
                        ttype.name
            else:
                tname = ttype.name

        return tname

    def _get_namespace(self, program=None):
        if program == None:
            program = self._program
        ns = program.get_namespace('cpp2')
        if ns:
            return ns
        ns = program.get_namespace('cpp')
        parts = [_f for _f in ns.split('.') if _f]
        parts.append('cpp2')
        return '.'.join(parts)

    def _namespace_prefix(self, ns):
        'Return the absolute c++ prefix for the .-separated namespace param'
        prefix = ' ::' + '::'.join(ns.split('.'))
        if len(ns) > 0:
            prefix += '::'
        return prefix

    def _type_access_suffix(self, ttype):
        if not ttype.is_typedef:
            return ''
        return self._cpp_annotation(ttype.as_typedef.type, 'indirection', '')


    # ==========================================================================
    # FATAL REFLECTION CODE - begin
    # ==========================================================================

    def _generate_fatal(self, program):
        name = self._program.name
        ns = self._get_original_namespace()
        self.fatal_detail_ns = 'thrift_fatal_impl_detail'
        with self._make_context(name + '_fatal') as context, \
                get_global_scope(CppPrimitiveFactory, context) as sg:
            sg('#include <thrift/lib/cpp2/reflection/reflection.h>')
            sg()
            sg('#include <fatal/type/list.h>')
            sg('#include <fatal/type/pair.h>')
            sg('#include <fatal/type/sequence.h>')
            sg()
            sg('#include "{0}"'.format(self._with_include_prefix(
                self._program, name + '_types.h')))

            if len(ns) > 0:
                with sg.namespace(ns).scope as sns:
                    self._generate_fatal_impl(sns, program)
            else:
                self._generate_fatal_impl(sg, program)
            sg('#include "{0}_fatal_types.h"'.format(
                self._with_include_prefix(self._program, name)))

    def _generate_fatal_impl(self, sns, program):
        name = self._program.name
        self.fatal_tags_class = '{0}_tags'.format(name)
        self.fatal_tag = '{0}::module'.format(self.fatal_tags_class)
        safe_ns = self._get_namespace().replace('.', '_')

        str_class = '{0}_{1}__unique_strings_list'.format(safe_ns, name)
        self.fatal_str_map_id = '{0}::{1}'.format(
            self.fatal_detail_ns, str_class)
        self.fatal_str_map = {}
        self.fatal_str_uid = []
        self._fatal_type_dependencies = None

        name_id = self._set_fatal_string(name)

        order = ['language', 'enum', 'union', 'struct', 'constant', 'service']
        items = {}
        items['language'] = self._generate_fatal_language(program)
        items['enum'] = self._generate_fatal_enum(program)
        items['union'] = self._generate_fatal_union(program)
        items['struct'] = self._generate_fatal_struct(program)
        items['constant'] = self._generate_fatal_constant(program)
        items['service'] = self._generate_fatal_service(program)

        # Combo include: types
        with self._make_context(name + '_fatal_types') as context_cmb_types, \
                get_global_scope(CppPrimitiveFactory, context_cmb_types) as sg:
            for dep in self._program.includes:
                sg('#include  "{0}_fatal_types.h"'
                   .format(self._with_include_prefix(dep, dep.name)))
            sg()
            for what in ['enum', 'union', 'struct']:
                sg('#include "{0}"'.format(self._with_include_prefix(
                    self._program, name + '_fatal_' + what + '.h')))

        # Combo include: all
        with self._make_context(name + '_fatal_all') as context_cmb_all, \
                get_global_scope(CppPrimitiveFactory, context_cmb_all) as sg:
            for dep in self._program.includes:
                sg('#include  "{0}_fatal_all.h"'
                   .format(self._with_include_prefix(dep, dep.name)))
            sg()
            sg('#include "{0}_types.h"'.format(
                self._with_include_prefix(self._program, name)))
            sg()
            for what in ['types', 'constant', 'service']:
                sg('#include "{0}"'.format(self._with_include_prefix(
                    self._program, name + '_fatal_' + what + '.h')))

        # Unique Compile-time Strings
        with sns.namespace(self.fatal_detail_ns).scope as detail:
            with detail.cls('struct {0}'.format(str_class)).scope as cstr:
                for i in sorted(self.fatal_str_map):
                    cstr('using {0} = {1};'.format(
                        self.fatal_str_map[i],
                        self._render_fatal_string(i)))

        # Metadata tags
        sns('class {0}_tags {1}'.format(name, '{')).scope
        nname = {}
        for o in order:
            nname[o] = '{0}_{1}__unique_{2}s_list'.format(safe_ns, name, o)
            eorder = items[o][0]
            entries = items[o][1]
            sns('  struct {0} {1}'.format(nname[o], '{'))
            for i in eorder:
                if type(entries) == list:
                    sns('    using {0} = {1};'.format(
                        self._get_fatal_string_short_id(i[0]), i[1]))
                elif type(entries) == dict:
                    sns('    using {0} = {1};'.format(
                        self._get_fatal_string_short_id(entries[i][0]),
                        entries[i][1]))
            sns('  };')
            sns()
        sns('public:')
        sns('  struct module {0}'.format('{};'))
        sns()
        for o in order:
            sns('  using {0}s = {1};'.format(o, nname[o]))
        sns()
        sns('  using strings = {0};'.format(self.fatal_str_map_id))
        sns('};')
        sns()

        # Metadata registration
        sns('THRIFT_REGISTER_REFLECTION_METADATA(')
        sns('  {0},'.format(self.fatal_tag))
        sns('  {0},'.format(name_id))
        for item_idx, o in enumerate(order):
            eorder = items[o][0]
            entries = items[o][1]
            sns('  // {0}s'.format(o))
            sns('  ::fatal::list<')
            for idx, i in enumerate(eorder):
                if type(entries) == list:
                    sns('    {0}{1}'.format(
                        i[2], ',' if idx + 1 < len(entries) else ''))
                elif type(entries) == dict:
                    sns('    ::fatal::pair<{0}, {1}>{2}'
                        .format(i, entries[i][2],
                                ',' if idx + 1 < len(entries) else ''))
            sns('  >{0}'.format(',' if item_idx + 1 < len(items) else ''))
        sns(');')

    def _get_fatal_string_short_id(self, s):
        return self.fatal_str_map[s]

    def _get_fatal_string_id(self, s):
        return '{0}::{1}'.format(
            self.fatal_str_map_id, self._get_fatal_string_short_id(s))

    def _set_fatal_string(self, s):
        if s not in self.fatal_str_map:
            identifier = s
            if len(identifier) == 0:
                identifier = "empty"
            else:
                if identifier[0] not in string.ascii_letters + '_':
                    identifier = "s_" + identifier
                identifier = re.sub(r'[\W\.:]', '_', s)

            uid = identifier
            uid_round = 0
            while uid in self.fatal_str_uid:
                uid = "{0}_{1}".format(identifier, uid_round)
                uid_round = uid_round + 1
            self.fatal_str_uid.append(uid)
            self.fatal_str_map[s] = uid
        return self._get_fatal_string_id(s)

    def _get_original_namespace(self):
        return self._get_namespace()

    def _get_scoped_original_namespace(self):
        ns = self._get_original_namespace()
        if len(ns) > 0:
            return '::{0}'.format(ns.replace('.', '::'))
        return ''

    def _render_fatal_string(self, s):
        result = "::fatal::sequence<char"
        substitutions = {
            '\0': '\\0',
            '\n': '\\n',
            '\r': '\\r',
            '\t': '\\t',
            '\'': '\\\'',
            '\\': '\\\\',
        }
        for i in s:
            result += ", '{0}'".format(substitutions.get(i, i))
        result += ">"
        return result

    def _render_fatal_type_class(self, ttype):
        while ttype.is_typedef:
            ttype = ttype.type

        if ttype.is_void:
            return '::apache::thrift::type_class::nothing'
        elif ttype.is_binary:
            return '::apache::thrift::type_class::binary'
        elif ttype.is_string:
            return '::apache::thrift::type_class::string'
        elif ttype.is_floating_point:
            return '::apache::thrift::type_class::floating_point'
        elif ttype.is_base_type:
            return '::apache::thrift::type_class::integral'
        elif ttype.is_enum:
            return '::apache::thrift::type_class::enumeration'
        elif ttype.is_list:
            return '::apache::thrift::type_class::list<{0}>'.format(
                self._render_fatal_type_class(ttype.as_list.elem_type))
        elif ttype.is_map:
            return '::apache::thrift::type_class::map<{0}, {1}>'.format(
                self._render_fatal_type_class(ttype.as_map.key_type),
                self._render_fatal_type_class(ttype.as_map.value_type))
        elif ttype.is_set:
            return '::apache::thrift::type_class::set<{0}>'.format(
                self._render_fatal_type_class(ttype.as_set.elem_type))
        elif ttype.is_struct:
            if ttype.as_struct.is_union:
                return '::apache::thrift::type_class::variant'
            else:
                return '::apache::thrift::type_class::structure'

        return '::apache::thrift::type_class::unknown'

    def _render_fatal_required_qualifier(self, required):
        if required == e_req.required:
            return 'required'
        elif required == e_req.optional:
            return 'optional'
        else:
            assert required == e_req.opt_in_req_out, \
                "unknown required qualifier"
            return 'required_of_writer'

    def _render_fatal_structured_annotation(self, what, out, indent, comma):
        t = type(what)
        comma = ',' if comma else ''

        if t == bool:
            out('{0}::std::{1}_type{2}'.format(
                indent, 'true' if what else 'false', comma))
        elif t == int:
            out('{0}::std::integral_constant< ::std::{1}max_t, {2}>{3}'.format(
                indent, 'int' if what < 0 else 'uint', what, comma))
        elif t == list or t == set:
            out('{0}::fatal::list<'.format(indent))
            for i, k in enumerate(what):
                self._render_fatal_structured_annotation(k, out, indent + '  ',
                                                         i + 1 < len(what))
            out('{0}>{1}'.format(indent, comma))
        elif t == dict:
            out('{0}::fatal::list<'.format(indent))
            for i, (k, v) in enumerate(sorted(what.items())):
                out('{0}  ::fatal::pair<'.format(indent))
                self._render_fatal_structured_annotation(k, out,
                                                         indent + '    ', True)
                self._render_fatal_structured_annotation(v, out,
                                                         indent + '    ', False)
                out('{0}  >{1}'.format(indent,
                                       ',' if i + 1 < len(what) else ''))
            out('{0}>{1}'.format(indent, comma))
        else:  # treat as string
            out('{0}{1}{2}'.format(indent, self._render_fatal_string(str(what)),
                comma))

    def _render_fatal_annotations(self, annotations, class_name, scope):
        clsnmkeys = '{0}__unique_annotations_keys'.format(class_name)
        clsnmvalues = '{0}__unique_annotations_values'.format(class_name)
        annotation_keys = []
        black_list = [
            'cpp.methods',
            'cpp.name',
            'cpp.ref',
            'cpp.ref_type',
            'cpp.template',
            'cpp.type',
            'cpp2.methods',
            'cpp2.ref',
            'cpp2.ref_type',
            'cpp2.template',
            'cpp2.type',
        ]
        if annotations is not None:
            for i in sorted(annotations.keys()):
                if i not in black_list:
                    annotation_keys.append(i)
        with scope.cls('class {0}'.format(class_name)).scope as aclass:
            if len(annotation_keys) > 0:
                with scope.cls('struct {0}'.format(clsnmkeys)).scope as akeys:
                    for i in annotation_keys:
                        full_id = self._set_fatal_string(i)
                        short_id = self._get_fatal_string_short_id(i)
                        akeys('using {0} = {1};'.format(short_id, full_id))
                with scope.cls('struct {0}'.format(clsnmvalues)).scope as aval:
                    for i in annotation_keys:
                        aval('using {0} = {1};'.format(
                            self._get_fatal_string_short_id(i),
                            self._render_fatal_string(annotations[i])))
                aclass()
            aclass('public:')
            if len(annotation_keys) > 0:
                aclass('using keys = {0};'.format(clsnmkeys))
                aclass('using values = {0};'.format(clsnmvalues))
            else:
                aclass('using keys = void;')
                aclass('using values = void;')
            aclass('using map = ::fatal::list<')
            import json
            for idx, i in enumerate(annotation_keys):
                structured = None
                try:
                    structured = json.loads(annotations[i])
                except ValueError:
                    pass

                identifier = self._get_fatal_string_short_id(i)
                aclass('  ::apache::thrift::annotation<')
                aclass('    keys::{0},'.format(identifier))
                aclass('    values::{0}{1}'
                       .format(identifier, '' if structured is None else ','))
                if structured is not None:
                    self._render_fatal_structured_annotation(
                        structured, aclass, '    ', False)
                aclass('  >{0}'
                       .format(',' if idx + 1 < len(annotation_keys) else ''))
            aclass('>;')
        return class_name

    def _render_fatal_type_common_metadata(self, annotations_class, legacyid,
                                           scope, indent, ns_prefix=''):
        scope('{0}::apache::thrift::detail::type_common_metadata_impl<'.format(
            indent))
        scope('{0}  {1}{2},'.format(indent, ns_prefix, self.fatal_tag))
        scope('{0}  ::apache::thrift::reflected_annotations<{1}>,'
            .format(indent, annotations_class))
        scope('{0}  static_cast<::apache::thrift::legacy_type_id_t>({1}ull)'
            .format(indent, legacyid))
        scope('{0}>'.format(indent))

    def _generate_fatal_language(self, program):
        replacement = {'cpp': '::', 'cpp2': '::', 'php': '_'}
        order = []
        result = {}
        for i in program.namespaces:
            language = i.key()
            ns = self._program.get_namespace(language)
            if language in replacement:
                ns = ns.replace('.', replacement[language])
            lang_id = self._set_fatal_string(language)
            result[lang_id] = (language, lang_id, self._set_fatal_string(ns))
            order.append(lang_id)
        return (order, result)

    def _generate_fatal_enum(self, program):
        name = self._program.name
        ns = self._get_original_namespace()

        with self._make_context(name + '_fatal_enum') as context, \
                get_global_scope(CppPrimitiveFactory, context) as sg:
            sg('#include "{0}"'.format(self._with_include_prefix(
                self._program, name + '_types.h')))

            sg('#include "{0}"'.format(self._fatal_header()))

            sg()
            sg('#include <fatal/type/enum.h>')
            sg()
            sg('#include <type_traits>')
            sg()
            if len(ns) > 0:
                with sg.namespace(ns).scope as sns:
                    return self._generate_fatal_enum_impl(sns, program)
            else:
                return self._generate_fatal_enum_impl(sg, program)

    def _generate_fatal_enum_impl(self, sns, program):
        result = {}
        order = []
        for i in program.enums:
            self._generate_fatal_enum_traits(i.name, i.name, i.enum_values, sns,
                i.annotations, i.type_id)
            string_ref = self._set_fatal_string(i.name)
            result[i.name] = (i.name, string_ref, string_ref)
            order.append(i.name)
        return (order, result)

    def _generate_fatal_enum_traits(self, name, scoped_name, members, scope,
      annotations, legacyid, guaranteed_unique=False):
        scoped_ns = self._get_scoped_original_namespace()
        traits_name = '{0}_enum_traits'.format(scoped_name.replace('::', '_'))
        with scope.namespace(self.fatal_detail_ns).scope as detail:
            with detail.cls('struct {0}'.format(traits_name)).scope as t:
                t('using type = {0}::{1};'.format(scoped_ns, scoped_name))
                t('using name = {0};'.format(self._set_fatal_string(name)))
                t()
                strcls = '{0}__struct_unique_strings_list'.format(name)
                with t.cls('struct {0}'.format(strcls)):
                    for i in members:
                        cpp_name = _cpp_name(i)
                        cseq = self._set_fatal_string(cpp_name)
                        t('using {0} = {1};'.format(cpp_name, cseq))
                t()
                mbmclsprefix = '{0}__struct_enum_members_'.format(name)
                for i in members:
                    cpp_name = _cpp_name(i)
                    with t.cls('struct {0}{1}'.format(mbmclsprefix, cpp_name)):
                        t('using name = {0}::{1};'.format(strcls, cpp_name))
                        t(('using value = std::integral_constant<type'
                            ', type::{0}>;').format(cpp_name))
                        self._render_fatal_annotations(
                            i.annotations, 'annotations', t)
                t()
                mbmcls = '{0}__struct_enum_members'.format(name)
                with t.cls('struct {0}'.format(mbmcls)):
                    for i in members:
                        t('using {0} = {1}{0};'.format(_cpp_name(i), mbmclsprefix))
                t()
                t('using member = {0};'.format(mbmcls))
                t()
                t('using fields = ::fatal::list<')
                for idx, i in enumerate(members):
                    t('    member::{0}{1}'
                        .format(_cpp_name(i), ',' if idx + 1 < len(members) else ''))
                t('>;')
                t()
                self._render_fatal_annotations(annotations, 'annotations', t)
                t()
                t('static char const *to_string(type e, char const *fallback)'
                    + ' {0}'.format('{'))
                t('  switch (e) {')
                member_names = []
                member_values = []
                for i in members:
                    if guaranteed_unique or i.value not in member_values:
                        member_names.append(_cpp_name(i))
                        member_values.append(i.value)
                for i in member_names:
                    t('    case type::{0}: return "{0}";'.format(i))
                t('    default: return fallback;')
                t('  }')
                t('}')
        scope()
        scope('FATAL_REGISTER_ENUM_TRAITS(')
        scope('  {0}::{1}::{2},'.format(
            scoped_ns, self.fatal_detail_ns, traits_name))
        self._render_fatal_type_common_metadata(
            '{0}::{1}::{2}::annotations'.format(
                scoped_ns, self.fatal_detail_ns, traits_name),
            legacyid, scope, '  ')
        scope(');')
        return traits_name

    def _generate_fatal_union(self, program):
        name = self._program.name
        ns = self._get_original_namespace()

        with self._make_context(name + '_fatal_union') as context, \
                get_global_scope(CppPrimitiveFactory, context) as sg:
            for dep in self._program.includes:
                sg('#include  "{0}_fatal_types.h"'
                   .format(self._with_include_prefix(dep, dep.name)))
            sg()
            sg('#include "{0}"'.format(self._with_include_prefix(
                self._program, name + '_types.h')))

            sg('#include "{0}"'.format(self._fatal_header()))
            sg()
            sg('#include <fatal/type/enum.h>')
            sg('#include <fatal/type/variant_traits.h>')
            sg()
            sg('#include <type_traits>')
            sg()
            if len(ns) > 0:
                with sg.namespace(ns).scope as sns:
                    return self._generate_fatal_union_impl(sns, program)
            else:
                return self._generate_fatal_union_impl(sg, program)

    def _generate_fatal_union_impl(self, sns, program):
        scoped_ns = self._get_scoped_original_namespace()
        result = {}
        order = []
        data = {}
        for i in program.structs:
            if not i.is_union:
                continue
            self._generate_fatal_enum_traits(
                'Type', '{0}::Type'.format(i.name),
                i.members, sns, None, 0, True)
            sns()
            string_ref = self._set_fatal_string(i.name)
            result[i.name] = (i.name, string_ref, string_ref)
            order.append(i.name)
            data[i.name] = [None, i.type_id]
            with sns.namespace(self.fatal_detail_ns).scope as detail:
                data[i.name][0] = self._generate_fatal_union_traits(
                    i, detail, i.annotations)
        if len(data) > 0:
            sns()
        for i in order:
            traits_class = '{0}::{1}::{2}'.format(
                scoped_ns, self.fatal_detail_ns, data[i][0])
            sns('FATAL_REGISTER_VARIANT_TRAITS(')
            sns('  {0},'.format(traits_class))
            self._render_fatal_type_common_metadata(
                '{0}::annotations'.format(traits_class), data[i][1], sns, '  ')
            sns(');')
        return (order, result)

    def _generate_fatal_union_traits(self, union, scope, annotations):
        scoped_ns = self._get_scoped_original_namespace()
        name = '{0}_variant_traits'.format(union.name)
        type_name = '{0}::{1}'.format(scoped_ns, union.name)
        with scope.cls('class {0}'.format(name)).scope as t:
            idscls = '{0}__struct_unique_identifiers_list'.format(union.name)
            with t.cls('struct {0}'.format(idscls)):
                for i in union.members:
                    t(('using {0} = std::integral_constant<{1}::Type, {1}::Type'
                       '::{0}>;').format(i.name, type_name))
            t()
            getcls = '{0}__struct_unique_getters_list'.format(union.name)
            with t.cls('struct {0}'.format(getcls)):
                for i in union.members:
                    self._generate_fatal_union_traits_getter(union, i, t)
            t()
            setcls = '{0}__struct_unique_setters_list'.format(union.name)
            with t.cls('struct {0}'.format(setcls)):
                for i in union.members:
                    self._generate_fatal_union_traits_setter(union, i, t)
            t()
            t('public:')
            t('using type = {0};'.format(type_name))
            t('using name = {0};'.format(self._set_fatal_string(union.name)))
            t('using id = type::Type;')
            t('using ids = {0};'.format(idscls))
            t('using descriptors = ::fatal::list<')
            for idx, i in enumerate(union.members):
                t('  ::fatal::variant_member_descriptor<')
                t('    {0},'.format(self._type_name(i.type)))
                t('    {0}::{1},'.format(idscls, i.name))
                t('    {0}::{1},'.format(getcls, i.name))
                t('    {0}::{1},'.format(setcls, i.name))
                t('    ::apache::thrift::reflected_variant_member_metadata<')
                t('      {0},'.format(self._get_fatal_string_id(i.name)))
                t('      {0},'.format(i.key))
                t('      {0}'.format(self._render_fatal_type_class(i.type)))
                t('    >')
                t('  >{0}'.format(',' if idx + 1 < len(union.members) else ''))
            t('>;')
            t()
            self._render_fatal_annotations(annotations, 'annotations', t)
            t()
            t('static id get_id(type const &variant) {0}'.format('{'))
            t('  return variant.getType();')
            t('}')
            t()
            t('static bool empty(type const &variant) {0}'.format('{'))
            t('  return variant.getType() == id::__EMPTY__;')
            t('}')
            t()
            t('static void clear(type &variant) {0}'.format('{'))
            t('  return variant.__clear();')
            t('}')
        return name

    def _generate_fatal_union_traits_getter(self, union, field, scope):
        with scope.cls('struct {0}'.format(field.name)):
            scope('decltype(auto) operator ()({0} const &variant) const {{'
                .format(union.name))
            scope('  return variant.get_{0}();'.format(field.name))
            scope('}')
            scope('decltype(auto) operator ()({0} &variant) const {{'
                .format(union.name))
            scope('  return variant.mutable_{0}();'.format(field.name))
            scope('}')
            scope('decltype(auto) operator ()({0} &&variant) const {{'
                .format(union.name))
            scope('  return std::move(variant).move_{0}();'.format(field.name))
            scope('}')

    def _generate_fatal_union_traits_setter(self, union, field, scope):
        with scope.cls('struct {0}'.format(field.name)):
            scope('template <typename... Args>')
            scope('decltype(auto) operator ()({0} &variant, Args &&...args) const {{'
                .format(union.name))
            scope('  return variant.set_{0}(std::forward<Args>(args)...);'
                .format(field.name))
            scope('}')

    def _fatal_header(self):
        return "{0}_fatal.h".format(self._with_include_prefix(
            self._program, self._program.name))

    def _generate_fatal_struct(self, program):
        name = self._program.name
        ns = self._get_original_namespace()
        with self._make_context(name + '_fatal_struct') as context, \
                get_global_scope(CppPrimitiveFactory, context) as sg:
            for dep in self._program.includes:
                sg('#include  "{0}_fatal_types.h"'
                   .format(self._with_include_prefix(dep, dep.name)))
            sg()
            sg('#include "{0}"'.format(self._with_include_prefix(
                self._program, name + '_types.h')))
            sg()
            sg('#include "{0}"'.format(self._fatal_header()))
            sg()
            sg('#include <fatal/type/traits.h>')
            sg('#include <fatal/type/list.h>')
            sg()
            result = None
            if len(ns) > 0:
                with sg.namespace(ns).scope as sns:
                    result = self._generate_fatal_struct_impl(sns, program)
            else:
                result = self._generate_fatal_struct_impl(sg, program)
            return self._generate_fatal_typedef_impl(
                sg, program, result[0], result[1], result[2])

    def _generate_fatal_struct_impl(self, sns, program):
        name = self._program.name
        safe_ns = self._get_namespace().replace('.', '_')
        dtmclsprefix = '{0}_{1}__struct_unique_data_member_getters_list'.format(
            safe_ns, name)
        indclsprefix = '{0}_{1}__struct_unique_indirections_list'.format(
            safe_ns, name)
        mpdclsprefix = '{0}_{1}__struct_unique_member_pod_list'.format(
            safe_ns, name)
        annclsprefix = '{0}_{1}__struct_unique_annotations'.format(
            safe_ns, name)
        mnfclsprefix = '{0}_{1}__struct_unique_member_info_list'.format(
            safe_ns, name)

        structs = []
        for struct in program.structs:
            structs.append(struct)
        for exception in program.exceptions:
            structs.append(exception)

        aliases = []
        for i in program.typedefs:
            alias = i.type
            if alias.is_typedef and 'cpp.type' in alias.annotations:
                ttype = i.type
                while ttype.is_typedef:
                    ttype = ttype.type
                if not (ttype.is_struct or ttype.is_xception):
                    continue
                ns_prefix = self._namespace_prefix(
                    self._get_original_namespace())
                aliases.append((i, alias, ttype, ns_prefix))

        with sns.namespace(self.fatal_detail_ns).scope as detail:
            members = []
            for i in structs:
                if i.is_union:
                    continue
                self._set_fatal_string(i.name)
                for m in i.members:
                    cpp_name = _cpp_name(m)
                    self._set_fatal_string(cpp_name)
                    if cpp_name not in members:
                        members.append(cpp_name)
            with detail.cls('struct {0}'.format(dtmclsprefix)).scope as dtm:
                for i in members:
                    dtm('FATAL_DATA_MEMBER_GETTER({0}, {0});'.format(i))
            for i in structs:
                if i.is_union:
                    continue
                if any(self._type_access_suffix(m.type) for m in i.members):
                    with detail.cls('struct {0}_{1}'.format(
                            i.name, indclsprefix)).scope as ind:
                        for m in i.members:
                            note = self._type_access_suffix(m.type)
                            if not note:
                                continue
                            with ind.cls('struct {0}'.format(
                                    m.name)).scope as ind:
                                out('template <typename T{0}>\n'
                                    'static auto val(T{0} &&{0}) {{\n'
                                    '  return std::forward<T{0}>({0}){1};\n'
                                    '}}'.format('__thrift__arg__', note))
                                out('template <typename T{0}>\n'
                                    'static auto &&ref(T{0} &&{0}) {{\n'
                                    '  return std::forward<T{0}>({0}){1};\n'
                                    '}}'.format('__thrift__arg__', note))
            with detail.cls('struct {0}'.format(mpdclsprefix)).scope as mpd:
                pod_arg = 'T_{0}_{1}_struct_member_pod'.format(safe_ns, name)
                for i in members:
                    mpd('template <typename {0}>'.format(pod_arg))
                    with detail.cls('struct {0}_{1}_struct_member_pod_{2}'
                      .format(safe_ns, name, i)).scope as pod:
                        pod('{0} {1};'.format(pod_arg, i))
            for i in structs:
                if i.is_union:
                    continue
                with detail.cls('class {0}_{1}'.format(
                        i.name, annclsprefix)).scope as cann:
                    members_class = '{0}_{1}_members'.format(
                        i.name, annclsprefix)
                    with cann.cls('class {0}'.format(
                            members_class)).scope as cmann:
                        for m in i.members:
                            self._render_fatal_annotations(
                                m.annotations, '{0}_{1}'.format(
                                    members_class, _cpp_name(m)), cmann)
                        cmann('public:')
                        for m in i.members:
                            cmann(('using {0} = ::apache::thrift::'
                                'reflected_annotations<{1}_{0}>;').format(
                                    _cpp_name(m), members_class))
                    self._render_fatal_annotations(i.annotations,
                        'annotations', cann)
                    cann('public:')
                    cann('using keys = annotations::keys;')
                    cann('using values = annotations::values;')
                    cann('using map = annotations::map;')
                    cann('using members = {0};'.format(members_class))
                with detail.cls(('struct {0}_{1}').format(
                        i.name, mnfclsprefix)).scope as cmnf:
                    for m in i.members:
                        cpp_name = _cpp_name(m)
                        cmnf(('using {0} = '
                            '::apache::thrift::reflected_struct_data_member<')
                            .format(cpp_name))
                        cmnf('')
                        cmnf('  {0},'.format(self._get_fatal_string_id(cpp_name)))
                        cmnf('  {0},'.format(self._type_name(m.type)))
                        cmnf('  {0},'.format(m.key))
                        cmnf('  ::apache::thrift::optionality::{0},'.format(
                            self._render_fatal_required_qualifier(m.req)))
                        if self._type_access_suffix(m.type):
                            cmnf('  ::apache::thrift::detail::'
                                 'chained_data_member_getter<')
                            cmnf('    {0}::{1}::{2},'.format(
                                self.fatal_detail_ns, dtmclsprefix, cpp_name))
                            cmnf('    ::apache::thrift::detail::'
                                 'reflection_indirection_getter<')
                            cmnf('      {0}::{1}_{2}::{3}'.format(
                                self.fatal_detail_ns,
                                i.name,
                                indclsprefix,
                                cpp_name))
                            cmnf('    >')
                            cmnf('  >,')
                        else:
                            cmnf('  {0}::{1}::{2},'.format(
                                self.fatal_detail_ns, dtmclsprefix, cpp_name))
                        cmnf('  {0},'.format(
                            self._render_fatal_type_class(m.type)))
                        cmnf('  {0}::{1}::{2}_{3}_struct_member_pod_{4},'
                            .format(self.fatal_detail_ns, mpdclsprefix,
                                safe_ns, name, cpp_name))
                        cmnf('  ::apache::thrift::reflected_annotations<'
                             '{0}::{1}_{2}::members::{3}>,'.format(
                                self.fatal_detail_ns, i.name, annclsprefix,
                                cpp_name))
                        # Owner
                        cmnf('  {0}'.format(i.name))
                        cmnf('>;')
            for i, _alias, ttype, _ns_prefix in aliases:
                self._set_fatal_string(i.symbolic)
                with detail.cls(('struct {0}_{1}').format(
                        i.symbolic, mnfclsprefix)).scope as cmnf:
                    for m in ttype.members:
                        cpp_name = _cpp_name(m)
                        cmnf(('using {0} = '
                              '::apache::thrift::reflected_struct_data_member<')
                              .format(cpp_name))
                        cmnf('')
                        cmnf('  {0},'.format(self._get_fatal_string_id(cpp_name)))
                        cmnf('  decltype(static_cast<{0} *>(nullptr)->{1}),'
                             .format(i.symbolic, cpp_name))
                        cmnf('  {0},'.format(m.key))
                        cmnf('  ::apache::thrift::optionality::required,')
                        cmnf('  {0}::{1}::{2},'.format(
                             self.fatal_detail_ns, dtmclsprefix, cpp_name))
                        cmnf('  {0},'.format(
                             self._render_fatal_type_class(m.type)))
                        cmnf('  {0}::{1}::{2}_{3}_struct_member_pod_{4},'
                             .format(self.fatal_detail_ns, mpdclsprefix,
                                     safe_ns, name, cpp_name))
                        cmnf('  ::apache::thrift::reflected_annotations<'
                             '{0}::{1}_{2}::members::{3}>,'
                             .format(self.fatal_detail_ns, ttype.name,
                                     annclsprefix, cpp_name))
                        # Owner
                        cmnf('  {0}'.format(i.symbolic))
                        cmnf('>;')

        def render_member_list(type_name, member_list):
            sns('  ::fatal::list<')
            for midx, m in enumerate(member_list):
                sns('      {0}::{1}_{2}::{3}{4}'.format(
                    self.fatal_detail_ns, type_name, mnfclsprefix, m.name,
                    ',' if midx + 1 < len(member_list) else ''))
            sns('  >,')

        result = {}
        order = []
        for i in structs:
            if i.is_union:
                continue
            string_ref = self._set_fatal_string(i.name)
            result[i.name] = (i.name, string_ref, string_ref)
            order.append(i.name)
            sns('THRIFT_REGISTER_STRUCT_TRAITS(')
            # Struct
            sns('  {0},'.format(i.name))
            # Name
            sns('  {0},'.format(self._get_fatal_string_id(i.name)))
            # MembersInfo
            sns('  {0}::{1}_{2},'.format(
                self.fatal_detail_ns, i.name, mnfclsprefix))
            # Info
            sns('  ::fatal::list<')
            annclsnm = '{0}::{1}_{2}'.format(
                self.fatal_detail_ns, i.name, annclsprefix)
            for midx, m in enumerate(i.members):
                sns('      {0}::{1}_{2}::{3}{4}'.format(
                    self.fatal_detail_ns, i.name, mnfclsprefix, _cpp_name(m),
                    ',' if midx + 1 < len(i.members) else ''))
            sns('  >,')
            # MembersAnnotations
            sns('  {0}::members,'.format(annclsnm))

            # Metadata
            self._render_fatal_type_common_metadata(
                annclsnm, i.type_id, sns, '  ')
            sns(');')

        return (aliases, order, result)

    def _generate_fatal_typedef_impl(self, sg, program, aliases, order, result):
        name = self._program.name
        safe_ns = self._get_namespace().replace('.', '_')
        annclsprefix = '{0}_{1}__struct_unique_annotations'.format(
            safe_ns, name)
        mnfclsprefix = '{0}_{1}__struct_unique_member_info_list'.format(
            safe_ns, name)
        with sg.namespace('apache.thrift.detail').scope as detail:
            for i, _alias, ttype, ns_prefix in aliases:
                string_ref = self._set_fatal_string(i.symbolic)
                result[i.symbolic] = (i.symbolic, string_ref, string_ref)
                order.append(i.symbolic)
                detail('THRIFT_REGISTER_STRUCT_TRAITS(')
                # Struct
                detail('  {0}{1},'.format(ns_prefix, i.symbolic))
                # Name
                detail('  {0}{1},'.format(ns_prefix, self._get_fatal_string_id(
                    i.symbolic)))
                # MembersInfo
                detail('  {0}{1}::{2}_{3},'.format(
                    ns_prefix, self.fatal_detail_ns, i.symbolic, mnfclsprefix))
                # Info
                detail('  ::fatal::list<')
                annclsnm = '{0}{1}::{2}_{3}'.format(
                    ns_prefix, self.fatal_detail_ns, ttype.name, annclsprefix)
                for midx, m in enumerate(ttype.members):
                    detail('      {0}{1}::{2}_{3}::{4}{5}'.format(
                           ns_prefix, self.fatal_detail_ns,
                           i.symbolic, mnfclsprefix, _cpp_name(m),
                           ',' if midx + 1 < len(ttype.members) else ''))
                detail('  >,')
                # MembersAnnotations
                detail('  {0}::members,'.format(annclsnm))
                # Metadata
                self._render_fatal_type_common_metadata(
                    annclsnm, ttype.type_id, detail, '  ', ns_prefix)
                detail(');')

        return (order, result)

    def _generate_fatal_constant(self, program):
        name = self._program.name
        ns = self._get_original_namespace()

        with self._make_context(name + '_fatal_constant') as context, \
                get_global_scope(CppPrimitiveFactory, context) as sg:
            sg('#include "{0}"'.format(self._with_include_prefix(
                self._program, name + '_fatal_types.h')))
            sg()
            if len(ns) > 0:
                with sg.namespace(ns).scope as sns:
                    return self._generate_fatal_constant_impl(sns, program)
            else:
                return self._generate_fatal_constant_impl(sg, program)

    def _generate_fatal_constant_impl(self, sns, program):
        result = []
        for i in program.consts:
            string_ref = self._set_fatal_string(i.name)
            result.append((i.name, string_ref, string_ref))
        return (result, result)

    def _generate_fatal_service(self, program):
        name = self._program.name
        ns = self._get_original_namespace()
        with self._make_context(name + '_fatal_service') as context, \
                get_global_scope(CppPrimitiveFactory, context) as sg:
            sg('#include "{0}"'.format(self._with_include_prefix(
                self._program, name + '_types.h')))

            sg()
            if len(ns) > 0:
                with sg.namespace(ns).scope as sns:
                    return self._generate_fatal_service_impl(sns, program)
            else:
                return self._generate_fatal_service_impl(sg, program)

    def _generate_fatal_service_impl(self, sns, program):
        with sns.namespace(self.fatal_detail_ns).scope:
            for s in program.services:
                for m in s.functions:
                    self._set_fatal_string(m.name)
                    for a in m.arglist.members:
                        self._set_fatal_string(a.name)
        result = []
        for i in program.services:
            string_ref = self._set_fatal_string(i.name)
            result.append((i.name, string_ref, string_ref))
        return (result, result)

    # ==========================================================================
    # FATAL REFLECTION CODE - end
    # ==========================================================================

    def _make_context(self, filename):
        'Convenience method to get the context and outputs for some file pair'
        # open files and instantiate outputs
        output_h = self._write_to(filename + '.h')

        header_path = self._with_include_prefix(self._program, filename)

        context = CppOutputContext(output_h, header_path)

        print(self._autogen_comment, file=context.outputs)
        return context

    @property
    def out_dir(self):
        return os.path.join(self._out_path, self._out_dir_base)

    def in_out_dir(self, filename):
        return os.path.join(self.out_dir, filename)

    # TODO add out_dir(self, program) as well?

    def _include_prefix(self, program, dir_base):
        #assert isinstance(program, frontend.t_program)
        ip = program.include_prefix
        if not ip:
            if not self.flag_include_prefix:
                return ip
            else:
                return self.flag_include_prefix + "/gen-cpp2/"
        if ip.startswith("/"):
            return self.flag_include_prefix + "/gen-cpp2/"
        return ip + "gen-cpp2/"

    def _out_include_prefix(self, program):
        return self._include_prefix(program, self._out_dir_base)

    def _with_include_prefix(self, program, *args):
        return os.path.join(self._out_include_prefix(program), *args)

    def _write_to(self, to):
        return IndentedOutput(open(self.in_out_dir(to), 'w'))

    def init_generator(self):
        # Make output directory
        try:
            os.mkdir(self.out_dir)
        except OSError as exc:
            if exc.errno == errno.EEXIST and os.path.isdir(self.out_dir):
                pass
            else:
                raise

    def close_generator(self):
        pass

    def generate_program(self):
        self.init_generator()
        self._generate_fatal(self.program)
        self.close_generator()

    def _generate_comment(self, text, style='auto'):
        'Style = block, line or auto'
        lines = text.split('\n')
        if style == 'auto':
            style = len(lines) > 1 and 'block' or 'line'
        if style == 'block':
            return '\n'.join(chain(('/**',), \
                    (' * {0}'.format(line) for line in lines),
                    (' */',)))
        elif style == 'line':
            return '\n'.join('// {0}'.format(line) for line in lines)
        else:
            raise NotImplementedError

# register the generator factory
t_generator.GeneratorFactory(CppGenerator)
