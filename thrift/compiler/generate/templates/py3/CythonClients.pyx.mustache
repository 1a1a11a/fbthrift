{{!

  Copyright 2016 Facebook, Inc.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

}}{{!

Generates a top-level file to be imported in the user's client code.

The generated file is pretty big, but the bulk of the generation is done inside
the ClientCallbacks partial.

}}
{{> AutoGeneratedPy}}
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t
from libcpp.vector cimport vector as vector
from libcpp.set cimport set as cset
from libcpp.map cimport map as cmap
from cython.operator cimport dereference as deref
from cpython.ref cimport PyObject
from thrift.py3.client cimport EventBase, make_py3_client, py3_get_exception
from thrift.py3.client import get_event_base
from thrift.py3.folly cimport cFollyEventBase, cFollyTry, cFollyUnit, c_unit

import asyncio
import sys
import traceback

cimport {{#program:py3Namespaces}}{{value}}.{{/program:py3Namespaces}}{{program:name}}.types
from {{#program:py3Namespaces}}{{value}}.{{/program:py3Namespaces}}{{program:name}}.clients_wrapper cimport move
{{#program:includeNamespaces}}
cimport {{#includeNamespace}}{{value}}.{{/includeNamespace}}types
import {{#includeNamespace}}{{value}}.{{/includeNamespace}}types
cimport {{#includeNamespace}}{{value}}.{{/includeNamespace}}clients
import {{#includeNamespace}}{{value}}.{{/includeNamespace}}clients
{{/program:includeNamespaces}}

{{#program:services}}
from {{#program:py3Namespaces}}{{value}}.{{/program:py3Namespaces}}{{program:name}}.clients_wrapper cimport c{{service:name}}AsyncClient, c{{service:name}}ClientWrapper
{{#service:extends}}
from {{#service:py3Namespaces}}{{value}}.{{/service:py3Namespaces}}{{service:programName}}.clients_wrapper cimport c{{service:name}}ClientWrapper
{{/service:extends}}
{{/program:services}}

{{> ClientCallbacks}}

{{#program:services}}
cdef class {{service:name}}{{#service:extends}}({{!
  }}{{#service:py3Namespaces}}{{value}}.{{/service:py3Namespaces}}{{!
    }}{{service:programName}}.clients.{{service:name}}{{!
  }}){{/service:extends}}:

    def __init__(self, *args, **kwds):
        raise TypeError('Use {{service:name}}.connect() instead.')

    def __cinit__(self, loop):
        self.loop = loop

    @staticmethod
    cdef _{{program:name}}_{{service:name}}_set_client({{service:name}} inst, shared_ptr[c{{service:name}}ClientWrapper] c_obj):
        """So the class hierarchy talks to the correct pointer type"""
        inst._{{program:name}}_{{service:name}}_client = c_obj
{{#service:extends}}
        {{#service:py3Namespaces}}{{value}}.{{/service:py3Namespaces}}{{service:programName}}.clients.{{service:name}}._{{service:programName}}_{{service:name}}_set_client(inst, <shared_ptr[c{{service:name}}ClientWrapper]>c_obj)
{{/service:extends}}

    @staticmethod
    async def connect(str host, int port, loop=None):
        loop = loop or asyncio.get_event_loop()
        future = loop.create_future()
        future.loop = loop
        eb = await get_event_base(loop)
        cdef string _host = host.encode('UTF-8')
        make_py3_client[c{{service:name}}AsyncClient, c{{service:name}}ClientWrapper](
            (<EventBase> eb)._folly_event_base,
            _host,
            port,
            0,
            made_{{service:name}}_py3_client_callback,
            future)
        return await future

    {{#service:functions}}
    def {{function:name}}(
            self{{#function:args}},
            arg_{{field:name}}{{/function:args}}):
        future = self.loop.create_future()
        future.loop = self.loop
        deref(self._{{#program:py3Namespaces}}{{value}}_{{/program:py3Namespaces}}{{program:name}}_{{service:name}}_client).{{function:name}}({{#function:args}}
            {{#field:type}}{{> CythonPythonToCppArg}}{{/field:type}},{{/function:args}}
            {{service:name}}_{{function:name}}_callback,
            future)
        return future

    {{/service:functions}}

{{! One callback for receiving the created C++ wrapper class and wrapping it in
    a python class. }}
cdef void made_{{service:name}}_py3_client_callback(
        PyObject* future,
        cFollyTry[shared_ptr[c{{service:name}}ClientWrapper]] result) with gil:
    cdef object pyfuture = <object> future
    if result.hasException():
        try:
            result.exception().throwException()
        except:
            pyfuture.loop.call_soon_threadsafe(pyfuture.set_exception, sys.exc_info()[1])
    else:
        pyclient = <{{service:name}}> {{service:name}}.__new__({{service:name}}, pyfuture.loop)
        {{service:name}}._{{program:name}}_{{service:name}}_set_client(pyclient, result.value())
        pyfuture.loop.call_soon_threadsafe(pyfuture.set_result, pyclient)

{{/program:services}}
