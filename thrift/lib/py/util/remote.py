"""
PyRemote

Used by PyRemote files generated by
  /thrift/compiler/generate/t_py_generator.cc

Remote.run is the interface used by the generated code.
Based on whether --host or --url is specified as a commandline option,
either a RemoteHostClient or RemoteHttpClient is instantiated to
handle the request.

Additional remote client types (subclasses of RemoteClient) can be
registered with the Remote class to define different ways of specifying a
host or communicating with the host. When registering a new client type,
you can specify the option used to select that type (i.e., url) with the
SELECTOR_OPTIONS attribute, and you can specify additional commandline options
with the CMDLINE_OPTIONS attribute. See the implementations of RemoteHostClient
and RemoteHttpClient for examples.
"""

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import argparse
import json
import os
import pprint
import sys
import traceback

from six.moves.urllib.parse import urlparse
from six import string_types
from thrift import Thrift
from thrift.transport import TTransport, TSocket, TSSLSocket, THttpClient
from thrift.transport.THeaderTransport import THeaderTransport
from thrift.transport.TFuzzyHeaderTransport import TFuzzyHeaderTransport
from thrift.protocol import TBinaryProtocol, TCompactProtocol, \
    TJSONProtocol, THeaderProtocol, TSimpleJSONProtocol


class Function(object):
    """Metadata for a service method"""
    def __init__(self, fn_name, svc_name, return_type, args):
        self.fn_name = fn_name
        self.svc_name = svc_name
        self.return_type = return_type
        self.args = args


def print_functions(functions, service_names, out, local_only=False):
    """Print all the functions available from this thrift service"""
    fns_by_service_name = {svc_name: {} for svc_name in service_names}
    for fn in functions.values():
        fns_by_service_name[fn.svc_name][fn.fn_name] = fn

    svc_names = service_names[0:1] if local_only else \
                    reversed(service_names)
    for svc_name in svc_names:
        out.write('Functions in %s:\n' % (svc_name,))
        for fn_name, fn in sorted(fns_by_service_name[svc_name].items()):
            if fn.return_type is None:
                out.write('  oneway void ')
            else:
                out.write('  %s ' % (fn.return_type,))
            out.write(fn_name + '(')
            out.write(', '.join('%s %s' % (type, name)
                                for type, name, true_type in fn.args))
            out.write(')\n')


format_to_helper = {
    "input": {},
    "output": {},
}


def add_format(name, format_type):
    lookup_table = format_to_helper[format_type]

    def builder(func):
        if name in lookup_table:
            raise ValueError("Format name '{}' is used twice".format(name))
        lookup_table[name] = func
        return func
    return builder


def get_helper_for_format(name, format_type):
    printer = format_to_helper[format_type].get(name)
    if printer is None:
        sys.stderr.write("Invalid {} format: {}\n".format(format_type, name))
        sys.exit(os.EX_USAGE)
    return printer


@add_format("python", "output")
def __python_output_printer(ret):
    if isinstance(ret, string_types):
        print(ret)
    else:
        pprint.pprint(ret, indent=2)


def __thrift_to_json(x):
    trans = TTransport.TMemoryBuffer()
    proto = TSimpleJSONProtocol.TSimpleJSONProtocol(trans)
    x.write(proto)
    return json.loads(trans.getvalue())


@add_format("json", "output")
def __json_output_printer(ret):
    """
    Python object
    {
        "foo": [
            ThriftStructB(
                x=2
            ),
        ],
        "x": ["%set is nice", 9,8,7, set("blah % blah", 4, 5, 6)],
        "bar": ThriftStructA(
            x=1,
            y="b",
            z=[1,2,3]
        ),
    }

    <=>
    JSON object
    {
        "foo": [
            {"x": 2}
        ],
        "x": ["%set is nice", 9,8,7, ["blah % blah", 4, 5, 6]],
        "bar": {
            "x": 1,
            "y": "b",
            "z": [1,2,3]
        }
    }

    There is no need to handle the type ambiguity between Json dict and
        thrift structs, because pyremote knows what type the services want,
        and we simply try to convert them to that type.

    Also, the exact form of dictionaries produced for Thrift structs may differ
        based across different Thrift versions.
    """
    print(json.dumps(ret, default=__thrift_to_json))


class RemoteClient(object):
    def __init__(self, functions, service_names, service_class,
                 ttypes, print_usage, default_port):
        self.functions = functions
        self.service_names = service_names
        self.service_class = service_class
        self.ttypes = ttypes
        self.print_usage = print_usage
        self.default_port = default_port

    def _exit(self, error_message=None, status=os.EX_USAGE, err_out=sys.stderr):
        """ Report an error, show help information, and exit the program """
        if error_message is not None:
            print("Error: %s" % error_message, file=err_out)

        if status is os.EX_USAGE:
            self.print_usage(err_out)

        if (self.functions is not None and
                status in {os.EX_USAGE, os.EX_CONFIG}):
            print_functions(self.functions, self.service_names, err_out)

        sys.exit(status)

    def _validate_options(self, options):
        """Check option validity and call _exit if there is an error"""
        pass

    def _get_client(self, options):
        """Get the thrift client that will be used to make method calls"""
        raise TypeError("_get_client should be called on "
                        "a subclass of RemoteClient")

    def _close_client(self):
        """After making the method call, do any cleanup work"""
        pass

    def _eval_arg(self, arg, thrift_types):
        """Evaluate a commandline argument within the scope of the IF types"""
        code_globals = {}
        code_globals.update(thrift_types)
        # Explicitly compile the code so that it does not inherit our
        # __future__ directives imported above.  In particular this ensures
        # that string literals are not treated as unicode unless explicitly
        # qualified as such.
        code = compile(arg, '<command_line>', 'eval', 0, 1)
        return eval(code, code_globals)

    def _process_fn_args(self, fn, args, eval_all=False):
        """Proccess positional commandline args as function arguments"""
        if len(args) != len(fn.args):
            self._exit(error_message=('"%s" expects %d arguments '
                       '(received %d)') % (fn.fn_name, len(fn.args), len(args)))

        # Get all custom Thrift types
        thrift_types = {}
        for key in dir(self.ttypes):
            thrift_types[key] = getattr(self.ttypes, key)

        fn_args = []
        for arg, arg_info in zip(args, fn.args):
            if arg_info[2] == 'string' and not eval_all:
                # For ease-of-use, we don't eval string arguments, simply so
                # users don't have to wrap the arguments in quotes
                fn_args.append(arg)
                continue
            try:
                value = self._eval_arg(arg, thrift_types)
            except Exception:
                traceback.print_exc(file=sys.stderr)
                self._exit(error_message='error parsing argument "%s"' % (arg,),
                           status=os.EX_DATAERR)
            fn_args.append(value)

        return fn_args

    def _process_args(self, args):
        """Populate instance data using commandline arguments"""
        fn_name = args.function_name
        if fn_name not in self.functions:
            self._exit(error_message='Unknown function "%s"' % fn_name,
                       status=os.EX_CONFIG)
        else:
            function = self.functions[fn_name]

        function_args = self._process_fn_args(function, args.function_args,
                                              args.evalargs)

        self._validate_options(args)
        return function.fn_name, function_args

    def _execute(self, fn_name, fn_args, args):
        """Make the requested call.
        Assumes _parse_args() and _process_args() have already been called.
        """
        client = self._get_client(args)

        # Call the function
        method = getattr(client, fn_name)
        try:
            ret = method(*fn_args)
        except Thrift.TException as e:
            ret = 'Exception:\n' + str(e)

        args.output_format(ret)

        transport = client._iprot.trans
        if isinstance(transport, THeaderTransport):
            response_headers = transport.get_headers()
            if response_headers is not None and len(response_headers) > 0:
                print("Response headers:")
                pprint.pprint(transport.get_headers(), indent=2)

        self._close_client()

    def run(self, args):
        fn_name, fn_args = self._process_args(args)
        self._execute(fn_name, fn_args, args)
        self._exit(status=0)


class RemoteTransportClient(RemoteClient):
    """Abstract class for clients with transport manually opened and closed"""
    CMDLINE_OPTIONS = [
        (
            ('-f', '--framed'),
            {
                'action': 'store_true',
                'default': False,
                'help': 'Use framed transport'
            }
        ), (
            ('-s', '--ssl'),
            {
                'action': 'store_true',
                'default': False,
                'help': 'Use SSL socket'
            }
        ), (
            ('-U', '--unframed'),
            {
                'action': 'store_true',
                'default': False,
                'help': 'Use unframed transport'
            }
        ), (
            ('-j', '--json'),
            {
                'action': 'store_true',
                'default': False,
                'help': 'Use TJSONProtocol'
            }
        ), (
            ('-c', '--compact'),
            {
                'action': 'store_true',
                'default': False,
                'help': 'Use TCompactProtocol'
            }
        ), (
            ('-H', '--headers'),
            {
                'action': 'store',
                'metavar': 'HEADERS_DICT',
                'help':
                'Python code to eval() into a dict of write headers',
            }
        ), (
            ('-I', '--stdin'),
            {
                'action': 'store_true',
                'default': False,
                'help': 'Take function arguments as a json list of strings '
                'on stdin.  Implies --evalargs.',
            }
        ), (
            ('-e', '--evalargs'),
            {
                'action': 'store_true',
                'default': False,
                'help': 'Call eval() on all arguments, including strings',
            }
        ),
    ]

    def _get_client_by_transport(self, options, transport, socket=None):
        # Create the protocol and client
        if options.json:
            protocol = TJSONProtocol.TJSONProtocol(transport)
        elif options.compact:
            protocol = TCompactProtocol.TCompactProtocol(transport)

        # No explicit option about protocol is specified. Try to infer.
        elif options.framed or options.unframed:
            protocol = TBinaryProtocol.TBinaryProtocolAccelerated(transport)

        elif socket is not None:
            # If json, compact, framed, and unframed are not specified,
            # THeaderProtocol is the default. Create a protocol using either
            # fuzzy or non-fuzzy transport depending on if options.fuzz is set.
            if options.fuzz is not None:
                transport = TFuzzyHeaderTransport(
                    socket, fuzz_fields=options.fuzz, verbose=True)
            else:
                transport = THeaderTransport(socket)
                if options.headers is not None:
                    try:
                        parsed_headers = eval(options.headers)
                    except Exception:
                        self._exit(
                            error_message='Request headers (--headers) argument'
                                          ' failed eval')
                    if not isinstance(parsed_headers, dict):
                        self._exit(
                            error_message='Request headers (--headers) argument'
                                          ' must evaluate to a dict')
                    for header_name, header_value in parsed_headers.items():
                        transport.set_header(header_name, header_value)
            protocol = THeaderProtocol.THeaderProtocol(transport)
        else:
            self._exit(error_message=('No valid protocol '
                                      'specified for %s' % (type(self))),
                       status=os.EX_USAGE)

        transport.open()
        self._transport = transport

        client = self.service_class.Client(protocol)

        return client

    def close_client(self):
        self._transport.close()

    def _validate_options(self, options):
        super(RemoteTransportClient, self)._validate_options(options)
        if options.framed and options.unframed:
            self._exit(error_message='cannot specify both '
                       '--framed and --unframed')

    def _parse_host_port(self, value, default_port):
        parts = value.rsplit(':', 1)
        if len(parts) == 1:
            return (parts[0], default_port)
        try:
            port = int(parts[1])
        except ValueError:
            raise ValueError('invalid port: ' + parts[1])
        return (parts[0], port)


class RemoteHostClient(RemoteTransportClient):
    SELECTOR_OPTIONS = 'host'
    CMDLINE_OPTIONS = list(RemoteTransportClient.CMDLINE_OPTIONS) + [(
        ('-h', '--host'),
        {
            'action': 'store',
            'metavar': 'HOST[:PORT]',
            'help': 'The host and port to connect to'
        }
    ), (
        ('-F', '--fuzz'),
        {
            'type': str,
            'nargs': '*',
            'default': None,
            'help': ('Use TFuzzyHeaderTransport to send a fuzzed message for '
                     'testing thrift transport. Optionally include a list of '
                     'message field names to fuzz after this flag. Fields: ' +
                     ', '.join(TFuzzyHeaderTransport.fuzzable_fields))
        }
    )]

    def _validate_options(self, options):
        super(RemoteHostClient, self)._validate_options(options)
        if (options.fuzz is not None and
            any([options.framed, options.unframed,
                 options.json, options.compact])):
            self._exit(error_message=('Transport fuzzing only supported for '
                                      'THeaderTransport (no framed, unframed, '
                                      'json, or compact.)'),
                       status=os.EX_USAGE)

    def _get_client(self, options):
        host, port = self._parse_host_port(options.host, self.default_port)
        socket = (TSSLSocket.TSSLSocket(host, port) if options.ssl
                  else TSocket.TSocket(host, port))
        if options.framed:
            transport = TTransport.TFramedTransport(socket)
        else:
            transport = TTransport.TBufferedTransport(socket)
        return self._get_client_by_transport(options, transport, socket=socket)


class RemoteHttpClient(RemoteTransportClient):
    SELECTOR_OPTIONS = 'url'
    CMDLINE_OPTIONS = list(RemoteTransportClient.CMDLINE_OPTIONS) + [(
        ('-u', '--url'),
        {
            'action': 'store',
            'help': 'The URL to connect to, for HTTP transport'
        }
    )]

    def _get_client(self, options):
        url = urlparse(options.url)
        host, port = self._parse_host_port(url[1], 80)
        transport = THttpClient.THttpClient(options.url)
        return self._get_client_by_transport(options, transport)

    def _validate_options(self, options):
        """Check if there are any option inconsistencies, and exit if so"""
        super(RemoteHttpClient, self)._validate_options(options)
        if not any([options.unframed, options.json]):
            self._exit(error_message='can only specify --url with '
                       '--unframed or --json')


class RemoteUNIXDomainClient(RemoteTransportClient):
    SELECTOR_OPTIONS = 'path'
    CMDLINE_OPTIONS = list(RemoteTransportClient.CMDLINE_OPTIONS) + [(
        ('-p', '--path'),
        {
            'action': 'store',
            'help': 'The path of the socket to use'
        }
    )]

    def _get_client(self, options):
        socket = TSocket.TSocket(unix_socket=options.path)
        if options.framed:
            transport = TTransport.TFramedTransport(socket)
        else:
            transport = TTransport.TBufferedTransport(socket)
        return self._get_client_by_transport(options, transport, socket=socket)


class Namespace(object):
    def __init__(self, attrs=None):
        if attrs is not None:
            self.__dict__.update(attrs)

    def __getitem__(self, key):
        return self.__dict__[key]

    def __setitem__(self, key, value):
        self.__dict__[key] = value


class Remote(object):
    __client_types = set()
    __occupied_args = {}
    __parser = argparse.ArgumentParser(add_help=False)

    @classmethod
    def register_cmdline_options(cls, cmdline_options):
        for args, kwargs in cmdline_options:
            is_repeated = False
            for arg in args:
                if arg in cls.__occupied_args:
                    if cls.__occupied_args[arg] != kwargs:
                        raise ValueError('Redefinition of {}'.format(arg))
                    is_repeated = True
            if is_repeated:
                continue
            cls.__occupied_args.update({x: kwargs for x in args})
            cls.__parser.add_argument(*args, **kwargs)

    @classmethod
    def register_client_type(cls, client_type):
        if not issubclass(client_type, RemoteClient):
            raise TypeError(('Remote client must be of type RemoteClient. '
                             'Got type %s.' % client_type.__name__))
        if client_type is RemoteClient:
            raise TypeError(('Remote client must be a strict subclass '
                             'of RemoteClient.'))
        if not hasattr(client_type, 'SELECTOR_OPTIONS'):
            raise AttributeError(('Remote client must have a '
                                  'SELECTOR_OPTIONS field.'))

        cls.__client_types.add(client_type)
        cls.register_cmdline_options(client_type.CMDLINE_OPTIONS)

    @classmethod
    def _exit_usage_error(cls, message):
        sys.stderr.write('ERROR: ' + message + '\n')
        cls.__parser.print_help(sys.stderr)
        sys.exit(os.EX_USAGE)

    @classmethod
    def _get_client_type(cls, options):
        matching_types = [ct for ct in cls.__client_types if
                          getattr(options, ct.SELECTOR_OPTIONS) is not None]
        if len(matching_types) != 1:
            cls._exit_usage_error('Must specify exactly one of [%s]' % (
                ', '.join('--%s' % ct.SELECTOR_OPTIONS
                          for ct in cls.__client_types)))
        else:
            return matching_types[0]

    @classmethod
    def _parse_cmdline_options(cls, argv):
        cls.register_cmdline_options((
            (
                ('-ofmt', '--output-format', ),
                {
                    'action': 'store',
                    'default': 'python',
                    'type': lambda x: get_helper_for_format(x, "output"),
                    'help': (
                        'Change the output format for the return value. The '
                        'default is "python", which direclty prints out strings'
                        'and pprint() other types. Available formats: {}.'
                    ).format(','.join(format_to_helper["output"].keys()))
                },
            ),
            (
                ('--help', ),
                {'action': 'help'},
            ),
            (
                ('-la', '--list-all-functions'),
                {'action': 'store_true'},
            ),
            (
                ('-l', '--list-functions', ),
                {'action': 'store_true'},
            ),
            (
                ('function_name', ),
                {'nargs': '?', 'help': 'Name of the remote function to call'},
            ),
            (
                ('function_args', ),
                {'nargs': '*', 'help': 'Arguments for the remote function'},
            ),
        ))
        try:
            return cls.__parser.parse_args(argv[1:])
        except BaseException:
            sys.exit(os.EX_USAGE)

    @classmethod
    def run(cls, functions, service_names, service_class,
            ttypes, argv, default_port=9090):
        args = cls._parse_cmdline_options(argv)
        if args.list_all_functions and args.list_functions:
            cls._exit_usage_error(
                'Please do not specify both --list-all-functions'
                ' and --list-functions.'
            )
        if args.list_all_functions:
            print_functions(functions, service_names, sys.stdout, local_only=False)
            return
        if args.list_functions:
            print_functions(functions, service_names, sys.stdout, local_only=True)
            return
        if args.function_name is None:
            cls._exit_usage_error('Please specify function_name.')
        if args.stdin:
            if args.function_args:
                cls._exit_usage_error(
                    'Please do no specify both --stdin and '
                    '[function_args] arguments.'
                )
            args.function_args = json.load(sys.stdin)
            args.evalargs = True
        client_type = cls._get_client_type(args)
        client = client_type(functions, service_names, service_class, ttypes,
                             cls.__parser.print_help, default_port)
        client.run(args)


Remote.register_client_type(RemoteHostClient)
Remote.register_client_type(RemoteHttpClient)
Remote.register_client_type(RemoteUNIXDomainClient)
